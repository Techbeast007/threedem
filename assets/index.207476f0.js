const Br=function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const A of i)if(A.type==="childList")for(const o of A.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&n(o)}).observe(document,{childList:!0,subtree:!0});function e(i){const A={};return i.integrity&&(A.integrity=i.integrity),i.referrerpolicy&&(A.referrerPolicy=i.referrerpolicy),i.crossorigin==="use-credentials"?A.credentials="include":i.crossorigin==="anonymous"?A.credentials="omit":A.credentials="same-origin",A}function n(i){if(i.ep)return;i.ep=!0;const A=e(i);fetch(i.href,A)}};Br();/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */class Ne{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const n=this._listeners[t];if(n!==void 0){const i=n.indexOf(e);i!==-1&&n.splice(i,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const e=this._listeners[t.type];if(e!==void 0){t.target=this;const n=e.slice(0);for(let i=0,A=n.length;i<A;i++)n[i].call(this,t);t.target=null}}}const Ct=[];for(let r=0;r<256;r++)Ct[r]=(r<16?"0":"")+r.toString(16);let cn=1234567;const qe=Math.PI/180,un=180/Math.PI;function Ie(){const r=4294967295*Math.random()|0,t=4294967295*Math.random()|0,e=4294967295*Math.random()|0,n=4294967295*Math.random()|0;return(Ct[255&r]+Ct[r>>8&255]+Ct[r>>16&255]+Ct[r>>24&255]+"-"+Ct[255&t]+Ct[t>>8&255]+"-"+Ct[t>>16&15|64]+Ct[t>>24&255]+"-"+Ct[63&e|128]+Ct[e>>8&255]+"-"+Ct[e>>16&255]+Ct[e>>24&255]+Ct[255&n]+Ct[n>>8&255]+Ct[n>>16&255]+Ct[n>>24&255]).toUpperCase()}function Kt(r,t,e){return Math.max(t,Math.min(e,r))}function kn(r,t){return(r%t+t)%t}function Ke(r,t,e){return(1-e)*r+e*t}function jn(r){return(r&r-1)==0&&r!==0}function Wi(r){return Math.pow(2,Math.ceil(Math.log(r)/Math.LN2))}function zi(r){return Math.pow(2,Math.floor(Math.log(r)/Math.LN2))}var kr=Object.freeze({__proto__:null,DEG2RAD:qe,RAD2DEG:un,generateUUID:Ie,clamp:Kt,euclideanModulo:kn,mapLinear:function(r,t,e,n,i){return n+(r-t)*(i-n)/(e-t)},inverseLerp:function(r,t,e){return r!==t?(e-r)/(t-r):0},lerp:Ke,damp:function(r,t,e,n){return Ke(r,t,1-Math.exp(-e*n))},pingpong:function(r,t=1){return t-Math.abs(kn(r,2*t)-t)},smoothstep:function(r,t,e){return r<=t?0:r>=e?1:(r=(r-t)/(e-t))*r*(3-2*r)},smootherstep:function(r,t,e){return r<=t?0:r>=e?1:(r=(r-t)/(e-t))*r*r*(r*(6*r-15)+10)},randInt:function(r,t){return r+Math.floor(Math.random()*(t-r+1))},randFloat:function(r,t){return r+Math.random()*(t-r)},randFloatSpread:function(r){return r*(.5-Math.random())},seededRandom:function(r){return r!==void 0&&(cn=r%2147483647),cn=16807*cn%2147483647,(cn-1)/2147483646},degToRad:function(r){return r*qe},radToDeg:function(r){return r*un},isPowerOfTwo:jn,ceilPowerOfTwo:Wi,floorPowerOfTwo:zi,setQuaternionFromProperEuler:function(r,t,e,n,i){const A=Math.cos,o=Math.sin,a=A(e/2),s=o(e/2),l=A((t+n)/2),c=o((t+n)/2),u=A((t-n)/2),h=o((t-n)/2),d=A((n-t)/2),g=o((n-t)/2);switch(i){case"XYX":r.set(a*c,s*u,s*h,a*l);break;case"YZY":r.set(s*h,a*c,s*u,a*l);break;case"ZXZ":r.set(s*u,s*h,a*c,a*l);break;case"XZX":r.set(a*c,s*g,s*d,a*l);break;case"YXY":r.set(s*d,a*c,s*g,a*l);break;case"ZYZ":r.set(s*g,s*d,a*c,a*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}});class ft{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,i=t.elements;return this.x=i[0]*e+i[3]*n+i[6],this.y=i[1]*e+i[4]*n+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),i=Math.sin(e),A=this.x-t.x,o=this.y-t.y;return this.x=A*n-o*i+t.x,this.y=A*i+o*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}ft.prototype.isVector2=!0;class Wt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,A,o,a,s,l){const c=this.elements;return c[0]=t,c[1]=i,c[2]=a,c[3]=e,c[4]=A,c[5]=s,c[6]=n,c[7]=o,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,A=this.elements,o=n[0],a=n[3],s=n[6],l=n[1],c=n[4],u=n[7],h=n[2],d=n[5],g=n[8],p=i[0],m=i[3],f=i[6],T=i[1],S=i[4],b=i[7],I=i[2],R=i[5],E=i[8];return A[0]=o*p+a*T+s*I,A[3]=o*m+a*S+s*R,A[6]=o*f+a*b+s*E,A[1]=l*p+c*T+u*I,A[4]=l*m+c*S+u*R,A[7]=l*f+c*b+u*E,A[2]=h*p+d*T+g*I,A[5]=h*m+d*S+g*R,A[8]=h*f+d*b+g*E,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],i=t[2],A=t[3],o=t[4],a=t[5],s=t[6],l=t[7],c=t[8];return e*o*c-e*a*l-n*A*c+n*a*s+i*A*l-i*o*s}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],A=t[3],o=t[4],a=t[5],s=t[6],l=t[7],c=t[8],u=c*o-a*l,h=a*s-c*A,d=l*A-o*s,g=e*u+n*h+i*d;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const p=1/g;return t[0]=u*p,t[1]=(i*l-c*n)*p,t[2]=(a*n-i*o)*p,t[3]=h*p,t[4]=(c*e-i*s)*p,t[5]=(i*A-a*e)*p,t[6]=d*p,t[7]=(n*s-l*e)*p,t[8]=(o*e-n*A)*p,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,i,A,o,a){const s=Math.cos(A),l=Math.sin(A);return this.set(n*s,n*l,-n*(s*o+l*a)+o+t,-i*l,i*s,-i*(-l*o+s*a)+a+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),i=this.elements,A=i[0],o=i[3],a=i[6],s=i[1],l=i[4],c=i[7];return i[0]=e*A+n*s,i[3]=e*o+n*l,i[6]=e*a+n*c,i[1]=-n*A+e*s,i[4]=-n*o+e*l,i[7]=-n*a+e*c,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}let Ce;Wt.prototype.isMatrix3=!0;class We{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Ce===void 0&&(Ce=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),Ce.width=t.width,Ce.height=t.height;const n=Ce.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Ce}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let jr=0;class Bt extends Ne{constructor(t=Bt.DEFAULT_IMAGE,e=Bt.DEFAULT_MAPPING,n=1001,i=1001,A=1006,o=1008,a=1023,s=1009,l=1,c=3e3){super(),Object.defineProperty(this,"id",{value:jr++}),this.uuid=Ie(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=A,this.minFilter=o,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=s,this.offset=new ft(0,0),this.repeat=new ft(1,1),this.center=new ft(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Wt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=Ie()),!e&&t.images[i.uuid]===void 0){let A;if(Array.isArray(i)){A=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?A.push(On(i[o].image)):A.push(On(i[o]))}else A=On(i);t.images[i.uuid]={uuid:i.uuid,url:A}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==300)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case 1e3:t.x=t.x-Math.floor(t.x);break;case 1001:t.x=t.x<0?0:1;break;case 1002:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x)}if(t.y<0||t.y>1)switch(this.wrapT){case 1e3:t.y=t.y-Math.floor(t.y);break;case 1001:t.y=t.y<0?0:1;break;case 1002:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y)}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}function On(r){return typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&r instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap?We.getDataURL(r):r.data?{data:Array.prototype.slice.call(r.data),width:r.width,height:r.height,type:r.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}Bt.DEFAULT_IMAGE=void 0,Bt.DEFAULT_MAPPING=300,Bt.prototype.isTexture=!0;class Et{constructor(t=0,e=0,n=0,i=1){this.x=t,this.y=e,this.z=n,this.w=i}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,i){return this.x=t,this.y=e,this.z=n,this.w=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,A=this.w,o=t.elements;return this.x=o[0]*e+o[4]*n+o[8]*i+o[12]*A,this.y=o[1]*e+o[5]*n+o[9]*i+o[13]*A,this.z=o[2]*e+o[6]*n+o[10]*i+o[14]*A,this.w=o[3]*e+o[7]*n+o[11]*i+o[15]*A,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,i,A;const o=.01,a=.1,s=t.elements,l=s[0],c=s[4],u=s[8],h=s[1],d=s[5],g=s[9],p=s[2],m=s[6],f=s[10];if(Math.abs(c-h)<o&&Math.abs(u-p)<o&&Math.abs(g-m)<o){if(Math.abs(c+h)<a&&Math.abs(u+p)<a&&Math.abs(g+m)<a&&Math.abs(l+d+f-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const S=(l+1)/2,b=(d+1)/2,I=(f+1)/2,R=(c+h)/4,E=(u+p)/4,L=(g+m)/4;return S>b&&S>I?S<o?(n=0,i=.707106781,A=.707106781):(n=Math.sqrt(S),i=R/n,A=E/n):b>I?b<o?(n=.707106781,i=0,A=.707106781):(i=Math.sqrt(b),n=R/i,A=L/i):I<o?(n=.707106781,i=.707106781,A=0):(A=Math.sqrt(I),n=E/A,i=L/A),this.set(n,i,A,e),this}let T=Math.sqrt((m-g)*(m-g)+(u-p)*(u-p)+(h-c)*(h-c));return Math.abs(T)<.001&&(T=1),this.x=(m-g)/T,this.y=(u-p)/T,this.z=(h-c)/T,this.w=Math.acos((l+d+f-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}Et.prototype.isVector4=!0;class ze extends Ne{constructor(t,e,n){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new Et(0,0,t,e),this.scissorTest=!1,this.viewport=new Et(0,0,t,e),n=n||{},this.texture=new Bt(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=1,this.texture.generateMipmaps=n.generateMipmaps!==void 0&&n.generateMipmaps,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:1006,this.depthBuffer=n.depthBuffer===void 0||n.depthBuffer,this.stencilBuffer=n.stencilBuffer!==void 0&&n.stencilBuffer,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){this.width===t&&this.height===e&&this.depth===n||(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}ze.prototype.isWebGLRenderTarget=!0;class Ae{constructor(t=0,e=0,n=0,i=1){this._x=t,this._y=e,this._z=n,this._w=i}static slerp(t,e,n,i){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,i)}static slerpFlat(t,e,n,i,A,o,a){let s=n[i+0],l=n[i+1],c=n[i+2],u=n[i+3];const h=A[o+0],d=A[o+1],g=A[o+2],p=A[o+3];if(a===0)return t[e+0]=s,t[e+1]=l,t[e+2]=c,void(t[e+3]=u);if(a===1)return t[e+0]=h,t[e+1]=d,t[e+2]=g,void(t[e+3]=p);if(u!==p||s!==h||l!==d||c!==g){let m=1-a;const f=s*h+l*d+c*g+u*p,T=f>=0?1:-1,S=1-f*f;if(S>Number.EPSILON){const I=Math.sqrt(S),R=Math.atan2(I,f*T);m=Math.sin(m*R)/I,a=Math.sin(a*R)/I}const b=a*T;if(s=s*m+h*b,l=l*m+d*b,c=c*m+g*b,u=u*m+p*b,m===1-a){const I=1/Math.sqrt(s*s+l*l+c*c+u*u);s*=I,l*=I,c*=I,u*=I}}t[e]=s,t[e+1]=l,t[e+2]=c,t[e+3]=u}static multiplyQuaternionsFlat(t,e,n,i,A,o){const a=n[i],s=n[i+1],l=n[i+2],c=n[i+3],u=A[o],h=A[o+1],d=A[o+2],g=A[o+3];return t[e]=a*g+c*u+s*d-l*h,t[e+1]=s*g+c*h+l*u-a*d,t[e+2]=l*g+c*d+a*h-s*u,t[e+3]=c*g-a*u-s*h-l*d,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!t||!t.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,i=t._y,A=t._z,o=t._order,a=Math.cos,s=Math.sin,l=a(n/2),c=a(i/2),u=a(A/2),h=s(n/2),d=s(i/2),g=s(A/2);switch(o){case"XYZ":this._x=h*c*u+l*d*g,this._y=l*d*u-h*c*g,this._z=l*c*g+h*d*u,this._w=l*c*u-h*d*g;break;case"YXZ":this._x=h*c*u+l*d*g,this._y=l*d*u-h*c*g,this._z=l*c*g-h*d*u,this._w=l*c*u+h*d*g;break;case"ZXY":this._x=h*c*u-l*d*g,this._y=l*d*u+h*c*g,this._z=l*c*g+h*d*u,this._w=l*c*u-h*d*g;break;case"ZYX":this._x=h*c*u-l*d*g,this._y=l*d*u+h*c*g,this._z=l*c*g-h*d*u,this._w=l*c*u+h*d*g;break;case"YZX":this._x=h*c*u+l*d*g,this._y=l*d*u+h*c*g,this._z=l*c*g-h*d*u,this._w=l*c*u-h*d*g;break;case"XZY":this._x=h*c*u-l*d*g,this._y=l*d*u-h*c*g,this._z=l*c*g+h*d*u,this._w=l*c*u+h*d*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,i=Math.sin(n);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],i=e[4],A=e[8],o=e[1],a=e[5],s=e[9],l=e[2],c=e[6],u=e[10],h=n+a+u;if(h>0){const d=.5/Math.sqrt(h+1);this._w=.25/d,this._x=(c-s)*d,this._y=(A-l)*d,this._z=(o-i)*d}else if(n>a&&n>u){const d=2*Math.sqrt(1+n-a-u);this._w=(c-s)/d,this._x=.25*d,this._y=(i+o)/d,this._z=(A+l)/d}else if(a>u){const d=2*Math.sqrt(1+a-n-u);this._w=(A-l)/d,this._x=(i+o)/d,this._y=.25*d,this._z=(s+c)/d}else{const d=2*Math.sqrt(1+u-n-a);this._w=(o-i)/d,this._x=(A+l)/d,this._y=(s+c)/d,this._z=.25*d}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Kt(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const i=Math.min(1,e/n);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,i=t._y,A=t._z,o=t._w,a=e._x,s=e._y,l=e._z,c=e._w;return this._x=n*c+o*a+i*l-A*s,this._y=i*c+o*s+A*a-n*l,this._z=A*c+o*l+n*s-i*a,this._w=o*c-n*a-i*s-A*l,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,i=this._y,A=this._z,o=this._w;let a=o*t._w+n*t._x+i*t._y+A*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=o,this._x=n,this._y=i,this._z=A,this;const s=1-a*a;if(s<=Number.EPSILON){const d=1-e;return this._w=d*o+e*this._w,this._x=d*n+e*this._x,this._y=d*i+e*this._y,this._z=d*A+e*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(s),c=Math.atan2(l,a),u=Math.sin((1-e)*c)/l,h=Math.sin(e*c)/l;return this._w=o*u+this._w*h,this._x=n*u+this._x*h,this._y=i*u+this._y*h,this._z=A*u+this._z*h,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Ae.prototype.isQuaternion=!0;class w{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Ui.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Ui.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,i=this.z,A=t.elements;return this.x=A[0]*e+A[3]*n+A[6]*i,this.y=A[1]*e+A[4]*n+A[7]*i,this.z=A[2]*e+A[5]*n+A[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,i=this.z,A=t.elements,o=1/(A[3]*e+A[7]*n+A[11]*i+A[15]);return this.x=(A[0]*e+A[4]*n+A[8]*i+A[12])*o,this.y=(A[1]*e+A[5]*n+A[9]*i+A[13])*o,this.z=(A[2]*e+A[6]*n+A[10]*i+A[14])*o,this}applyQuaternion(t){const e=this.x,n=this.y,i=this.z,A=t.x,o=t.y,a=t.z,s=t.w,l=s*e+o*i-a*n,c=s*n+a*e-A*i,u=s*i+A*n-o*e,h=-A*e-o*n-a*i;return this.x=l*s+h*-A+c*-a-u*-o,this.y=c*s+h*-o+u*-A-l*-a,this.z=u*s+h*-a+l*-o-c*-A,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,i=this.z,A=t.elements;return this.x=A[0]*e+A[4]*n+A[8]*i,this.y=A[1]*e+A[5]*n+A[9]*i,this.z=A[2]*e+A[6]*n+A[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,i=t.y,A=t.z,o=e.x,a=e.y,s=e.z;return this.x=i*s-A*a,this.y=A*o-n*s,this.z=n*a-i*o,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Yn.copy(this).projectOnVector(t),this.sub(Yn)}reflect(t){return this.sub(Yn.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(Kt(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return e*e+n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const i=Math.sin(e)*t;return this.x=i*Math.sin(n),this.y=Math.cos(e)*t,this.z=i*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=i,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,4*e)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,3*e)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}w.prototype.isVector3=!0;const Yn=new w,Ui=new Ae;class Vt{constructor(t=new w(1/0,1/0,1/0),e=new w(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,i=1/0,A=-1/0,o=-1/0,a=-1/0;for(let s=0,l=t.length;s<l;s+=3){const c=t[s],u=t[s+1],h=t[s+2];c<e&&(e=c),u<n&&(n=u),h<i&&(i=h),c>A&&(A=c),u>o&&(o=u),h>a&&(a=h)}return this.min.set(e,n,i),this.max.set(A,o,a),this}setFromBufferAttribute(t){let e=1/0,n=1/0,i=1/0,A=-1/0,o=-1/0,a=-1/0;for(let s=0,l=t.count;s<l;s++){const c=t.getX(s),u=t.getY(s),h=t.getZ(s);c<e&&(e=c),u<n&&(n=u),h<i&&(i=h),c>A&&(A=c),u>o&&(o=u),h>a&&(a=h)}return this.min.set(e,n,i),this.max.set(A,o,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Qe.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return t===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new w),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return t===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new w),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),Gn.copy(e.boundingBox),Gn.applyMatrix4(t.matrixWorld),this.union(Gn));const n=t.children;for(let i=0,A=n.length;i<A;i++)this.expandByObject(n[i]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),e=new w),e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,Qe),Qe.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(_e),hn.subVectors(this.max,_e),Ue.subVectors(t.a,_e),He.subVectors(t.b,_e),De.subVectors(t.c,_e),de.subVectors(He,Ue),pe.subVectors(De,He),Se.subVectors(Ue,De);let e=[0,-de.z,de.y,0,-pe.z,pe.y,0,-Se.z,Se.y,de.z,0,-de.x,pe.z,0,-pe.x,Se.z,0,-Se.x,-de.y,de.x,0,-pe.y,pe.x,0,-Se.y,Se.x,0];return!!Vn(e,Ue,He,De,hn)&&(e=[1,0,0,0,1,0,0,0,1],!!Vn(e,Ue,He,De,hn)&&(dn.crossVectors(de,pe),e=[dn.x,dn.y,dn.z],Vn(e,Ue,He,De,hn)))}clampPoint(t,e){return e===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),e=new w),e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Qe.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return t===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=.5*this.getSize(Qe).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(ae[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),ae[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),ae[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),ae[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),ae[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),ae[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),ae[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),ae[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(ae)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Vt.prototype.isBox3=!0;const ae=[new w,new w,new w,new w,new w,new w,new w,new w],Qe=new w,Gn=new Vt,Ue=new w,He=new w,De=new w,de=new w,pe=new w,Se=new w,_e=new w,hn=new w,dn=new w,Le=new w;function Vn(r,t,e,n,i){for(let A=0,o=r.length-3;A<=o;A+=3){Le.fromArray(r,A);const a=i.x*Math.abs(Le.x)+i.y*Math.abs(Le.y)+i.z*Math.abs(Le.z),s=t.dot(Le),l=e.dot(Le),c=n.dot(Le);if(Math.max(-Math.max(s,l,c),Math.min(s,l,c))>a)return!1}return!0}const Or=new Vt,Hi=new w,Zn=new w,Xn=new w;class pn{constructor(t=new w,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):Or.setFromPoints(t).getCenter(n);let i=0;for(let A=0,o=t.length;A<o;A++)i=Math.max(i,n.distanceToSquared(t[A]));return this.radius=Math.sqrt(i),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),e=new w),e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return t===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new Vt),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Xn.subVectors(t,this.center);const e=Xn.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),i=.5*(n-this.radius);this.center.add(Xn.multiplyScalar(i/n)),this.radius+=i}return this}union(t){return Zn.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Hi.copy(t.center).add(Zn)),this.expandByPoint(Hi.copy(t.center).sub(Zn)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const se=new w,qn=new w,mn=new w,me=new w,Kn=new w,fn=new w,Qn=new w;class gn{constructor(t=new w,e=new w(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e===void 0&&(console.warn("THREE.Ray: .at() target is now required"),e=new w),e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,se)),this}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),e=new w),e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=se.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(se.copy(this.direction).multiplyScalar(e).add(this.origin),se.distanceToSquared(t))}distanceSqToSegment(t,e,n,i){qn.copy(t).add(e).multiplyScalar(.5),mn.copy(e).sub(t).normalize(),me.copy(this.origin).sub(qn);const A=.5*t.distanceTo(e),o=-this.direction.dot(mn),a=me.dot(this.direction),s=-me.dot(mn),l=me.lengthSq(),c=Math.abs(1-o*o);let u,h,d,g;if(c>0)if(u=o*s-a,h=o*a-s,g=A*c,u>=0)if(h>=-g)if(h<=g){const p=1/c;u*=p,h*=p,d=u*(u+o*h+2*a)+h*(o*u+h+2*s)+l}else h=A,u=Math.max(0,-(o*h+a)),d=-u*u+h*(h+2*s)+l;else h=-A,u=Math.max(0,-(o*h+a)),d=-u*u+h*(h+2*s)+l;else h<=-g?(u=Math.max(0,-(-o*A+a)),h=u>0?-A:Math.min(Math.max(-A,-s),A),d=-u*u+h*(h+2*s)+l):h<=g?(u=0,h=Math.min(Math.max(-A,-s),A),d=h*(h+2*s)+l):(u=Math.max(0,-(o*A+a)),h=u>0?A:Math.min(Math.max(-A,-s),A),d=-u*u+h*(h+2*s)+l);else h=o>0?-A:A,u=Math.max(0,-(o*h+a)),d=-u*u+h*(h+2*s)+l;return n&&n.copy(this.direction).multiplyScalar(u).add(this.origin),i&&i.copy(mn).multiplyScalar(h).add(qn),d}intersectSphere(t,e){se.subVectors(t.center,this.origin);const n=se.dot(this.direction),i=se.dot(se)-n*n,A=t.radius*t.radius;if(i>A)return null;const o=Math.sqrt(A-i),a=n-o,s=n+o;return a<0&&s<0?null:a<0?this.at(s,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0?!0:t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,i,A,o,a,s;const l=1/this.direction.x,c=1/this.direction.y,u=1/this.direction.z,h=this.origin;return l>=0?(n=(t.min.x-h.x)*l,i=(t.max.x-h.x)*l):(n=(t.max.x-h.x)*l,i=(t.min.x-h.x)*l),c>=0?(A=(t.min.y-h.y)*c,o=(t.max.y-h.y)*c):(A=(t.max.y-h.y)*c,o=(t.min.y-h.y)*c),n>o||A>i?null:((A>n||n!=n)&&(n=A),(o<i||i!=i)&&(i=o),u>=0?(a=(t.min.z-h.z)*u,s=(t.max.z-h.z)*u):(a=(t.max.z-h.z)*u,s=(t.min.z-h.z)*u),n>s||a>i?null:((a>n||n!=n)&&(n=a),(s<i||i!=i)&&(i=s),i<0?null:this.at(n>=0?n:i,e)))}intersectsBox(t){return this.intersectBox(t,se)!==null}intersectTriangle(t,e,n,i,A){Kn.subVectors(e,t),fn.subVectors(n,t),Qn.crossVectors(Kn,fn);let o,a=this.direction.dot(Qn);if(a>0){if(i)return null;o=1}else{if(!(a<0))return null;o=-1,a=-a}me.subVectors(this.origin,t);const s=o*this.direction.dot(fn.crossVectors(me,fn));if(s<0)return null;const l=o*this.direction.dot(Kn.cross(me));if(l<0||s+l>a)return null;const c=-o*me.dot(Qn);return c<0?null:this.at(c/a,A)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ct{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,i,A,o,a,s,l,c,u,h,d,g,p,m){const f=this.elements;return f[0]=t,f[4]=e,f[8]=n,f[12]=i,f[1]=A,f[5]=o,f[9]=a,f[13]=s,f[2]=l,f[6]=c,f[10]=u,f[14]=h,f[3]=d,f[7]=g,f[11]=p,f[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ct().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,i=1/Je.setFromMatrixColumn(t,0).length(),A=1/Je.setFromMatrixColumn(t,1).length(),o=1/Je.setFromMatrixColumn(t,2).length();return e[0]=n[0]*i,e[1]=n[1]*i,e[2]=n[2]*i,e[3]=0,e[4]=n[4]*A,e[5]=n[5]*A,e[6]=n[6]*A,e[7]=0,e[8]=n[8]*o,e[9]=n[9]*o,e[10]=n[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,i=t.y,A=t.z,o=Math.cos(n),a=Math.sin(n),s=Math.cos(i),l=Math.sin(i),c=Math.cos(A),u=Math.sin(A);if(t.order==="XYZ"){const h=o*c,d=o*u,g=a*c,p=a*u;e[0]=s*c,e[4]=-s*u,e[8]=l,e[1]=d+g*l,e[5]=h-p*l,e[9]=-a*s,e[2]=p-h*l,e[6]=g+d*l,e[10]=o*s}else if(t.order==="YXZ"){const h=s*c,d=s*u,g=l*c,p=l*u;e[0]=h+p*a,e[4]=g*a-d,e[8]=o*l,e[1]=o*u,e[5]=o*c,e[9]=-a,e[2]=d*a-g,e[6]=p+h*a,e[10]=o*s}else if(t.order==="ZXY"){const h=s*c,d=s*u,g=l*c,p=l*u;e[0]=h-p*a,e[4]=-o*u,e[8]=g+d*a,e[1]=d+g*a,e[5]=o*c,e[9]=p-h*a,e[2]=-o*l,e[6]=a,e[10]=o*s}else if(t.order==="ZYX"){const h=o*c,d=o*u,g=a*c,p=a*u;e[0]=s*c,e[4]=g*l-d,e[8]=h*l+p,e[1]=s*u,e[5]=p*l+h,e[9]=d*l-g,e[2]=-l,e[6]=a*s,e[10]=o*s}else if(t.order==="YZX"){const h=o*s,d=o*l,g=a*s,p=a*l;e[0]=s*c,e[4]=p-h*u,e[8]=g*u+d,e[1]=u,e[5]=o*c,e[9]=-a*c,e[2]=-l*c,e[6]=d*u+g,e[10]=h-p*u}else if(t.order==="XZY"){const h=o*s,d=o*l,g=a*s,p=a*l;e[0]=s*c,e[4]=-u,e[8]=l*c,e[1]=h*u+p,e[5]=o*c,e[9]=d*u-g,e[2]=g*u-d,e[6]=a*c,e[10]=p*u+h}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Yr,t,Gr)}lookAt(t,e,n){const i=this.elements;return kt.subVectors(t,e),kt.lengthSq()===0&&(kt.z=1),kt.normalize(),fe.crossVectors(n,kt),fe.lengthSq()===0&&(Math.abs(n.z)===1?kt.x+=1e-4:kt.z+=1e-4,kt.normalize(),fe.crossVectors(n,kt)),fe.normalize(),xn.crossVectors(kt,fe),i[0]=fe.x,i[4]=xn.x,i[8]=kt.x,i[1]=fe.y,i[5]=xn.y,i[9]=kt.y,i[2]=fe.z,i[6]=xn.z,i[10]=kt.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,i=e.elements,A=this.elements,o=n[0],a=n[4],s=n[8],l=n[12],c=n[1],u=n[5],h=n[9],d=n[13],g=n[2],p=n[6],m=n[10],f=n[14],T=n[3],S=n[7],b=n[11],I=n[15],R=i[0],E=i[4],L=i[8],k=i[12],N=i[1],D=i[5],z=i[9],W=i[13],F=i[2],K=i[6],G=i[10],_=i[14],Z=i[3],X=i[7],$=i[11],st=i[15];return A[0]=o*R+a*N+s*F+l*Z,A[4]=o*E+a*D+s*K+l*X,A[8]=o*L+a*z+s*G+l*$,A[12]=o*k+a*W+s*_+l*st,A[1]=c*R+u*N+h*F+d*Z,A[5]=c*E+u*D+h*K+d*X,A[9]=c*L+u*z+h*G+d*$,A[13]=c*k+u*W+h*_+d*st,A[2]=g*R+p*N+m*F+f*Z,A[6]=g*E+p*D+m*K+f*X,A[10]=g*L+p*z+m*G+f*$,A[14]=g*k+p*W+m*_+f*st,A[3]=T*R+S*N+b*F+I*Z,A[7]=T*E+S*D+b*K+I*X,A[11]=T*L+S*z+b*G+I*$,A[15]=T*k+S*W+b*_+I*st,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],i=t[8],A=t[12],o=t[1],a=t[5],s=t[9],l=t[13],c=t[2],u=t[6],h=t[10],d=t[14];return t[3]*(+A*s*u-i*l*u-A*a*h+n*l*h+i*a*d-n*s*d)+t[7]*(+e*s*d-e*l*h+A*o*h-i*o*d+i*l*c-A*s*c)+t[11]*(+e*l*u-e*a*d-A*o*u+n*o*d+A*a*c-n*l*c)+t[15]*(-i*a*c-e*s*u+e*a*h+i*o*u-n*o*h+n*s*c)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=e,i[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],i=t[2],A=t[3],o=t[4],a=t[5],s=t[6],l=t[7],c=t[8],u=t[9],h=t[10],d=t[11],g=t[12],p=t[13],m=t[14],f=t[15],T=u*m*l-p*h*l+p*s*d-a*m*d-u*s*f+a*h*f,S=g*h*l-c*m*l-g*s*d+o*m*d+c*s*f-o*h*f,b=c*p*l-g*u*l+g*a*d-o*p*d-c*a*f+o*u*f,I=g*u*s-c*p*s-g*a*h+o*p*h+c*a*m-o*u*m,R=e*T+n*S+i*b+A*I;if(R===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const E=1/R;return t[0]=T*E,t[1]=(p*h*A-u*m*A-p*i*d+n*m*d+u*i*f-n*h*f)*E,t[2]=(a*m*A-p*s*A+p*i*l-n*m*l-a*i*f+n*s*f)*E,t[3]=(u*s*A-a*h*A-u*i*l+n*h*l+a*i*d-n*s*d)*E,t[4]=S*E,t[5]=(c*m*A-g*h*A+g*i*d-e*m*d-c*i*f+e*h*f)*E,t[6]=(g*s*A-o*m*A-g*i*l+e*m*l+o*i*f-e*s*f)*E,t[7]=(o*h*A-c*s*A+c*i*l-e*h*l-o*i*d+e*s*d)*E,t[8]=b*E,t[9]=(g*u*A-c*p*A-g*n*d+e*p*d+c*n*f-e*u*f)*E,t[10]=(o*p*A-g*a*A+g*n*l-e*p*l-o*n*f+e*a*f)*E,t[11]=(c*a*A-o*u*A-c*n*l+e*u*l+o*n*d-e*a*d)*E,t[12]=I*E,t[13]=(c*p*i-g*u*i+g*n*h-e*p*h-c*n*m+e*u*m)*E,t[14]=(g*a*i-o*p*i-g*n*s+e*p*s+o*n*m-e*a*m)*E,t[15]=(o*u*i-c*a*i+c*n*s-e*u*s-o*n*h+e*a*h)*E,this}scale(t){const e=this.elements,n=t.x,i=t.y,A=t.z;return e[0]*=n,e[4]*=i,e[8]*=A,e[1]*=n,e[5]*=i,e[9]*=A,e[2]*=n,e[6]*=i,e[10]*=A,e[3]*=n,e[7]*=i,e[11]*=A,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,i))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),i=Math.sin(e),A=1-n,o=t.x,a=t.y,s=t.z,l=A*o,c=A*a;return this.set(l*o+n,l*a-i*s,l*s+i*a,0,l*a+i*s,c*a+n,c*s-i*o,0,l*s-i*a,c*s+i*o,A*s*s+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n){return this.set(1,e,n,0,t,1,n,0,t,e,1,0,0,0,0,1),this}compose(t,e,n){const i=this.elements,A=e._x,o=e._y,a=e._z,s=e._w,l=A+A,c=o+o,u=a+a,h=A*l,d=A*c,g=A*u,p=o*c,m=o*u,f=a*u,T=s*l,S=s*c,b=s*u,I=n.x,R=n.y,E=n.z;return i[0]=(1-(p+f))*I,i[1]=(d+b)*I,i[2]=(g-S)*I,i[3]=0,i[4]=(d-b)*R,i[5]=(1-(h+f))*R,i[6]=(m+T)*R,i[7]=0,i[8]=(g+S)*E,i[9]=(m-T)*E,i[10]=(1-(h+p))*E,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,n){const i=this.elements;let A=Je.set(i[0],i[1],i[2]).length();const o=Je.set(i[4],i[5],i[6]).length(),a=Je.set(i[8],i[9],i[10]).length();this.determinant()<0&&(A=-A),t.x=i[12],t.y=i[13],t.z=i[14],Qt.copy(this);const s=1/A,l=1/o,c=1/a;return Qt.elements[0]*=s,Qt.elements[1]*=s,Qt.elements[2]*=s,Qt.elements[4]*=l,Qt.elements[5]*=l,Qt.elements[6]*=l,Qt.elements[8]*=c,Qt.elements[9]*=c,Qt.elements[10]*=c,e.setFromRotationMatrix(Qt),n.x=A,n.y=o,n.z=a,this}makePerspective(t,e,n,i,A,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,s=2*A/(e-t),l=2*A/(n-i),c=(e+t)/(e-t),u=(n+i)/(n-i),h=-(o+A)/(o-A),d=-2*o*A/(o-A);return a[0]=s,a[4]=0,a[8]=c,a[12]=0,a[1]=0,a[5]=l,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=h,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,n,i,A,o){const a=this.elements,s=1/(e-t),l=1/(n-i),c=1/(o-A),u=(e+t)*s,h=(n+i)*l,d=(o+A)*c;return a[0]=2*s,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-h,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let i=0;i<16;i++)if(e[i]!==n[i])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}ct.prototype.isMatrix4=!0;const Je=new w,Qt=new ct,Yr=new w(0,0,0),Gr=new w(1,1,1),fe=new w,xn=new w,kt=new w,Di=new ct,Ji=new Ae;class Fe{constructor(t=0,e=0,n=0,i=Fe.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=i}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,i){return this._x=t,this._y=e,this._z=n,this._order=i||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e,n){const i=t.elements,A=i[0],o=i[4],a=i[8],s=i[1],l=i[5],c=i[9],u=i[2],h=i[6],d=i[10];switch(e=e||this._order){case"XYZ":this._y=Math.asin(Kt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-o,A)):(this._x=Math.atan2(h,l),this._z=0);break;case"YXZ":this._x=Math.asin(-Kt(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(s,l)):(this._y=Math.atan2(-u,A),this._z=0);break;case"ZXY":this._x=Math.asin(Kt(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-u,d),this._z=Math.atan2(-o,l)):(this._y=0,this._z=Math.atan2(s,A));break;case"ZYX":this._y=Math.asin(-Kt(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(h,d),this._z=Math.atan2(s,A)):(this._x=0,this._z=Math.atan2(-o,l));break;case"YZX":this._z=Math.asin(Kt(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-u,A)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-Kt(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(h,l),this._y=Math.atan2(a,A)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n!==!1&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return Di.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Di,e,n)}setFromVector3(t,e){return this.set(t.x,t.y,t.z,e||this._order)}reorder(t){return Ji.setFromEuler(this),this.setFromQuaternion(Ji,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new w(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Fe.prototype.isEuler=!0,Fe.DefaultOrder="XYZ",Fe.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Vr{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}}let Zr=0;const Fi=new w,Be=new Ae,oe=new ct,vn=new w,$e=new w,Xr=new w,qr=new Ae,Bi=new w(1,0,0),ki=new w(0,1,0),ji=new w(0,0,1),Kr={type:"added"},Oi={type:"removed"};class Rt extends Ne{constructor(){super(),Object.defineProperty(this,"id",{value:Zr++}),this.uuid=Ie(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Rt.DefaultUp.clone();const t=new w,e=new Fe,n=new Ae,i=new w(1,1,1);e._onChange(function(){n.setFromEuler(e,!1)}),n._onChange(function(){e.setFromQuaternion(n,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ct},normalMatrix:{value:new Wt}}),this.matrix=new ct,this.matrixWorld=new ct,this.matrixAutoUpdate=Rt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Vr,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Be.setFromAxisAngle(t,e),this.quaternion.multiply(Be),this}rotateOnWorldAxis(t,e){return Be.setFromAxisAngle(t,e),this.quaternion.premultiply(Be),this}rotateX(t){return this.rotateOnAxis(Bi,t)}rotateY(t){return this.rotateOnAxis(ki,t)}rotateZ(t){return this.rotateOnAxis(ji,t)}translateOnAxis(t,e){return Fi.copy(t).applyQuaternion(this.quaternion),this.position.add(Fi.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(Bi,t)}translateY(t){return this.translateOnAxis(ki,t)}translateZ(t){return this.translateOnAxis(ji,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(oe.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?vn.copy(t):vn.set(t,e,n);const i=this.parent;this.updateWorldMatrix(!0,!1),$e.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?oe.lookAt($e,vn,this.up):oe.lookAt(vn,$e,this.up),this.quaternion.setFromRotationMatrix(oe),i&&(oe.extractRotation(i.matrixWorld),Be.setFromRotationMatrix(oe),this.quaternion.premultiply(Be.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Kr)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Oi)),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Oi)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),oe.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),oe.multiply(t.parent.matrixWorld)),t.applyMatrix4(oe),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,i=this.children.length;n<i;n++){const A=this.children[n].getObjectByProperty(t,e);if(A!==void 0)return A}}getWorldPosition(t){return t===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),t=new w),this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return t===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),t=new Ae),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose($e,t,Xr),t}getWorldScale(t){return t===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),t=new w),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose($e,qr,t),t}getWorldDirection(t){t===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),t=new w),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,i=e.length;n<i;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const i=this.children;for(let A=0,o=i.length;A<o;A++)i[A].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};function A(a,s){return a[s.uuid]===void 0&&(a[s.uuid]=s.toJSON(t)),s.uuid}if(i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isMesh||this.isLine||this.isPoints){i.geometry=A(t.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const s=a.shapes;if(Array.isArray(s))for(let l=0,c=s.length;l<c;l++){const u=s[l];A(t.shapes,u)}else A(t.shapes,s)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(A(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let s=0,l=this.material.length;s<l;s++)a.push(A(t.materials,this.material[s]));i.material=a}else i.material=A(t.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const s=this.animations[a];i.animations.push(A(t.animations,s))}}if(e){const a=o(t.geometries),s=o(t.materials),l=o(t.textures),c=o(t.images),u=o(t.shapes),h=o(t.skeletons),d=o(t.animations);a.length>0&&(n.geometries=a),s.length>0&&(n.materials=s),l.length>0&&(n.textures=l),c.length>0&&(n.images=c),u.length>0&&(n.shapes=u),h.length>0&&(n.skeletons=h),d.length>0&&(n.animations=d)}return n.object=i,n;function o(a){const s=[];for(const l in a){const c=a[l];delete c.metadata,s.push(c)}return s}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const i=t.children[n];this.add(i.clone())}return this}}Rt.DefaultUp=new w(0,1,0),Rt.DefaultMatrixAutoUpdate=!0,Rt.prototype.isObject3D=!0;const _n=new w,Qr=new w,_r=new Wt;class ee{constructor(t=new w(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,i){return this.normal.set(t,e,n),this.constant=i,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const i=_n.subVectors(n,e).cross(Qr.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(i,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),e=new w),e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){e===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),e=new w);const n=t.delta(_n),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const A=-(t.start.dot(this.normal)+this.constant)/i;return A<0||A>1?null:e.copy(n).multiplyScalar(A).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new w),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||_r.getNormalMatrix(t),i=this.coplanarPoint(_n).applyMatrix4(t),A=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(A),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}ee.prototype.isPlane=!0;const _t=new w,le=new w,$n=new w,ce=new w,ke=new w,je=new w,Yi=new w,ti=new w,ei=new w,ni=new w;class Pt{constructor(t=new w,e=new w,n=new w){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,i){i===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),i=new w),i.subVectors(n,e),_t.subVectors(t,e),i.cross(_t);const A=i.lengthSq();return A>0?i.multiplyScalar(1/Math.sqrt(A)):i.set(0,0,0)}static getBarycoord(t,e,n,i,A){_t.subVectors(i,e),le.subVectors(n,e),$n.subVectors(t,e);const o=_t.dot(_t),a=_t.dot(le),s=_t.dot($n),l=le.dot(le),c=le.dot($n),u=o*l-a*a;if(A===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),A=new w),u===0)return A.set(-2,-1,-1);const h=1/u,d=(l*s-a*c)*h,g=(o*c-a*s)*h;return A.set(1-d-g,g,d)}static containsPoint(t,e,n,i){return this.getBarycoord(t,e,n,i,ce),ce.x>=0&&ce.y>=0&&ce.x+ce.y<=1}static getUV(t,e,n,i,A,o,a,s){return this.getBarycoord(t,e,n,i,ce),s.set(0,0),s.addScaledVector(A,ce.x),s.addScaledVector(o,ce.y),s.addScaledVector(a,ce.z),s}static isFrontFacing(t,e,n,i){return _t.subVectors(n,e),le.subVectors(t,e),_t.cross(le).dot(i)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,i){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[i]),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return _t.subVectors(this.c,this.b),le.subVectors(this.a,this.b),.5*_t.cross(le).length()}getMidpoint(t){return t===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new w),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return Pt.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new ee),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return Pt.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,i,A){return Pt.getUV(t,this.a,this.b,this.c,e,n,i,A)}containsPoint(t){return Pt.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return Pt.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){e===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),e=new w);const n=this.a,i=this.b,A=this.c;let o,a;ke.subVectors(i,n),je.subVectors(A,n),ti.subVectors(t,n);const s=ke.dot(ti),l=je.dot(ti);if(s<=0&&l<=0)return e.copy(n);ei.subVectors(t,i);const c=ke.dot(ei),u=je.dot(ei);if(c>=0&&u<=c)return e.copy(i);const h=s*u-c*l;if(h<=0&&s>=0&&c<=0)return o=s/(s-c),e.copy(n).addScaledVector(ke,o);ni.subVectors(t,A);const d=ke.dot(ni),g=je.dot(ni);if(g>=0&&d<=g)return e.copy(A);const p=d*l-s*g;if(p<=0&&l>=0&&g<=0)return a=l/(l-g),e.copy(n).addScaledVector(je,a);const m=c*g-d*u;if(m<=0&&u-c>=0&&d-g>=0)return Yi.subVectors(A,i),a=(u-c)/(u-c+(d-g)),e.copy(i).addScaledVector(Yi,a);const f=1/(m+p+h);return o=p*f,a=h*f,e.copy(n).addScaledVector(ke,o).addScaledVector(je,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let $r=0;function ue(){Object.defineProperty(this,"id",{value:$r++}),this.uuid=Ie(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}ue.prototype=Object.assign(Object.create(Ne.prototype),{constructor:ue,isMaterial:!0,onBuild:function(){},onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(r){if(r!==void 0)for(const t in r){const e=r[t];if(e===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===1;continue}const n=this[t];n!==void 0?n&&n.isColor?n.set(e):n&&n.isVector3&&e&&e.isVector3?n.copy(e):this[t]=e:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}},toJSON:function(r){const t=r===void 0||typeof r=="string";t&&(r={textures:{},images:{}});const e={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function n(i){const A=[];for(const o in i){const a=i[o];delete a.metadata,A.push(a)}return A}if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.color&&this.color.isColor&&(e.color=this.color.getHex()),this.roughness!==void 0&&(e.roughness=this.roughness),this.metalness!==void 0&&(e.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(e.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(e.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(e.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(e.specular=this.specular.getHex()),this.shininess!==void 0&&(e.shininess=this.shininess),this.clearcoat!==void 0&&(e.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(e.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(e.clearcoatMap=this.clearcoatMap.toJSON(r).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(e.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(r).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(e.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(r).uuid,e.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(e.map=this.map.toJSON(r).uuid),this.matcap&&this.matcap.isTexture&&(e.matcap=this.matcap.toJSON(r).uuid),this.alphaMap&&this.alphaMap.isTexture&&(e.alphaMap=this.alphaMap.toJSON(r).uuid),this.lightMap&&this.lightMap.isTexture&&(e.lightMap=this.lightMap.toJSON(r).uuid,e.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(e.aoMap=this.aoMap.toJSON(r).uuid,e.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(e.bumpMap=this.bumpMap.toJSON(r).uuid,e.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(e.normalMap=this.normalMap.toJSON(r).uuid,e.normalMapType=this.normalMapType,e.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(e.displacementMap=this.displacementMap.toJSON(r).uuid,e.displacementScale=this.displacementScale,e.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(e.roughnessMap=this.roughnessMap.toJSON(r).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(e.metalnessMap=this.metalnessMap.toJSON(r).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(e.emissiveMap=this.emissiveMap.toJSON(r).uuid),this.specularMap&&this.specularMap.isTexture&&(e.specularMap=this.specularMap.toJSON(r).uuid),this.envMap&&this.envMap.isTexture&&(e.envMap=this.envMap.toJSON(r).uuid,this.combine!==void 0&&(e.combine=this.combine)),this.envMapIntensity!==void 0&&(e.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(e.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(e.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(e.gradientMap=this.gradientMap.toJSON(r).uuid),this.size!==void 0&&(e.size=this.size),this.shadowSide!==null&&(e.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(e.sizeAttenuation=this.sizeAttenuation),this.blending!==1&&(e.blending=this.blending),this.side!==0&&(e.side=this.side),this.vertexColors&&(e.vertexColors=!0),this.opacity<1&&(e.opacity=this.opacity),this.transparent===!0&&(e.transparent=this.transparent),e.depthFunc=this.depthFunc,e.depthTest=this.depthTest,e.depthWrite=this.depthWrite,e.colorWrite=this.colorWrite,e.stencilWrite=this.stencilWrite,e.stencilWriteMask=this.stencilWriteMask,e.stencilFunc=this.stencilFunc,e.stencilRef=this.stencilRef,e.stencilFuncMask=this.stencilFuncMask,e.stencilFail=this.stencilFail,e.stencilZFail=this.stencilZFail,e.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(e.rotation=this.rotation),this.polygonOffset===!0&&(e.polygonOffset=!0),this.polygonOffsetFactor!==0&&(e.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(e.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(e.linewidth=this.linewidth),this.dashSize!==void 0&&(e.dashSize=this.dashSize),this.gapSize!==void 0&&(e.gapSize=this.gapSize),this.scale!==void 0&&(e.scale=this.scale),this.dithering===!0&&(e.dithering=!0),this.alphaTest>0&&(e.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(e.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(e.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(e.wireframe=this.wireframe),this.wireframeLinewidth>1&&(e.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(e.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(e.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(e.morphTargets=!0),this.morphNormals===!0&&(e.morphNormals=!0),this.skinning===!0&&(e.skinning=!0),this.flatShading===!0&&(e.flatShading=this.flatShading),this.visible===!1&&(e.visible=!1),this.toneMapped===!1&&(e.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(e.userData=this.userData),t){const i=n(r.textures),A=n(r.images);i.length>0&&(e.textures=i),A.length>0&&(e.images=A)}return e},clone:function(){return new this.constructor().copy(this)},copy:function(r){this.name=r.name,this.fog=r.fog,this.blending=r.blending,this.side=r.side,this.vertexColors=r.vertexColors,this.opacity=r.opacity,this.transparent=r.transparent,this.blendSrc=r.blendSrc,this.blendDst=r.blendDst,this.blendEquation=r.blendEquation,this.blendSrcAlpha=r.blendSrcAlpha,this.blendDstAlpha=r.blendDstAlpha,this.blendEquationAlpha=r.blendEquationAlpha,this.depthFunc=r.depthFunc,this.depthTest=r.depthTest,this.depthWrite=r.depthWrite,this.stencilWriteMask=r.stencilWriteMask,this.stencilFunc=r.stencilFunc,this.stencilRef=r.stencilRef,this.stencilFuncMask=r.stencilFuncMask,this.stencilFail=r.stencilFail,this.stencilZFail=r.stencilZFail,this.stencilZPass=r.stencilZPass,this.stencilWrite=r.stencilWrite;const t=r.clippingPlanes;let e=null;if(t!==null){const n=t.length;e=new Array(n);for(let i=0;i!==n;++i)e[i]=t[i].clone()}return this.clippingPlanes=e,this.clipIntersection=r.clipIntersection,this.clipShadows=r.clipShadows,this.shadowSide=r.shadowSide,this.colorWrite=r.colorWrite,this.precision=r.precision,this.polygonOffset=r.polygonOffset,this.polygonOffsetFactor=r.polygonOffsetFactor,this.polygonOffsetUnits=r.polygonOffsetUnits,this.dithering=r.dithering,this.alphaTest=r.alphaTest,this.alphaToCoverage=r.alphaToCoverage,this.premultipliedAlpha=r.premultipliedAlpha,this.visible=r.visible,this.toneMapped=r.toneMapped,this.userData=JSON.parse(JSON.stringify(r.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(ue.prototype,"needsUpdate",{set:function(r){r===!0&&this.version++}});const Gi={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},$t={h:0,s:0,l:0},Mn={h:0,s:0,l:0};function ii(r,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?r+6*(t-r)*e:e<.5?t:e<2/3?r+6*(t-r)*(2/3-e):r}function ri(r){return r<.04045?.0773993808*r:Math.pow(.9478672986*r+.0521327014,2.4)}function Ai(r){return r<.0031308?12.92*r:1.055*Math.pow(r,.41666)-.055}class vt{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(255&t)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=kn(t,1),e=Kt(e,0,1),n=Kt(n,0,1),e===0)this.r=this.g=this.b=n;else{const i=n<=.5?n*(1+e):n+e-n*e,A=2*n-i;this.r=ii(A,i,t+1/3),this.g=ii(A,i,t),this.b=ii(A,i,t-1/3)}return this}setStyle(t){function e(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let i;const A=n[1],o=n[2];switch(A){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(i[1],10))/255,this.g=Math.min(255,parseInt(i[2],10))/255,this.b=Math.min(255,parseInt(i[3],10))/255,e(i[4]),this;if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(i[1],10))/100,this.g=Math.min(100,parseInt(i[2],10))/100,this.b=Math.min(100,parseInt(i[3],10))/100,e(i[4]),this;break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(i[1])/360,s=parseInt(i[2],10)/100,l=parseInt(i[3],10)/100;return e(i[4]),this.setHSL(a,s,l)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const i=n[1],A=i.length;if(A===3)return this.r=parseInt(i.charAt(0)+i.charAt(0),16)/255,this.g=parseInt(i.charAt(1)+i.charAt(1),16)/255,this.b=parseInt(i.charAt(2)+i.charAt(2),16)/255,this;if(A===6)return this.r=parseInt(i.charAt(0)+i.charAt(1),16)/255,this.g=parseInt(i.charAt(2)+i.charAt(3),16)/255,this.b=parseInt(i.charAt(4)+i.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Gi[t.toLowerCase()];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,e=2){return this.r=Math.pow(t.r,e),this.g=Math.pow(t.g,e),this.b=Math.pow(t.b,e),this}copyLinearToGamma(t,e=2){const n=e>0?1/e:1;return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=ri(t.r),this.g=ri(t.g),this.b=ri(t.b),this}copyLinearToSRGB(t){return this.r=Ai(t.r),this.g=Ai(t.g),this.b=Ai(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){t===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const e=this.r,n=this.g,i=this.b,A=Math.max(e,n,i),o=Math.min(e,n,i);let a,s;const l=(o+A)/2;if(o===A)a=0,s=0;else{const c=A-o;switch(s=l<=.5?c/(A+o):c/(2-A-o),A){case e:a=(n-i)/c+(n<i?6:0);break;case n:a=(i-e)/c+2;break;case i:a=(e-n)/c+4}a/=6}return t.h=a,t.s=s,t.l=l,t}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(t,e,n){return this.getHSL($t),$t.h+=t,$t.s+=e,$t.l+=n,this.setHSL($t.h,$t.s,$t.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL($t),t.getHSL(Mn);const n=Ke($t.h,Mn.h,e),i=Ke($t.s,Mn.s,e),A=Ke($t.l,Mn.l,e);return this.setHSL(n,i,A),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}vt.NAMES=Gi,vt.prototype.isColor=!0,vt.prototype.r=1,vt.prototype.g=1,vt.prototype.b=1;class yn extends ue{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new vt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this}}yn.prototype.isMeshBasicMaterial=!0;const yt=new w,wn=new ft;class jt{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.onUploadCallback=function(){}}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let i=0,A=this.itemSize;i<A;i++)this.array[t+i]=e.array[n+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let i=0,A=t.length;i<A;i++){let o=t[i];o===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),o=new vt),e[n++]=o.r,e[n++]=o.g,e[n++]=o.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let i=0,A=t.length;i<A;i++){let o=t[i];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),o=new ft),e[n++]=o.x,e[n++]=o.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let i=0,A=t.length;i<A;i++){let o=t[i];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),o=new w),e[n++]=o.x,e[n++]=o.y,e[n++]=o.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let i=0,A=t.length;i<A;i++){let o=t[i];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),o=new Et),e[n++]=o.x,e[n++]=o.y,e[n++]=o.z,e[n++]=o.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)wn.fromBufferAttribute(this,e),wn.applyMatrix3(t),this.setXY(e,wn.x,wn.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)yt.fromBufferAttribute(this,e),yt.applyMatrix3(t),this.setXYZ(e,yt.x,yt.y,yt.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)yt.x=this.getX(e),yt.y=this.getY(e),yt.z=this.getZ(e),yt.applyMatrix4(t),this.setXYZ(e,yt.x,yt.y,yt.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)yt.x=this.getX(e),yt.y=this.getY(e),yt.z=this.getZ(e),yt.applyNormalMatrix(t),this.setXYZ(e,yt.x,yt.y,yt.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)yt.x=this.getX(e),yt.y=this.getY(e),yt.z=this.getZ(e),yt.transformDirection(t),this.setXYZ(e,yt.x,yt.y,yt.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this}setXYZW(t,e,n,i,A){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=i,this.array[t+3]=A,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==35044&&(t.usage=this.usage),this.updateRange.offset===0&&this.updateRange.count===-1||(t.updateRange=this.updateRange),t}}jt.prototype.isBufferAttribute=!0;class Vi extends jt{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Zi extends jt{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Ot extends jt{constructor(t,e,n){super(new Float32Array(t),e,n)}}function Xi(r){if(r.length===0)return-1/0;let t=r[0];for(let e=1,n=r.length;e<n;++e)r[e]>t&&(t=r[e]);return t}let tA=0;const ne=new ct,ai=new Rt,Oe=new w,Yt=new Vt,tn=new Vt,Nt=new w;class It extends Ne{constructor(){super(),Object.defineProperty(this,"id",{value:tA++}),this.uuid=Ie(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Xi(t)>65535?Zi:Vi)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const A=new Wt().getNormalMatrix(t);n.applyNormalMatrix(A),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(t),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}rotateX(t){return ne.makeRotationX(t),this.applyMatrix4(ne),this}rotateY(t){return ne.makeRotationY(t),this.applyMatrix4(ne),this}rotateZ(t){return ne.makeRotationZ(t),this.applyMatrix4(ne),this}translate(t,e,n){return ne.makeTranslation(t,e,n),this.applyMatrix4(ne),this}scale(t,e,n){return ne.makeScale(t,e,n),this.applyMatrix4(ne),this}lookAt(t){return ai.lookAt(t),ai.updateMatrix(),this.applyMatrix4(ai.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Oe).negate(),this.translate(Oe.x,Oe.y,Oe.z),this}setFromPoints(t){const e=[];for(let n=0,i=t.length;n<i;n++){const A=t[n];e.push(A.x,A.y,A.z||0)}return this.setAttribute("position",new Ot(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Vt);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new w(-1/0,-1/0,-1/0),new w(1/0,1/0,1/0));if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,i=e.length;n<i;n++){const A=e[n];Yt.setFromBufferAttribute(A),this.morphTargetsRelative?(Nt.addVectors(this.boundingBox.min,Yt.min),this.boundingBox.expandByPoint(Nt),Nt.addVectors(this.boundingBox.max,Yt.max),this.boundingBox.expandByPoint(Nt)):(this.boundingBox.expandByPoint(Yt.min),this.boundingBox.expandByPoint(Yt.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new pn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new w,1/0);if(t){const n=this.boundingSphere.center;if(Yt.setFromBufferAttribute(t),e)for(let A=0,o=e.length;A<o;A++){const a=e[A];tn.setFromBufferAttribute(a),this.morphTargetsRelative?(Nt.addVectors(Yt.min,tn.min),Yt.expandByPoint(Nt),Nt.addVectors(Yt.max,tn.max),Yt.expandByPoint(Nt)):(Yt.expandByPoint(tn.min),Yt.expandByPoint(tn.max))}Yt.getCenter(n);let i=0;for(let A=0,o=t.count;A<o;A++)Nt.fromBufferAttribute(t,A),i=Math.max(i,n.distanceToSquared(Nt));if(e)for(let A=0,o=e.length;A<o;A++){const a=e[A],s=this.morphTargetsRelative;for(let l=0,c=a.count;l<c;l++)Nt.fromBufferAttribute(a,l),s&&(Oe.fromBufferAttribute(t,l),Nt.add(Oe)),i=Math.max(i,n.distanceToSquared(Nt))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeFaceNormals(){}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=t.array,i=e.position.array,A=e.normal.array,o=e.uv.array,a=i.length/3;e.tangent===void 0&&this.setAttribute("tangent",new jt(new Float32Array(4*a),4));const s=e.tangent.array,l=[],c=[];for(let N=0;N<a;N++)l[N]=new w,c[N]=new w;const u=new w,h=new w,d=new w,g=new ft,p=new ft,m=new ft,f=new w,T=new w;function S(N,D,z){u.fromArray(i,3*N),h.fromArray(i,3*D),d.fromArray(i,3*z),g.fromArray(o,2*N),p.fromArray(o,2*D),m.fromArray(o,2*z),h.sub(u),d.sub(u),p.sub(g),m.sub(g);const W=1/(p.x*m.y-m.x*p.y);isFinite(W)&&(f.copy(h).multiplyScalar(m.y).addScaledVector(d,-p.y).multiplyScalar(W),T.copy(d).multiplyScalar(p.x).addScaledVector(h,-m.x).multiplyScalar(W),l[N].add(f),l[D].add(f),l[z].add(f),c[N].add(T),c[D].add(T),c[z].add(T))}let b=this.groups;b.length===0&&(b=[{start:0,count:n.length}]);for(let N=0,D=b.length;N<D;++N){const z=b[N],W=z.start;for(let F=W,K=W+z.count;F<K;F+=3)S(n[F+0],n[F+1],n[F+2])}const I=new w,R=new w,E=new w,L=new w;function k(N){E.fromArray(A,3*N),L.copy(E);const D=l[N];I.copy(D),I.sub(E.multiplyScalar(E.dot(D))).normalize(),R.crossVectors(L,D);const z=R.dot(c[N])<0?-1:1;s[4*N]=I.x,s[4*N+1]=I.y,s[4*N+2]=I.z,s[4*N+3]=z}for(let N=0,D=b.length;N<D;++N){const z=b[N],W=z.start;for(let F=W,K=W+z.count;F<K;F+=3)k(n[F+0]),k(n[F+1]),k(n[F+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new jt(new Float32Array(3*e.count),3),this.setAttribute("normal",n);else for(let h=0,d=n.count;h<d;h++)n.setXYZ(h,0,0,0);const i=new w,A=new w,o=new w,a=new w,s=new w,l=new w,c=new w,u=new w;if(t)for(let h=0,d=t.count;h<d;h+=3){const g=t.getX(h+0),p=t.getX(h+1),m=t.getX(h+2);i.fromBufferAttribute(e,g),A.fromBufferAttribute(e,p),o.fromBufferAttribute(e,m),c.subVectors(o,A),u.subVectors(i,A),c.cross(u),a.fromBufferAttribute(n,g),s.fromBufferAttribute(n,p),l.fromBufferAttribute(n,m),a.add(c),s.add(c),l.add(c),n.setXYZ(g,a.x,a.y,a.z),n.setXYZ(p,s.x,s.y,s.z),n.setXYZ(m,l.x,l.y,l.z)}else for(let h=0,d=e.count;h<d;h+=3)i.fromBufferAttribute(e,h+0),A.fromBufferAttribute(e,h+1),o.fromBufferAttribute(e,h+2),c.subVectors(o,A),u.subVectors(i,A),c.cross(u),n.setXYZ(h+0,c.x,c.y,c.z),n.setXYZ(h+1,c.x,c.y,c.z),n.setXYZ(h+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(t.attributes[i]===void 0)continue;const A=n[i].array,o=t.attributes[i],a=o.array,s=o.itemSize*e,l=Math.min(a.length,A.length-s);for(let c=0,u=s;c<l;c++,u++)A[u]=a[c]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)Nt.fromBufferAttribute(t,e),Nt.normalize(),t.setXYZ(e,Nt.x,Nt.y,Nt.z)}toNonIndexed(){function t(a,s){const l=a.array,c=a.itemSize,u=a.normalized,h=new l.constructor(s.length*c);let d=0,g=0;for(let p=0,m=s.length;p<m;p++){d=s[p]*c;for(let f=0;f<c;f++)h[g++]=l[d++]}return new jt(h,c,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new It,n=this.index.array,i=this.attributes;for(const a in i){const s=t(i[a],n);e.setAttribute(a,s)}const A=this.morphAttributes;for(const a in A){const s=[],l=A[a];for(let c=0,u=l.length;c<u;c++){const h=t(l[c],n);s.push(h)}e.morphAttributes[a]=s}e.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,s=o.length;a<s;a++){const l=o[a];e.addGroup(l.start,l.count,l.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const s=this.parameters;for(const l in s)s[l]!==void 0&&(t[l]=s[l]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const s in n){const l=n[s];t.data.attributes[s]=l.toJSON(t.data)}const i={};let A=!1;for(const s in this.morphAttributes){const l=this.morphAttributes[s],c=[];for(let u=0,h=l.length;u<h;u++){const d=l[u];c.push(d.toJSON(t.data))}c.length>0&&(i[s]=c,A=!0)}A&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(t.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new It().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const i=t.attributes;for(const l in i){const c=i[l];this.setAttribute(l,c.clone(e))}const A=t.morphAttributes;for(const l in A){const c=[],u=A[l];for(let h=0,d=u.length;h<d;h++)c.push(u[h].clone(e));this.morphAttributes[l]=c}this.morphTargetsRelative=t.morphTargetsRelative;const o=t.groups;for(let l=0,c=o.length;l<c;l++){const u=o[l];this.addGroup(u.start,u.count,u.materialIndex)}const a=t.boundingBox;a!==null&&(this.boundingBox=a.clone());const s=t.boundingSphere;return s!==null&&(this.boundingSphere=s.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}It.prototype.isBufferGeometry=!0;const qi=new ct,Ye=new gn,si=new pn,ge=new w,xe=new w,ve=new w,oi=new w,li=new w,ci=new w,En=new w,Tn=new w,bn=new w,Sn=new ft,Ln=new ft,Rn=new ft,ui=new w,Pn=new w;class Zt extends Rt{constructor(t=new It,e=new yn){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const i=e[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let A=0,o=i.length;A<o;A++){const a=i[A].name||String(A);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=A}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,i=this.material,A=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),si.copy(n.boundingSphere),si.applyMatrix4(A),t.ray.intersectsSphere(si)===!1)||(qi.copy(A).invert(),Ye.copy(t.ray).applyMatrix4(qi),n.boundingBox!==null&&Ye.intersectsBox(n.boundingBox)===!1))return;let o;if(n.isBufferGeometry){const a=n.index,s=n.attributes.position,l=n.morphAttributes.position,c=n.morphTargetsRelative,u=n.attributes.uv,h=n.attributes.uv2,d=n.groups,g=n.drawRange;if(a!==null)if(Array.isArray(i))for(let p=0,m=d.length;p<m;p++){const f=d[p],T=i[f.materialIndex];for(let S=Math.max(f.start,g.start),b=Math.min(f.start+f.count,g.start+g.count);S<b;S+=3){const I=a.getX(S),R=a.getX(S+1),E=a.getX(S+2);o=Nn(this,T,t,Ye,s,l,c,u,h,I,R,E),o&&(o.faceIndex=Math.floor(S/3),o.face.materialIndex=f.materialIndex,e.push(o))}}else for(let p=Math.max(0,g.start),m=Math.min(a.count,g.start+g.count);p<m;p+=3){const f=a.getX(p),T=a.getX(p+1),S=a.getX(p+2);o=Nn(this,i,t,Ye,s,l,c,u,h,f,T,S),o&&(o.faceIndex=Math.floor(p/3),e.push(o))}else if(s!==void 0)if(Array.isArray(i))for(let p=0,m=d.length;p<m;p++){const f=d[p],T=i[f.materialIndex];for(let S=Math.max(f.start,g.start),b=Math.min(f.start+f.count,g.start+g.count);S<b;S+=3)o=Nn(this,T,t,Ye,s,l,c,u,h,S,S+1,S+2),o&&(o.faceIndex=Math.floor(S/3),o.face.materialIndex=f.materialIndex,e.push(o))}else for(let p=Math.max(0,g.start),m=Math.min(s.count,g.start+g.count);p<m;p+=3)o=Nn(this,i,t,Ye,s,l,c,u,h,p,p+1,p+2),o&&(o.faceIndex=Math.floor(p/3),e.push(o))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function Nn(r,t,e,n,i,A,o,a,s,l,c,u){ge.fromBufferAttribute(i,l),xe.fromBufferAttribute(i,c),ve.fromBufferAttribute(i,u);const h=r.morphTargetInfluences;if(t.morphTargets&&A&&h){En.set(0,0,0),Tn.set(0,0,0),bn.set(0,0,0);for(let g=0,p=A.length;g<p;g++){const m=h[g],f=A[g];m!==0&&(oi.fromBufferAttribute(f,l),li.fromBufferAttribute(f,c),ci.fromBufferAttribute(f,u),o?(En.addScaledVector(oi,m),Tn.addScaledVector(li,m),bn.addScaledVector(ci,m)):(En.addScaledVector(oi.sub(ge),m),Tn.addScaledVector(li.sub(xe),m),bn.addScaledVector(ci.sub(ve),m)))}ge.add(En),xe.add(Tn),ve.add(bn)}r.isSkinnedMesh&&t.skinning&&(r.boneTransform(l,ge),r.boneTransform(c,xe),r.boneTransform(u,ve));const d=function(g,p,m,f,T,S,b,I){let R;if(R=p.side===1?f.intersectTriangle(b,S,T,!0,I):f.intersectTriangle(T,S,b,p.side!==2,I),R===null)return null;Pn.copy(I),Pn.applyMatrix4(g.matrixWorld);const E=m.ray.origin.distanceTo(Pn);return E<m.near||E>m.far?null:{distance:E,point:Pn.clone(),object:g}}(r,t,e,n,ge,xe,ve,ui);if(d){a&&(Sn.fromBufferAttribute(a,l),Ln.fromBufferAttribute(a,c),Rn.fromBufferAttribute(a,u),d.uv=Pt.getUV(ui,ge,xe,ve,Sn,Ln,Rn,new ft)),s&&(Sn.fromBufferAttribute(s,l),Ln.fromBufferAttribute(s,c),Rn.fromBufferAttribute(s,u),d.uv2=Pt.getUV(ui,ge,xe,ve,Sn,Ln,Rn,new ft));const g={a:l,b:c,c:u,normal:new w,materialIndex:0};Pt.getNormal(ge,xe,ve,g.normal),d.face=g}return d}Zt.prototype.isMesh=!0;class In extends It{constructor(t=1,e=1,n=1,i=1,A=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:i,heightSegments:A,depthSegments:o};const a=this;i=Math.floor(i),A=Math.floor(A),o=Math.floor(o);const s=[],l=[],c=[],u=[];let h=0,d=0;function g(p,m,f,T,S,b,I,R,E,L,k){const N=b/E,D=I/L,z=b/2,W=I/2,F=R/2,K=E+1,G=L+1;let _=0,Z=0;const X=new w;for(let $=0;$<G;$++){const st=$*D-W;for(let M=0;M<K;M++){const y=M*N-z;X[p]=y*T,X[m]=st*S,X[f]=F,l.push(X.x,X.y,X.z),X[p]=0,X[m]=0,X[f]=R>0?1:-1,c.push(X.x,X.y,X.z),u.push(M/E),u.push(1-$/L),_+=1}}for(let $=0;$<L;$++)for(let st=0;st<E;st++){const M=h+st+K*$,y=h+st+K*($+1),B=h+(st+1)+K*($+1),H=h+(st+1)+K*$;s.push(M,y,H),s.push(y,B,H),Z+=6}a.addGroup(d,Z,k),d+=Z,h+=_}g("z","y","x",-1,-1,n,e,t,o,A,0),g("z","y","x",1,-1,n,e,-t,o,A,1),g("x","z","y",1,1,t,n,e,i,o,2),g("x","z","y",1,-1,t,n,-e,i,o,3),g("x","y","z",1,-1,t,e,n,i,A,4),g("x","y","z",-1,-1,t,e,-n,i,A,5),this.setIndex(s),this.setAttribute("position",new Ot(l,3)),this.setAttribute("normal",new Ot(c,3)),this.setAttribute("uv",new Ot(u,2))}}function Ge(r){const t={};for(const e in r){t[e]={};for(const n in r[e]){const i=r[e][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?t[e][n]=i.clone():Array.isArray(i)?t[e][n]=i.slice():t[e][n]=i}}return t}function zt(r){const t={};for(let e=0;e<r.length;e++){const n=Ge(r[e]);for(const i in n)t[i]=n[i]}return t}const eA={clone:Ge,merge:zt};class Ve extends ue{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,this.fragmentShader=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Ge(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const i in this.uniforms){const A=this.uniforms[i].value;A&&A.isTexture?e.uniforms[i]={type:"t",value:A.toJSON(t).uuid}:A&&A.isColor?e.uniforms[i]={type:"c",value:A.getHex()}:A&&A.isVector2?e.uniforms[i]={type:"v2",value:A.toArray()}:A&&A.isVector3?e.uniforms[i]={type:"v3",value:A.toArray()}:A&&A.isVector4?e.uniforms[i]={type:"v4",value:A.toArray()}:A&&A.isMatrix3?e.uniforms[i]={type:"m3",value:A.toArray()}:A&&A.isMatrix4?e.uniforms[i]={type:"m4",value:A.toArray()}:e.uniforms[i]={value:A}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}Ve.prototype.isShaderMaterial=!0;class Ki extends Rt{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new ct,this.projectionMatrix=new ct,this.projectionMatrixInverse=new ct}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){t===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),t=new w),this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Ki.prototype.isCamera=!0;class Gt extends Ki{constructor(t=50,e=1,n=.1,i=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=2*un*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(.5*qe*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return 2*un*Math.atan(Math.tan(.5*qe*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,i,A,o){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=i,this.view.width=A,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(.5*qe*this.fov)/this.zoom,n=2*e,i=this.aspect*n,A=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const s=o.fullWidth,l=o.fullHeight;A+=o.offsetX*i/s,e-=o.offsetY*n/l,i*=o.width/s,n*=o.height/l}const a=this.filmOffset;a!==0&&(A+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(A,A+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}Gt.prototype.isPerspectiveCamera=!0;class hi extends Rt{constructor(t,e,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const i=new Gt(90,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new w(1,0,0)),this.add(i);const A=new Gt(90,1,t,e);A.layers=this.layers,A.up.set(0,-1,0),A.lookAt(new w(-1,0,0)),this.add(A);const o=new Gt(90,1,t,e);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new w(0,1,0)),this.add(o);const a=new Gt(90,1,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new w(0,-1,0)),this.add(a);const s=new Gt(90,1,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new w(0,0,1)),this.add(s);const l=new Gt(90,1,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new w(0,0,-1)),this.add(l)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[i,A,o,a,s,l]=this.children,c=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,i),t.setRenderTarget(n,1),t.render(e,A),t.setRenderTarget(n,2),t.render(e,o),t.setRenderTarget(n,3),t.render(e,a),t.setRenderTarget(n,4),t.render(e,s),n.texture.generateMipmaps=h,t.setRenderTarget(n,5),t.render(e,l),t.setRenderTarget(u),t.xr.enabled=c}}class Cn extends Bt{constructor(t,e,n,i,A,o,a,s,l,c){super(t=t!==void 0?t:[],e=e!==void 0?e:301,n,i,A,o,a=a!==void 0?a:1022,s,l,c),this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Cn.prototype.isCubeTexture=!0;class Qi extends ze{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),e=e||{},this.texture=new Cn(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.generateMipmaps=e.generateMipmaps!==void 0&&e.generateMipmaps,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:1006,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=1023,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new In(5,5,5),A=new Ve({name:"CubemapFromEquirect",uniforms:Ge(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:1,blending:0});A.uniforms.tEquirect.value=e;const o=new Zt(i,A),a=e.minFilter;return e.minFilter===1008&&(e.minFilter=1006),new hi(1,10,this).update(t,o),e.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(t,e,n,i){const A=t.getRenderTarget();for(let o=0;o<6;o++)t.setRenderTarget(this,o),t.clear(e,n,i);t.setRenderTarget(A)}}Qi.prototype.isWebGLCubeRenderTarget=!0;class _i extends Bt{constructor(t,e,n,i,A,o,a,s,l,c,u,h){super(null,o,a,s,l,c,i,A,u,h),this.image={data:t||null,width:e||1,height:n||1},this.magFilter=l!==void 0?l:1003,this.minFilter=c!==void 0?c:1003,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}_i.prototype.isDataTexture=!0;const Ze=new pn,Wn=new w;class zn{constructor(t=new ee,e=new ee,n=new ee,i=new ee,A=new ee,o=new ee){this.planes=[t,e,n,i,A,o]}set(t,e,n,i,A,o){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(n),a[3].copy(i),a[4].copy(A),a[5].copy(o),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,i=n[0],A=n[1],o=n[2],a=n[3],s=n[4],l=n[5],c=n[6],u=n[7],h=n[8],d=n[9],g=n[10],p=n[11],m=n[12],f=n[13],T=n[14],S=n[15];return e[0].setComponents(a-i,u-s,p-h,S-m).normalize(),e[1].setComponents(a+i,u+s,p+h,S+m).normalize(),e[2].setComponents(a+A,u+l,p+d,S+f).normalize(),e[3].setComponents(a-A,u-l,p-d,S-f).normalize(),e[4].setComponents(a-o,u-c,p-g,S-T).normalize(),e[5].setComponents(a+o,u+c,p+g,S+T).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),Ze.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Ze)}intersectsSprite(t){return Ze.center.set(0,0,0),Ze.radius=.7071067811865476,Ze.applyMatrix4(t.matrixWorld),this.intersectsSphere(Ze)}intersectsSphere(t){const e=this.planes,n=t.center,i=-t.radius;for(let A=0;A<6;A++)if(e[A].distanceToPoint(n)<i)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const i=e[n];if(Wn.x=i.normal.x>0?t.max.x:t.min.x,Wn.y=i.normal.y>0?t.max.y:t.min.y,Wn.z=i.normal.z>0?t.max.z:t.min.z,i.distanceToPoint(Wn)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function $i(){let r=null,t=!1,e=null,n=null;function i(A,o){e(A,o),n=r.requestAnimationFrame(i)}return{start:function(){t!==!0&&e!==null&&(n=r.requestAnimationFrame(i),t=!0)},stop:function(){r.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(A){e=A},setContext:function(A){r=A}}}function nA(r,t){const e=t.isWebGL2,n=new WeakMap;return{get:function(i){return i.isInterleavedBufferAttribute&&(i=i.data),n.get(i)},remove:function(i){i.isInterleavedBufferAttribute&&(i=i.data);const A=n.get(i);A&&(r.deleteBuffer(A.buffer),n.delete(i))},update:function(i,A){if(i.isGLBufferAttribute){const a=n.get(i);return void((!a||a.version<i.version)&&n.set(i,{buffer:i.buffer,type:i.type,bytesPerElement:i.elementSize,version:i.version}))}i.isInterleavedBufferAttribute&&(i=i.data);const o=n.get(i);o===void 0?n.set(i,function(a,s){const l=a.array,c=a.usage,u=r.createBuffer();r.bindBuffer(s,u),r.bufferData(s,l,c),a.onUploadCallback();let h=5126;return l instanceof Float32Array?h=5126:l instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):l instanceof Uint16Array?a.isFloat16BufferAttribute?e?h=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):h=5123:l instanceof Int16Array?h=5122:l instanceof Uint32Array?h=5125:l instanceof Int32Array?h=5124:l instanceof Int8Array?h=5120:l instanceof Uint8Array&&(h=5121),{buffer:u,type:h,bytesPerElement:l.BYTES_PER_ELEMENT,version:a.version}}(i,A)):o.version<i.version&&(function(a,s,l){const c=s.array,u=s.updateRange;r.bindBuffer(l,a),u.count===-1?r.bufferSubData(l,0,c):(e?r.bufferSubData(l,u.offset*c.BYTES_PER_ELEMENT,c,u.offset,u.count):r.bufferSubData(l,u.offset*c.BYTES_PER_ELEMENT,c.subarray(u.offset,u.offset+u.count)),u.count=-1)}(o.buffer,i,A),o.version=i.version)}}}class iA extends It{constructor(t=1,e=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:i};const A=t/2,o=e/2,a=Math.floor(n),s=Math.floor(i),l=a+1,c=s+1,u=t/a,h=e/s,d=[],g=[],p=[],m=[];for(let f=0;f<c;f++){const T=f*h-o;for(let S=0;S<l;S++){const b=S*u-A;g.push(b,-T,0),p.push(0,0,1),m.push(S/a),m.push(1-f/s)}}for(let f=0;f<s;f++)for(let T=0;T<a;T++){const S=T+l*f,b=T+l*(f+1),I=T+1+l*(f+1),R=T+1+l*f;d.push(S,b,R),d.push(b,I,R)}this.setIndex(d),this.setAttribute("position",new Ot(g,3)),this.setAttribute("normal",new Ot(p,3)),this.setAttribute("uv",new Ot(m,2))}}const ht={alphamap_fragment:`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,alphamap_pars_fragment:`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment:`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,aomap_fragment:`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,aomap_pars_fragment:`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs:`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,bumpmap_pars_fragment:`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment:`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,clipping_planes_pars_fragment:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex:`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex:`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment:`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex:`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex:`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common:`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,cube_uv_reflection_fragment:`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex:`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex:`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex:`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment:`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment:`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,envmap_fragment:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment:`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment:`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex:`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_physical_pars_fragment:`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,envmap_vertex:`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex:`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,fog_pars_vertex:`#ifdef USE_FOG
	varying float fogDepth;
#endif`,fog_fragment:`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment:`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment:`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,lightmap_fragment:`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,lightmap_pars_fragment:`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_vertex:`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,lights_pars_begin:`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,lights_toon_fragment:`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment:`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,lights_phong_fragment:`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment:`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,lights_physical_fragment:`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,lights_physical_pars_fragment:`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin:`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps:`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,lights_fragment_end:`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,logdepthbuf_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment:`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex:`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment:`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,map_pars_fragment:`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment:`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment:`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment:`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphnormal_vertex:`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,morphtarget_pars_vertex:`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,morphtarget_vertex:`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,normal_fragment_begin:`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,normal_fragment_maps:`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normalmap_pars_fragment:`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,clearcoat_normal_fragment_begin:`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,clearcoat_normal_fragment_maps:`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,clearcoat_pars_fragment:`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,packing:`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,premultiplied_alpha_fragment:`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex:`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment:`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment:`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment:`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment:`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex:`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,shadowmask_pars_fragment:`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex:`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex:`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,skinning_vertex:`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex:`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment:`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment:`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment:`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment:`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmissionmap_fragment:`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,transmissionmap_pars_fragment:`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,uv_pars_fragment:`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,uv_pars_vertex:`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,uv_vertex:`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,uv2_pars_fragment:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,uv2_pars_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,uv2_vertex:`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,worldpos_vertex:`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,background_frag:`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,background_vert:`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,cube_frag:`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,cube_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,depth_frag:`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,depth_vert:`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,distanceRGBA_frag:`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,distanceRGBA_vert:`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,equirect_frag:`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,equirect_vert:`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,linedashed_frag:`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,linedashed_vert:`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,meshbasic_frag:`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshbasic_vert:`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,meshlambert_frag:`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshlambert_vert:`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshmatcap_frag:`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshmatcap_vert:`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,meshtoon_frag:`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshtoon_vert:`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphong_frag:`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphong_vert:`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,meshphysical_frag:`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,meshphysical_vert:`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,normal_frag:`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,normal_vert:`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,points_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,points_vert:`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,shadow_frag:`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,shadow_vert:`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,sprite_frag:`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,sprite_vert:`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`},q={common:{diffuse:{value:new vt(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new Wt},uv2Transform:{value:new Wt},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new ft(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new vt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new vt(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Wt}},sprite:{diffuse:{value:new vt(15658734)},opacity:{value:1},center:{value:new ft(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Wt}}},ie={basic:{uniforms:zt([q.common,q.specularmap,q.envmap,q.aomap,q.lightmap,q.fog]),vertexShader:ht.meshbasic_vert,fragmentShader:ht.meshbasic_frag},lambert:{uniforms:zt([q.common,q.specularmap,q.envmap,q.aomap,q.lightmap,q.emissivemap,q.fog,q.lights,{emissive:{value:new vt(0)}}]),vertexShader:ht.meshlambert_vert,fragmentShader:ht.meshlambert_frag},phong:{uniforms:zt([q.common,q.specularmap,q.envmap,q.aomap,q.lightmap,q.emissivemap,q.bumpmap,q.normalmap,q.displacementmap,q.fog,q.lights,{emissive:{value:new vt(0)},specular:{value:new vt(1118481)},shininess:{value:30}}]),vertexShader:ht.meshphong_vert,fragmentShader:ht.meshphong_frag},standard:{uniforms:zt([q.common,q.envmap,q.aomap,q.lightmap,q.emissivemap,q.bumpmap,q.normalmap,q.displacementmap,q.roughnessmap,q.metalnessmap,q.fog,q.lights,{emissive:{value:new vt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ht.meshphysical_vert,fragmentShader:ht.meshphysical_frag},toon:{uniforms:zt([q.common,q.aomap,q.lightmap,q.emissivemap,q.bumpmap,q.normalmap,q.displacementmap,q.gradientmap,q.fog,q.lights,{emissive:{value:new vt(0)}}]),vertexShader:ht.meshtoon_vert,fragmentShader:ht.meshtoon_frag},matcap:{uniforms:zt([q.common,q.bumpmap,q.normalmap,q.displacementmap,q.fog,{matcap:{value:null}}]),vertexShader:ht.meshmatcap_vert,fragmentShader:ht.meshmatcap_frag},points:{uniforms:zt([q.points,q.fog]),vertexShader:ht.points_vert,fragmentShader:ht.points_frag},dashed:{uniforms:zt([q.common,q.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ht.linedashed_vert,fragmentShader:ht.linedashed_frag},depth:{uniforms:zt([q.common,q.displacementmap]),vertexShader:ht.depth_vert,fragmentShader:ht.depth_frag},normal:{uniforms:zt([q.common,q.bumpmap,q.normalmap,q.displacementmap,{opacity:{value:1}}]),vertexShader:ht.normal_vert,fragmentShader:ht.normal_frag},sprite:{uniforms:zt([q.sprite,q.fog]),vertexShader:ht.sprite_vert,fragmentShader:ht.sprite_frag},background:{uniforms:{uvTransform:{value:new Wt},t2D:{value:null}},vertexShader:ht.background_vert,fragmentShader:ht.background_frag},cube:{uniforms:zt([q.envmap,{opacity:{value:1}}]),vertexShader:ht.cube_vert,fragmentShader:ht.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ht.equirect_vert,fragmentShader:ht.equirect_frag},distanceRGBA:{uniforms:zt([q.common,q.displacementmap,{referencePosition:{value:new w},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ht.distanceRGBA_vert,fragmentShader:ht.distanceRGBA_frag},shadow:{uniforms:zt([q.lights,q.fog,{color:{value:new vt(0)},opacity:{value:1}}]),vertexShader:ht.shadow_vert,fragmentShader:ht.shadow_frag}};function rA(r,t,e,n,i){const A=new vt(0);let o,a,s=0,l=null,c=0,u=null;function h(d,g){e.buffers.color.setClear(d.r,d.g,d.b,g,i)}return{getClearColor:function(){return A},setClearColor:function(d,g=1){A.set(d),s=g,h(A,s)},getClearAlpha:function(){return s},setClearAlpha:function(d){s=d,h(A,s)},render:function(d,g,p,m){let f=g.isScene===!0?g.background:null;f&&f.isTexture&&(f=t.get(f));const T=r.xr,S=T.getSession&&T.getSession();S&&S.environmentBlendMode==="additive"&&(f=null),f===null?h(A,s):f&&f.isColor&&(h(f,1),m=!0),(r.autoClear||m)&&r.clear(r.autoClearColor,r.autoClearDepth,r.autoClearStencil),f&&(f.isCubeTexture||f.mapping===306)?(a===void 0&&(a=new Zt(new In(1,1,1),new Ve({name:"BackgroundCubeMaterial",uniforms:Ge(ie.cube.uniforms),vertexShader:ie.cube.vertexShader,fragmentShader:ie.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),a.geometry.deleteAttribute("uv"),a.onBeforeRender=function(b,I,R){this.matrixWorld.copyPosition(R.matrixWorld)},Object.defineProperty(a.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(a)),a.material.uniforms.envMap.value=f,a.material.uniforms.flipEnvMap.value=f.isCubeTexture&&f._needsFlipEnvMap?-1:1,l===f&&c===f.version&&u===r.toneMapping||(a.material.needsUpdate=!0,l=f,c=f.version,u=r.toneMapping),d.unshift(a,a.geometry,a.material,0,0,null)):f&&f.isTexture&&(o===void 0&&(o=new Zt(new iA(2,2),new Ve({name:"BackgroundMaterial",uniforms:Ge(ie.background.uniforms),vertexShader:ie.background.vertexShader,fragmentShader:ie.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(o)),o.material.uniforms.t2D.value=f,f.matrixAutoUpdate===!0&&f.updateMatrix(),o.material.uniforms.uvTransform.value.copy(f.matrix),l===f&&c===f.version&&u===r.toneMapping||(o.material.needsUpdate=!0,l=f,c=f.version,u=r.toneMapping),d.unshift(o,o.geometry,o.material,0,0,null))}}}function AA(r,t,e,n){const i=r.getParameter(34921),A=n.isWebGL2?null:t.get("OES_vertex_array_object"),o=n.isWebGL2||A!==null,a={},s=h(null);let l=s;function c(b){return n.isWebGL2?r.bindVertexArray(b):A.bindVertexArrayOES(b)}function u(b){return n.isWebGL2?r.deleteVertexArray(b):A.deleteVertexArrayOES(b)}function h(b){const I=[],R=[],E=[];for(let L=0;L<i;L++)I[L]=0,R[L]=0,E[L]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:I,enabledAttributes:R,attributeDivisors:E,object:b,attributes:{},index:null}}function d(){const b=l.newAttributes;for(let I=0,R=b.length;I<R;I++)b[I]=0}function g(b){p(b,0)}function p(b,I){const R=l.newAttributes,E=l.enabledAttributes,L=l.attributeDivisors;R[b]=1,E[b]===0&&(r.enableVertexAttribArray(b),E[b]=1),L[b]!==I&&((n.isWebGL2?r:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](b,I),L[b]=I)}function m(){const b=l.newAttributes,I=l.enabledAttributes;for(let R=0,E=I.length;R<E;R++)I[R]!==b[R]&&(r.disableVertexAttribArray(R),I[R]=0)}function f(b,I,R,E,L,k){n.isWebGL2!==!0||R!==5124&&R!==5125?r.vertexAttribPointer(b,I,R,E,L,k):r.vertexAttribIPointer(b,I,R,L,k)}function T(){S(),l!==s&&(l=s,c(l.object))}function S(){s.geometry=null,s.program=null,s.wireframe=!1}return{setup:function(b,I,R,E,L){let k=!1;if(o){const N=function(D,z,W){const F=W.wireframe===!0;let K=a[D.id];K===void 0&&(K={},a[D.id]=K);let G=K[z.id];G===void 0&&(G={},K[z.id]=G);let _=G[F];return _===void 0&&(_=h(n.isWebGL2?r.createVertexArray():A.createVertexArrayOES()),G[F]=_),_}(E,R,I);l!==N&&(l=N,c(l.object)),k=function(D,z){const W=l.attributes,F=D.attributes;let K=0;for(const G in F){const _=W[G],Z=F[G];if(_===void 0||_.attribute!==Z||_.data!==Z.data)return!0;K++}return l.attributesNum!==K||l.index!==z}(E,L),k&&function(D,z){const W={},F=D.attributes;let K=0;for(const G in F){const _=F[G],Z={};Z.attribute=_,_.data&&(Z.data=_.data),W[G]=Z,K++}l.attributes=W,l.attributesNum=K,l.index=z}(E,L)}else{const N=I.wireframe===!0;l.geometry===E.id&&l.program===R.id&&l.wireframe===N||(l.geometry=E.id,l.program=R.id,l.wireframe=N,k=!0)}b.isInstancedMesh===!0&&(k=!0),L!==null&&e.update(L,34963),k&&(function(N,D,z,W){if(n.isWebGL2===!1&&(N.isInstancedMesh||W.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;d();const F=W.attributes,K=z.getAttributes(),G=D.defaultAttributeValues;for(const _ in K){const Z=K[_];if(Z>=0){const X=F[_];if(X!==void 0){const $=X.normalized,st=X.itemSize,M=e.get(X);if(M===void 0)continue;const y=M.buffer,B=M.type,H=M.bytesPerElement;if(X.isInterleavedBufferAttribute){const C=X.data,tt=C.stride,v=X.offset;C&&C.isInstancedInterleavedBuffer?(p(Z,C.meshPerAttribute),W._maxInstanceCount===void 0&&(W._maxInstanceCount=C.meshPerAttribute*C.count)):g(Z),r.bindBuffer(34962,y),f(Z,st,B,$,tt*H,v*H)}else X.isInstancedBufferAttribute?(p(Z,X.meshPerAttribute),W._maxInstanceCount===void 0&&(W._maxInstanceCount=X.meshPerAttribute*X.count)):g(Z),r.bindBuffer(34962,y),f(Z,st,B,$,0,0)}else if(_==="instanceMatrix"){const $=e.get(N.instanceMatrix);if($===void 0)continue;const st=$.buffer,M=$.type;p(Z+0,1),p(Z+1,1),p(Z+2,1),p(Z+3,1),r.bindBuffer(34962,st),r.vertexAttribPointer(Z+0,4,M,!1,64,0),r.vertexAttribPointer(Z+1,4,M,!1,64,16),r.vertexAttribPointer(Z+2,4,M,!1,64,32),r.vertexAttribPointer(Z+3,4,M,!1,64,48)}else if(_==="instanceColor"){const $=e.get(N.instanceColor);if($===void 0)continue;const st=$.buffer,M=$.type;p(Z,1),r.bindBuffer(34962,st),r.vertexAttribPointer(Z,3,M,!1,12,0)}else if(G!==void 0){const $=G[_];if($!==void 0)switch($.length){case 2:r.vertexAttrib2fv(Z,$);break;case 3:r.vertexAttrib3fv(Z,$);break;case 4:r.vertexAttrib4fv(Z,$);break;default:r.vertexAttrib1fv(Z,$)}}}}m()}(b,I,R,E),L!==null&&r.bindBuffer(34963,e.get(L).buffer))},reset:T,resetDefaultState:S,dispose:function(){T();for(const b in a){const I=a[b];for(const R in I){const E=I[R];for(const L in E)u(E[L].object),delete E[L];delete I[R]}delete a[b]}},releaseStatesOfGeometry:function(b){if(a[b.id]===void 0)return;const I=a[b.id];for(const R in I){const E=I[R];for(const L in E)u(E[L].object),delete E[L];delete I[R]}delete a[b.id]},releaseStatesOfProgram:function(b){for(const I in a){const R=a[I];if(R[b.id]===void 0)continue;const E=R[b.id];for(const L in E)u(E[L].object),delete E[L];delete R[b.id]}},initAttributes:d,enableAttribute:g,disableUnusedAttributes:m}}function aA(r,t,e,n){const i=n.isWebGL2;let A;this.setMode=function(o){A=o},this.render=function(o,a){r.drawArrays(A,o,a),e.update(a,A,1)},this.renderInstances=function(o,a,s){if(s===0)return;let l,c;if(i)l=r,c="drawArraysInstanced";else if(l=t.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",l===null)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](A,o,a,s),e.update(a,A,s)}}function sA(r,t,e){let n;function i(S){if(S==="highp"){if(r.getShaderPrecisionFormat(35633,36338).precision>0&&r.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";S="mediump"}return S==="mediump"&&r.getShaderPrecisionFormat(35633,36337).precision>0&&r.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const A=typeof WebGL2RenderingContext!="undefined"&&r instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&r instanceof WebGL2ComputeRenderingContext;let o=e.precision!==void 0?e.precision:"highp";const a=i(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const s=e.logarithmicDepthBuffer===!0,l=r.getParameter(34930),c=r.getParameter(35660),u=r.getParameter(3379),h=r.getParameter(34076),d=r.getParameter(34921),g=r.getParameter(36347),p=r.getParameter(36348),m=r.getParameter(36349),f=c>0,T=A||t.has("OES_texture_float");return{isWebGL2:A,getMaxAnisotropy:function(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const S=t.get("EXT_texture_filter_anisotropic");n=r.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n},getMaxPrecision:i,precision:o,logarithmicDepthBuffer:s,maxTextures:l,maxVertexTextures:c,maxTextureSize:u,maxCubemapSize:h,maxAttributes:d,maxVertexUniforms:g,maxVaryings:p,maxFragmentUniforms:m,vertexTextures:f,floatFragmentTextures:T,floatVertexTextures:f&&T,maxSamples:A?r.getParameter(36183):0}}function oA(r){const t=this;let e=null,n=0,i=!1,A=!1;const o=new ee,a=new Wt,s={value:null,needsUpdate:!1};function l(){s.value!==e&&(s.value=e,s.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function c(u,h,d,g){const p=u!==null?u.length:0;let m=null;if(p!==0){if(m=s.value,g!==!0||m===null){const f=d+4*p,T=h.matrixWorldInverse;a.getNormalMatrix(T),(m===null||m.length<f)&&(m=new Float32Array(f));for(let S=0,b=d;S!==p;++S,b+=4)o.copy(u[S]).applyMatrix4(T,a),o.normal.toArray(m,b),m[b+3]=o.constant}s.value=m,s.needsUpdate=!0}return t.numPlanes=p,t.numIntersection=0,m}this.uniform=s,this.numPlanes=0,this.numIntersection=0,this.init=function(u,h,d){const g=u.length!==0||h||n!==0||i;return i=h,e=c(u,d,0),n=u.length,g},this.beginShadows=function(){A=!0,c(null)},this.endShadows=function(){A=!1,l()},this.setState=function(u,h,d){const g=u.clippingPlanes,p=u.clipIntersection,m=u.clipShadows,f=r.get(u);if(!i||g===null||g.length===0||A&&!m)A?c(null):l();else{const T=A?0:n,S=4*T;let b=f.clippingState||null;s.value=b,b=c(g,h,S,d);for(let I=0;I!==S;++I)b[I]=e[I];f.clippingState=b,this.numIntersection=p?this.numPlanes:0,this.numPlanes+=T}}}function lA(r){let t=new WeakMap;function e(i,A){return A===303?i.mapping=301:A===304&&(i.mapping=302),i}function n(i){const A=i.target;A.removeEventListener("dispose",n);const o=t.get(A);o!==void 0&&(t.delete(A),o.dispose())}return{get:function(i){if(i&&i.isTexture){const A=i.mapping;if(A===303||A===304){if(t.has(i))return e(t.get(i).texture,i.mapping);{const o=i.image;if(o&&o.height>0){const a=r.getRenderTarget(),s=new Qi(o.height/2);return s.fromEquirectangularTexture(r,i),t.set(i,s),r.setRenderTarget(a),i.addEventListener("dispose",n),e(s.texture,i.mapping)}return null}}}return i},dispose:function(){t=new WeakMap}}}function cA(r){const t={};function e(n){if(t[n]!==void 0)return t[n];let i;switch(n){case"WEBGL_depth_texture":i=r.getExtension("WEBGL_depth_texture")||r.getExtension("MOZ_WEBGL_depth_texture")||r.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=r.getExtension("EXT_texture_filter_anisotropic")||r.getExtension("MOZ_EXT_texture_filter_anisotropic")||r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=r.getExtension("WEBGL_compressed_texture_s3tc")||r.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=r.getExtension(n)}return t[n]=i,i}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float")},get:function(n){const i=e(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function uA(r,t,e,n){const i={},A=new WeakMap;function o(s){const l=s.target;l.index!==null&&t.remove(l.index);for(const u in l.attributes)t.remove(l.attributes[u]);l.removeEventListener("dispose",o),delete i[l.id];const c=A.get(l);c&&(t.remove(c),A.delete(l)),n.releaseStatesOfGeometry(l),l.isInstancedBufferGeometry===!0&&delete l._maxInstanceCount,e.memory.geometries--}function a(s){const l=[],c=s.index,u=s.attributes.position;let h=0;if(c!==null){const p=c.array;h=c.version;for(let m=0,f=p.length;m<f;m+=3){const T=p[m+0],S=p[m+1],b=p[m+2];l.push(T,S,S,b,b,T)}}else{const p=u.array;h=u.version;for(let m=0,f=p.length/3-1;m<f;m+=3){const T=m+0,S=m+1,b=m+2;l.push(T,S,S,b,b,T)}}const d=new(Xi(l)>65535?Zi:Vi)(l,1);d.version=h;const g=A.get(s);g&&t.remove(g),A.set(s,d)}return{get:function(s,l){return i[l.id]===!0||(l.addEventListener("dispose",o),i[l.id]=!0,e.memory.geometries++),l},update:function(s){const l=s.attributes;for(const u in l)t.update(l[u],34962);const c=s.morphAttributes;for(const u in c){const h=c[u];for(let d=0,g=h.length;d<g;d++)t.update(h[d],34962)}},getWireframeAttribute:function(s){const l=A.get(s);if(l){const c=s.index;c!==null&&l.version<c.version&&a(s)}else a(s);return A.get(s)}}}function hA(r,t,e,n){const i=n.isWebGL2;let A,o,a;this.setMode=function(s){A=s},this.setIndex=function(s){o=s.type,a=s.bytesPerElement},this.render=function(s,l){r.drawElements(A,l,o,s*a),e.update(l,A,1)},this.renderInstances=function(s,l,c){if(c===0)return;let u,h;if(i)u=r,h="drawElementsInstanced";else if(u=t.get("ANGLE_instanced_arrays"),h="drawElementsInstancedANGLE",u===null)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");u[h](A,l,o,s*a,c),e.update(l,A,c)}}function dA(r){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(e,n,i){switch(t.calls++,n){case 4:t.triangles+=i*(e/3);break;case 1:t.lines+=i*(e/2);break;case 3:t.lines+=i*(e-1);break;case 2:t.lines+=i*e;break;case 0:t.points+=i*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",n)}}}}function pA(r,t){return r[0]-t[0]}function mA(r,t){return Math.abs(t[1])-Math.abs(r[1])}function fA(r){const t={},e=new Float32Array(8),n=[];for(let i=0;i<8;i++)n[i]=[i,0];return{update:function(i,A,o,a){const s=i.morphTargetInfluences,l=s===void 0?0:s.length;let c=t[A.id];if(c===void 0){c=[];for(let p=0;p<l;p++)c[p]=[p,0];t[A.id]=c}for(let p=0;p<l;p++){const m=c[p];m[0]=p,m[1]=s[p]}c.sort(mA);for(let p=0;p<8;p++)p<l&&c[p][1]?(n[p][0]=c[p][0],n[p][1]=c[p][1]):(n[p][0]=Number.MAX_SAFE_INTEGER,n[p][1]=0);n.sort(pA);const u=o.morphTargets&&A.morphAttributes.position,h=o.morphNormals&&A.morphAttributes.normal;let d=0;for(let p=0;p<8;p++){const m=n[p],f=m[0],T=m[1];f!==Number.MAX_SAFE_INTEGER&&T?(u&&A.getAttribute("morphTarget"+p)!==u[f]&&A.setAttribute("morphTarget"+p,u[f]),h&&A.getAttribute("morphNormal"+p)!==h[f]&&A.setAttribute("morphNormal"+p,h[f]),e[p]=T,d+=T):(u&&A.hasAttribute("morphTarget"+p)===!0&&A.deleteAttribute("morphTarget"+p),h&&A.hasAttribute("morphNormal"+p)===!0&&A.deleteAttribute("morphNormal"+p),e[p]=0)}const g=A.morphTargetsRelative?1:1-d;a.getUniforms().setValue(r,"morphTargetBaseInfluence",g),a.getUniforms().setValue(r,"morphTargetInfluences",e)}}}function gA(r,t,e,n){let i=new WeakMap;function A(o){const a=o.target;a.removeEventListener("dispose",A),e.remove(a.instanceMatrix),a.instanceColor!==null&&e.remove(a.instanceColor)}return{update:function(o){const a=n.render.frame,s=o.geometry,l=t.get(o,s);return i.get(l)!==a&&(t.update(l),i.set(l,a)),o.isInstancedMesh&&(o.hasEventListener("dispose",A)===!1&&o.addEventListener("dispose",A),e.update(o.instanceMatrix,34962),o.instanceColor!==null&&e.update(o.instanceColor,34962)),l},dispose:function(){i=new WeakMap}}}ie.physical={uniforms:zt([ie.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new ft(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new vt(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:ht.meshphysical_vert,fragmentShader:ht.meshphysical_frag};class tr extends Bt{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}tr.prototype.isDataTexture2DArray=!0;class er extends Bt{constructor(t=null,e=1,n=1,i=1){super(null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}er.prototype.isDataTexture3D=!0;const nr=new Bt,xA=new tr,vA=new er,ir=new Cn,rr=[],Ar=[],ar=new Float32Array(16),sr=new Float32Array(9),or=new Float32Array(4);function Xe(r,t,e){const n=r[0];if(n<=0||n>0)return r;const i=t*e;let A=rr[i];if(A===void 0&&(A=new Float32Array(i),rr[i]=A),t!==0){n.toArray(A,0);for(let o=1,a=0;o!==t;++o)a+=e,r[o].toArray(A,a)}return A}function Dt(r,t){if(r.length!==t.length)return!1;for(let e=0,n=r.length;e<n;e++)if(r[e]!==t[e])return!1;return!0}function Ut(r,t){for(let e=0,n=t.length;e<n;e++)r[e]=t[e]}function lr(r,t){let e=Ar[t];e===void 0&&(e=new Int32Array(t),Ar[t]=e);for(let n=0;n!==t;++n)e[n]=r.allocateTextureUnit();return e}function MA(r,t){const e=this.cache;e[0]!==t&&(r.uniform1f(this.addr,t),e[0]=t)}function yA(r,t){const e=this.cache;if(t.x!==void 0)e[0]===t.x&&e[1]===t.y||(r.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Dt(e,t))return;r.uniform2fv(this.addr,t),Ut(e,t)}}function wA(r,t){const e=this.cache;if(t.x!==void 0)e[0]===t.x&&e[1]===t.y&&e[2]===t.z||(r.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)e[0]===t.r&&e[1]===t.g&&e[2]===t.b||(r.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Dt(e,t))return;r.uniform3fv(this.addr,t),Ut(e,t)}}function EA(r,t){const e=this.cache;if(t.x!==void 0)e[0]===t.x&&e[1]===t.y&&e[2]===t.z&&e[3]===t.w||(r.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Dt(e,t))return;r.uniform4fv(this.addr,t),Ut(e,t)}}function TA(r,t){const e=this.cache,n=t.elements;if(n===void 0){if(Dt(e,t))return;r.uniformMatrix2fv(this.addr,!1,t),Ut(e,t)}else{if(Dt(e,n))return;or.set(n),r.uniformMatrix2fv(this.addr,!1,or),Ut(e,n)}}function bA(r,t){const e=this.cache,n=t.elements;if(n===void 0){if(Dt(e,t))return;r.uniformMatrix3fv(this.addr,!1,t),Ut(e,t)}else{if(Dt(e,n))return;sr.set(n),r.uniformMatrix3fv(this.addr,!1,sr),Ut(e,n)}}function SA(r,t){const e=this.cache,n=t.elements;if(n===void 0){if(Dt(e,t))return;r.uniformMatrix4fv(this.addr,!1,t),Ut(e,t)}else{if(Dt(e,n))return;ar.set(n),r.uniformMatrix4fv(this.addr,!1,ar),Ut(e,n)}}function LA(r,t){const e=this.cache;e[0]!==t&&(r.uniform1i(this.addr,t),e[0]=t)}function RA(r,t){const e=this.cache;Dt(e,t)||(r.uniform2iv(this.addr,t),Ut(e,t))}function PA(r,t){const e=this.cache;Dt(e,t)||(r.uniform3iv(this.addr,t),Ut(e,t))}function NA(r,t){const e=this.cache;Dt(e,t)||(r.uniform4iv(this.addr,t),Ut(e,t))}function IA(r,t){const e=this.cache;e[0]!==t&&(r.uniform1ui(this.addr,t),e[0]=t)}function CA(r,t){const e=this.cache;Dt(e,t)||(r.uniform2uiv(this.addr,t),Ut(e,t))}function WA(r,t){const e=this.cache;Dt(e,t)||(r.uniform3uiv(this.addr,t),Ut(e,t))}function zA(r,t){const e=this.cache;Dt(e,t)||(r.uniform4uiv(this.addr,t),Ut(e,t))}function UA(r,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),e.safeSetTexture2D(t||nr,i)}function HA(r,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),e.setTexture3D(t||vA,i)}function DA(r,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),e.safeSetTextureCube(t||ir,i)}function JA(r,t,e){const n=this.cache,i=e.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),e.setTexture2DArray(t||xA,i)}function FA(r,t){r.uniform1fv(this.addr,t)}function BA(r,t){const e=Xe(t,this.size,2);r.uniform2fv(this.addr,e)}function kA(r,t){const e=Xe(t,this.size,3);r.uniform3fv(this.addr,e)}function jA(r,t){const e=Xe(t,this.size,4);r.uniform4fv(this.addr,e)}function OA(r,t){const e=Xe(t,this.size,4);r.uniformMatrix2fv(this.addr,!1,e)}function YA(r,t){const e=Xe(t,this.size,9);r.uniformMatrix3fv(this.addr,!1,e)}function GA(r,t){const e=Xe(t,this.size,16);r.uniformMatrix4fv(this.addr,!1,e)}function VA(r,t){r.uniform1iv(this.addr,t)}function ZA(r,t){r.uniform2iv(this.addr,t)}function XA(r,t){r.uniform3iv(this.addr,t)}function qA(r,t){r.uniform4iv(this.addr,t)}function KA(r,t){r.uniform1uiv(this.addr,t)}function QA(r,t){r.uniform2uiv(this.addr,t)}function _A(r,t){r.uniform3uiv(this.addr,t)}function $A(r,t){r.uniform4uiv(this.addr,t)}function ta(r,t,e){const n=t.length,i=lr(e,n);r.uniform1iv(this.addr,i);for(let A=0;A!==n;++A)e.safeSetTexture2D(t[A]||nr,i[A])}function ea(r,t,e){const n=t.length,i=lr(e,n);r.uniform1iv(this.addr,i);for(let A=0;A!==n;++A)e.safeSetTextureCube(t[A]||ir,i[A])}function na(r,t,e){this.id=r,this.addr=e,this.cache=[],this.setValue=function(n){switch(n){case 5126:return MA;case 35664:return yA;case 35665:return wA;case 35666:return EA;case 35674:return TA;case 35675:return bA;case 35676:return SA;case 5124:case 35670:return LA;case 35667:case 35671:return RA;case 35668:case 35672:return PA;case 35669:case 35673:return NA;case 5125:return IA;case 36294:return CA;case 36295:return WA;case 36296:return zA;case 35678:case 36198:case 36298:case 36306:case 35682:return UA;case 35679:case 36299:case 36307:return HA;case 35680:case 36300:case 36308:case 36293:return DA;case 36289:case 36303:case 36311:case 36292:return JA}}(t.type)}function cr(r,t,e){this.id=r,this.addr=e,this.cache=[],this.size=t.size,this.setValue=function(n){switch(n){case 5126:return FA;case 35664:return BA;case 35665:return kA;case 35666:return jA;case 35674:return OA;case 35675:return YA;case 35676:return GA;case 5124:case 35670:return VA;case 35667:case 35671:return ZA;case 35668:case 35672:return XA;case 35669:case 35673:return qA;case 5125:return KA;case 36294:return QA;case 36295:return _A;case 36296:return $A;case 35678:case 36198:case 36298:case 36306:case 35682:return ta;case 35680:case 36300:case 36308:case 36293:return ea}}(t.type)}function ur(r){this.id=r,this.seq=[],this.map={}}cr.prototype.updateCache=function(r){const t=this.cache;r instanceof Float32Array&&t.length!==r.length&&(this.cache=new Float32Array(r.length)),Ut(t,r)},ur.prototype.setValue=function(r,t,e){const n=this.seq;for(let i=0,A=n.length;i!==A;++i){const o=n[i];o.setValue(r,t[o.id],e)}};const di=/(\w+)(\])?(\[|\.)?/g;function hr(r,t){r.seq.push(t),r.map[t.id]=t}function ia(r,t,e){const n=r.name,i=n.length;for(di.lastIndex=0;;){const A=di.exec(n),o=di.lastIndex;let a=A[1];const s=A[2]==="]",l=A[3];if(s&&(a|=0),l===void 0||l==="["&&o+2===i){hr(e,l===void 0?new na(a,r,t):new cr(a,r,t));break}{let c=e.map[a];c===void 0&&(c=new ur(a),hr(e,c)),e=c}}}function Me(r,t){this.seq=[],this.map={};const e=r.getProgramParameter(t,35718);for(let n=0;n<e;++n){const i=r.getActiveUniform(t,n);ia(i,r.getUniformLocation(t,i.name),this)}}function dr(r,t,e){const n=r.createShader(t);return r.shaderSource(n,e),r.compileShader(n),n}Me.prototype.setValue=function(r,t,e,n){const i=this.map[t];i!==void 0&&i.setValue(r,e,n)},Me.prototype.setOptional=function(r,t,e){const n=t[e];n!==void 0&&this.setValue(r,e,n)},Me.upload=function(r,t,e,n){for(let i=0,A=t.length;i!==A;++i){const o=t[i],a=e[o.id];a.needsUpdate!==!1&&o.setValue(r,a.value,n)}},Me.seqWithValue=function(r,t){const e=[];for(let n=0,i=r.length;n!==i;++n){const A=r[n];A.id in t&&e.push(A)}return e};let ra=0;function pr(r){switch(r){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",r),["Linear","( value )"]}}function mr(r,t,e){const n=r.getShaderParameter(t,35713),i=r.getShaderInfoLog(t).trim();return n&&i===""?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+e+`
`+i+function(A){const o=A.split(`
`);for(let a=0;a<o.length;a++)o[a]=a+1+": "+o[a];return o.join(`
`)}(r.getShaderSource(t))}function en(r,t){const e=pr(t);return"vec4 "+r+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function Aa(r,t){const e=pr(t);return"vec4 "+r+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function aa(r,t){let e;switch(t){case 1:e="Linear";break;case 2:e="Reinhard";break;case 3:e="OptimizedCineon";break;case 4:e="ACESFilmic";break;case 5:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+r+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function nn(r){return r!==""}function fr(r,t){return r.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function gr(r,t){return r.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const sa=/^[ \t]*#include +<([\w\d./]+)>/gm;function pi(r){return r.replace(sa,oa)}function oa(r,t){const e=ht[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return pi(e)}const la=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,ca=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function xr(r){return r.replace(ca,vr).replace(la,ua)}function ua(r,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),vr(r,t,e,n)}function vr(r,t,e,n){let i="";for(let A=parseInt(t);A<parseInt(e);A++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+A+" ]").replace(/UNROLLED_LOOP_INDEX/g,A);return i}function Mr(r){let t="precision "+r.precision+` float;
precision `+r.precision+" int;";return r.precision==="highp"?t+=`
#define HIGH_PRECISION`:r.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:r.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function ha(r,t,e,n){const i=r.getContext(),A=e.defines;let o=e.vertexShader,a=e.fragmentShader;const s=function(L){let k="SHADOWMAP_TYPE_BASIC";return L.shadowMapType===1?k="SHADOWMAP_TYPE_PCF":L.shadowMapType===2?k="SHADOWMAP_TYPE_PCF_SOFT":L.shadowMapType===3&&(k="SHADOWMAP_TYPE_VSM"),k}(e),l=function(L){let k="ENVMAP_TYPE_CUBE";if(L.envMap)switch(L.envMapMode){case 301:case 302:k="ENVMAP_TYPE_CUBE";break;case 306:case 307:k="ENVMAP_TYPE_CUBE_UV"}return k}(e),c=function(L){let k="ENVMAP_MODE_REFLECTION";if(L.envMap)switch(L.envMapMode){case 302:case 307:k="ENVMAP_MODE_REFRACTION"}return k}(e),u=function(L){let k="ENVMAP_BLENDING_NONE";if(L.envMap)switch(L.combine){case 0:k="ENVMAP_BLENDING_MULTIPLY";break;case 1:k="ENVMAP_BLENDING_MIX";break;case 2:k="ENVMAP_BLENDING_ADD"}return k}(e),h=r.gammaFactor>0?r.gammaFactor:1,d=e.isWebGL2?"":function(L){return[L.extensionDerivatives||L.envMapCubeUV||L.bumpMap||L.tangentSpaceNormalMap||L.clearcoatNormalMap||L.flatShading||L.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(L.extensionFragDepth||L.logarithmicDepthBuffer)&&L.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",L.extensionDrawBuffers&&L.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(L.extensionShaderTextureLOD||L.envMap)&&L.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(nn).join(`
`)}(e),g=function(L){const k=[];for(const N in L){const D=L[N];D!==!1&&k.push("#define "+N+" "+D)}return k.join(`
`)}(A),p=i.createProgram();let m,f,T=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(m=[g].filter(nn).join(`
`),m.length>0&&(m+=`
`),f=[d,g].filter(nn).join(`
`),f.length>0&&(f+=`
`)):(m=[Mr(e),"#define SHADER_NAME "+e.shaderName,g,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+h,"#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+s:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(nn).join(`
`),f=[d,Mr(e),"#define SHADER_NAME "+e.shaderName,g,e.alphaTest?"#define ALPHATEST "+e.alphaTest+(e.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+h,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+l:"",e.envMap?"#define "+c:"",e.envMap?"#define "+u:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.sheen?"#define USE_SHEEN":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+s:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==0?"#define TONE_MAPPING":"",e.toneMapping!==0?ht.tonemapping_pars_fragment:"",e.toneMapping!==0?aa("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",ht.encodings_pars_fragment,e.map?en("mapTexelToLinear",e.mapEncoding):"",e.matcap?en("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?en("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?en("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.lightMap?en("lightMapTexelToLinear",e.lightMapEncoding):"",Aa("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(nn).join(`
`)),o=pi(o),o=fr(o,e),o=gr(o,e),a=pi(a),a=fr(a,e),a=gr(a,e),o=xr(o),a=xr(a),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(T=`#version 300 es
`,m=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,f=["#define varying in",e.glslVersion==="300 es"?"":"out highp vec4 pc_fragColor;",e.glslVersion==="300 es"?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+f);const S=T+f+a,b=dr(i,35633,T+m+o),I=dr(i,35632,S);if(i.attachShader(p,b),i.attachShader(p,I),e.index0AttributeName!==void 0?i.bindAttribLocation(p,0,e.index0AttributeName):e.morphTargets===!0&&i.bindAttribLocation(p,0,"position"),i.linkProgram(p),r.debug.checkShaderErrors){const L=i.getProgramInfoLog(p).trim(),k=i.getShaderInfoLog(b).trim(),N=i.getShaderInfoLog(I).trim();let D=!0,z=!0;if(i.getProgramParameter(p,35714)===!1){D=!1;const W=mr(i,b,"vertex"),F=mr(i,I,"fragment");console.error("THREE.WebGLProgram: shader error: ",i.getError(),"35715",i.getProgramParameter(p,35715),"gl.getProgramInfoLog",L,W,F)}else L!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",L):k!==""&&N!==""||(z=!1);z&&(this.diagnostics={runnable:D,programLog:L,vertexShader:{log:k,prefix:m},fragmentShader:{log:N,prefix:f}})}let R,E;return i.deleteShader(b),i.deleteShader(I),this.getUniforms=function(){return R===void 0&&(R=new Me(i,p)),R},this.getAttributes=function(){return E===void 0&&(E=function(L,k){const N={},D=L.getProgramParameter(k,35721);for(let z=0;z<D;z++){const W=L.getActiveAttrib(k,z).name;N[W]=L.getAttribLocation(k,W)}return N}(i,p)),E},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(p),this.program=void 0},this.name=e.shaderName,this.id=ra++,this.cacheKey=t,this.usedTimes=1,this.program=p,this.vertexShader=b,this.fragmentShader=I,this}function da(r,t,e,n,i,A){const o=[],a=n.isWebGL2,s=n.logarithmicDepthBuffer,l=n.floatVertexTextures,c=n.maxVertexUniforms,u=n.vertexTextures;let h=n.precision;const d={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},g=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function p(m){let f;return m&&m.isTexture?f=m.encoding:m&&m.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),f=m.texture.encoding):f=3e3,f}return{getParameters:function(m,f,T,S,b){const I=S.fog,R=m.isMeshStandardMaterial?S.environment:null,E=t.get(m.envMap||R),L=d[m.type],k=b.isSkinnedMesh?function(W){const F=W.skeleton.bones;if(l)return 1024;{const K=c,G=Math.floor((K-20)/4),_=Math.min(G,F.length);return _<F.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+F.length+" bones. This GPU supports "+_+"."),0):_}}(b):0;let N,D;if(m.precision!==null&&(h=n.getMaxPrecision(m.precision),h!==m.precision&&console.warn("THREE.WebGLProgram.getParameters:",m.precision,"not supported, using",h,"instead.")),L){const W=ie[L];N=W.vertexShader,D=W.fragmentShader}else N=m.vertexShader,D=m.fragmentShader;const z=r.getRenderTarget();return{isWebGL2:a,shaderID:L,shaderName:m.type,vertexShader:N,fragmentShader:D,defines:m.defines,isRawShaderMaterial:m.isRawShaderMaterial===!0,glslVersion:m.glslVersion,precision:h,instancing:b.isInstancedMesh===!0,instancingColor:b.isInstancedMesh===!0&&b.instanceColor!==null,supportsVertexTextures:u,outputEncoding:z!==null?p(z.texture):r.outputEncoding,map:!!m.map,mapEncoding:p(m.map),matcap:!!m.matcap,matcapEncoding:p(m.matcap),envMap:!!E,envMapMode:E&&E.mapping,envMapEncoding:p(E),envMapCubeUV:!!E&&(E.mapping===306||E.mapping===307),lightMap:!!m.lightMap,lightMapEncoding:p(m.lightMap),aoMap:!!m.aoMap,emissiveMap:!!m.emissiveMap,emissiveMapEncoding:p(m.emissiveMap),bumpMap:!!m.bumpMap,normalMap:!!m.normalMap,objectSpaceNormalMap:m.normalMapType===1,tangentSpaceNormalMap:m.normalMapType===0,clearcoatMap:!!m.clearcoatMap,clearcoatRoughnessMap:!!m.clearcoatRoughnessMap,clearcoatNormalMap:!!m.clearcoatNormalMap,displacementMap:!!m.displacementMap,roughnessMap:!!m.roughnessMap,metalnessMap:!!m.metalnessMap,specularMap:!!m.specularMap,alphaMap:!!m.alphaMap,gradientMap:!!m.gradientMap,sheen:!!m.sheen,transmissionMap:!!m.transmissionMap,combine:m.combine,vertexTangents:m.normalMap&&m.vertexTangents,vertexColors:m.vertexColors,vertexAlphas:m.vertexColors===!0&&b.geometry&&b.geometry.attributes.color&&b.geometry.attributes.color.itemSize===4,vertexUvs:!!(m.map||m.bumpMap||m.normalMap||m.specularMap||m.alphaMap||m.emissiveMap||m.roughnessMap||m.metalnessMap||m.clearcoatMap||m.clearcoatRoughnessMap||m.clearcoatNormalMap||m.displacementMap||m.transmissionMap),uvsVertexOnly:!(m.map||m.bumpMap||m.normalMap||m.specularMap||m.alphaMap||m.emissiveMap||m.roughnessMap||m.metalnessMap||m.clearcoatNormalMap||m.transmissionMap||!m.displacementMap),fog:!!I,useFog:m.fog,fogExp2:I&&I.isFogExp2,flatShading:!!m.flatShading,sizeAttenuation:m.sizeAttenuation,logarithmicDepthBuffer:s,skinning:m.skinning&&k>0,maxBones:k,useVertexTexture:l,morphTargets:m.morphTargets,morphNormals:m.morphNormals,numDirLights:f.directional.length,numPointLights:f.point.length,numSpotLights:f.spot.length,numRectAreaLights:f.rectArea.length,numHemiLights:f.hemi.length,numDirLightShadows:f.directionalShadowMap.length,numPointLightShadows:f.pointShadowMap.length,numSpotLightShadows:f.spotShadowMap.length,numClippingPlanes:A.numPlanes,numClipIntersection:A.numIntersection,dithering:m.dithering,shadowMapEnabled:r.shadowMap.enabled&&T.length>0,shadowMapType:r.shadowMap.type,toneMapping:m.toneMapped?r.toneMapping:0,physicallyCorrectLights:r.physicallyCorrectLights,premultipliedAlpha:m.premultipliedAlpha,alphaTest:m.alphaTest,doubleSided:m.side===2,flipSided:m.side===1,depthPacking:m.depthPacking!==void 0&&m.depthPacking,index0AttributeName:m.index0AttributeName,extensionDerivatives:m.extensions&&m.extensions.derivatives,extensionFragDepth:m.extensions&&m.extensions.fragDepth,extensionDrawBuffers:m.extensions&&m.extensions.drawBuffers,extensionShaderTextureLOD:m.extensions&&m.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||e.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||e.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||e.has("EXT_shader_texture_lod"),customProgramCacheKey:m.customProgramCacheKey()}},getProgramCacheKey:function(m){const f=[];if(m.shaderID?f.push(m.shaderID):(f.push(m.fragmentShader),f.push(m.vertexShader)),m.defines!==void 0)for(const T in m.defines)f.push(T),f.push(m.defines[T]);if(m.isRawShaderMaterial===!1){for(let T=0;T<g.length;T++)f.push(m[g[T]]);f.push(r.outputEncoding),f.push(r.gammaFactor)}return f.push(m.customProgramCacheKey),f.join()},getUniforms:function(m){const f=d[m.type];let T;if(f){const S=ie[f];T=eA.clone(S.uniforms)}else T=m.uniforms;return T},acquireProgram:function(m,f){let T;for(let S=0,b=o.length;S<b;S++){const I=o[S];if(I.cacheKey===f){T=I,++T.usedTimes;break}}return T===void 0&&(T=new ha(r,f,m,i),o.push(T)),T},releaseProgram:function(m){if(--m.usedTimes==0){const f=o.indexOf(m);o[f]=o[o.length-1],o.pop(),m.destroy()}},programs:o}}function pa(){let r=new WeakMap;return{get:function(t){let e=r.get(t);return e===void 0&&(e={},r.set(t,e)),e},remove:function(t){r.delete(t)},update:function(t,e,n){r.get(t)[e]=n},dispose:function(){r=new WeakMap}}}function ma(r,t){return r.groupOrder!==t.groupOrder?r.groupOrder-t.groupOrder:r.renderOrder!==t.renderOrder?r.renderOrder-t.renderOrder:r.program!==t.program?r.program.id-t.program.id:r.material.id!==t.material.id?r.material.id-t.material.id:r.z!==t.z?r.z-t.z:r.id-t.id}function fa(r,t){return r.groupOrder!==t.groupOrder?r.groupOrder-t.groupOrder:r.renderOrder!==t.renderOrder?r.renderOrder-t.renderOrder:r.z!==t.z?t.z-r.z:r.id-t.id}function yr(r){const t=[];let e=0;const n=[],i=[],A={id:-1};function o(a,s,l,c,u,h){let d=t[e];const g=r.get(l);return d===void 0?(d={id:a.id,object:a,geometry:s,material:l,program:g.program||A,groupOrder:c,renderOrder:a.renderOrder,z:u,group:h},t[e]=d):(d.id=a.id,d.object=a,d.geometry=s,d.material=l,d.program=g.program||A,d.groupOrder=c,d.renderOrder=a.renderOrder,d.z=u,d.group=h),e++,d}return{opaque:n,transparent:i,init:function(){e=0,n.length=0,i.length=0},push:function(a,s,l,c,u,h){const d=o(a,s,l,c,u,h);(l.transparent===!0?i:n).push(d)},unshift:function(a,s,l,c,u,h){const d=o(a,s,l,c,u,h);(l.transparent===!0?i:n).unshift(d)},finish:function(){for(let a=e,s=t.length;a<s;a++){const l=t[a];if(l.id===null)break;l.id=null,l.object=null,l.geometry=null,l.material=null,l.program=null,l.group=null}},sort:function(a,s){n.length>1&&n.sort(a||ma),i.length>1&&i.sort(s||fa)}}}function ga(r){let t=new WeakMap;return{get:function(e,n){let i;return t.has(e)===!1?(i=new yr(r),t.set(e,[i])):n>=t.get(e).length?(i=new yr(r),t.get(e).push(i)):i=t.get(e)[n],i},dispose:function(){t=new WeakMap}}}function xa(){const r={};return{get:function(t){if(r[t.id]!==void 0)return r[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new w,color:new vt};break;case"SpotLight":e={position:new w,direction:new w,color:new vt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new w,color:new vt,distance:0,decay:0};break;case"HemisphereLight":e={direction:new w,skyColor:new vt,groundColor:new vt};break;case"RectAreaLight":e={color:new vt,position:new w,halfWidth:new w,halfHeight:new w}}return r[t.id]=e,e}}}let va=0;function Ma(r,t){return(t.castShadow?1:0)-(r.castShadow?1:0)}function ya(r,t){const e=new xa,n=function(){const s={};return{get:function(l){if(s[l.id]!==void 0)return s[l.id];let c;switch(l.type){case"DirectionalLight":case"SpotLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ft};break;case"PointLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ft,shadowCameraNear:1,shadowCameraFar:1e3}}return s[l.id]=c,c}}}(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let s=0;s<9;s++)i.probe.push(new w);const A=new w,o=new ct,a=new ct;return{setup:function(s){let l=0,c=0,u=0;for(let I=0;I<9;I++)i.probe[I].set(0,0,0);let h=0,d=0,g=0,p=0,m=0,f=0,T=0,S=0;s.sort(Ma);for(let I=0,R=s.length;I<R;I++){const E=s[I],L=E.color,k=E.intensity,N=E.distance,D=E.shadow&&E.shadow.map?E.shadow.map.texture:null;if(E.isAmbientLight)l+=L.r*k,c+=L.g*k,u+=L.b*k;else if(E.isLightProbe)for(let z=0;z<9;z++)i.probe[z].addScaledVector(E.sh.coefficients[z],k);else if(E.isDirectionalLight){const z=e.get(E);if(z.color.copy(E.color).multiplyScalar(E.intensity),E.castShadow){const W=E.shadow,F=n.get(E);F.shadowBias=W.bias,F.shadowNormalBias=W.normalBias,F.shadowRadius=W.radius,F.shadowMapSize=W.mapSize,i.directionalShadow[h]=F,i.directionalShadowMap[h]=D,i.directionalShadowMatrix[h]=E.shadow.matrix,f++}i.directional[h]=z,h++}else if(E.isSpotLight){const z=e.get(E);if(z.position.setFromMatrixPosition(E.matrixWorld),z.color.copy(L).multiplyScalar(k),z.distance=N,z.coneCos=Math.cos(E.angle),z.penumbraCos=Math.cos(E.angle*(1-E.penumbra)),z.decay=E.decay,E.castShadow){const W=E.shadow,F=n.get(E);F.shadowBias=W.bias,F.shadowNormalBias=W.normalBias,F.shadowRadius=W.radius,F.shadowMapSize=W.mapSize,i.spotShadow[g]=F,i.spotShadowMap[g]=D,i.spotShadowMatrix[g]=E.shadow.matrix,S++}i.spot[g]=z,g++}else if(E.isRectAreaLight){const z=e.get(E);z.color.copy(L).multiplyScalar(k),z.halfWidth.set(.5*E.width,0,0),z.halfHeight.set(0,.5*E.height,0),i.rectArea[p]=z,p++}else if(E.isPointLight){const z=e.get(E);if(z.color.copy(E.color).multiplyScalar(E.intensity),z.distance=E.distance,z.decay=E.decay,E.castShadow){const W=E.shadow,F=n.get(E);F.shadowBias=W.bias,F.shadowNormalBias=W.normalBias,F.shadowRadius=W.radius,F.shadowMapSize=W.mapSize,F.shadowCameraNear=W.camera.near,F.shadowCameraFar=W.camera.far,i.pointShadow[d]=F,i.pointShadowMap[d]=D,i.pointShadowMatrix[d]=E.shadow.matrix,T++}i.point[d]=z,d++}else if(E.isHemisphereLight){const z=e.get(E);z.skyColor.copy(E.color).multiplyScalar(k),z.groundColor.copy(E.groundColor).multiplyScalar(k),i.hemi[m]=z,m++}}p>0&&(t.isWebGL2||r.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=q.LTC_FLOAT_1,i.rectAreaLTC2=q.LTC_FLOAT_2):r.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=q.LTC_HALF_1,i.rectAreaLTC2=q.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=l,i.ambient[1]=c,i.ambient[2]=u;const b=i.hash;b.directionalLength===h&&b.pointLength===d&&b.spotLength===g&&b.rectAreaLength===p&&b.hemiLength===m&&b.numDirectionalShadows===f&&b.numPointShadows===T&&b.numSpotShadows===S||(i.directional.length=h,i.spot.length=g,i.rectArea.length=p,i.point.length=d,i.hemi.length=m,i.directionalShadow.length=f,i.directionalShadowMap.length=f,i.pointShadow.length=T,i.pointShadowMap.length=T,i.spotShadow.length=S,i.spotShadowMap.length=S,i.directionalShadowMatrix.length=f,i.pointShadowMatrix.length=T,i.spotShadowMatrix.length=S,b.directionalLength=h,b.pointLength=d,b.spotLength=g,b.rectAreaLength=p,b.hemiLength=m,b.numDirectionalShadows=f,b.numPointShadows=T,b.numSpotShadows=S,i.version=va++)},setupView:function(s,l){let c=0,u=0,h=0,d=0,g=0;const p=l.matrixWorldInverse;for(let m=0,f=s.length;m<f;m++){const T=s[m];if(T.isDirectionalLight){const S=i.directional[c];S.direction.setFromMatrixPosition(T.matrixWorld),A.setFromMatrixPosition(T.target.matrixWorld),S.direction.sub(A),S.direction.transformDirection(p),c++}else if(T.isSpotLight){const S=i.spot[h];S.position.setFromMatrixPosition(T.matrixWorld),S.position.applyMatrix4(p),S.direction.setFromMatrixPosition(T.matrixWorld),A.setFromMatrixPosition(T.target.matrixWorld),S.direction.sub(A),S.direction.transformDirection(p),h++}else if(T.isRectAreaLight){const S=i.rectArea[d];S.position.setFromMatrixPosition(T.matrixWorld),S.position.applyMatrix4(p),a.identity(),o.copy(T.matrixWorld),o.premultiply(p),a.extractRotation(o),S.halfWidth.set(.5*T.width,0,0),S.halfHeight.set(0,.5*T.height,0),S.halfWidth.applyMatrix4(a),S.halfHeight.applyMatrix4(a),d++}else if(T.isPointLight){const S=i.point[u];S.position.setFromMatrixPosition(T.matrixWorld),S.position.applyMatrix4(p),u++}else if(T.isHemisphereLight){const S=i.hemi[g];S.direction.setFromMatrixPosition(T.matrixWorld),S.direction.transformDirection(p),S.direction.normalize(),g++}}},state:i}}function wr(r,t){const e=new ya(r,t),n=[],i=[];return{init:function(){n.length=0,i.length=0},state:{lightsArray:n,shadowsArray:i,lights:e},setupLights:function(){e.setup(n)},setupLightsView:function(A){e.setupView(n,A)},pushLight:function(A){n.push(A)},pushShadow:function(A){i.push(A)}}}function wa(r,t){let e=new WeakMap;return{get:function(n,i=0){let A;return e.has(n)===!1?(A=new wr(r,t),e.set(n,[A])):i>=e.get(n).length?(A=new wr(r,t),e.get(n).push(A)):A=e.get(n)[i],A},dispose:function(){e=new WeakMap}}}class Er extends ue{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}Er.prototype.isMeshDepthMaterial=!0;class Tr extends ue{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new w,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}Tr.prototype.isMeshDistanceMaterial=!0;function br(r,t,e){let n=new zn;const i=new ft,A=new ft,o=new Et,a=[],s=[],l={},c=e.maxTextureSize,u={0:1,1:0,2:2},h=new Ve({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new ft},radius:{value:4}},vertexShader:`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragmentShader:`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`}),d=h.clone();d.defines.HORIZONTAL_PASS=1;const g=new It;g.setAttribute("position",new jt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new Zt(g,h),m=this;function f(R,E){const L=t.update(p);h.uniforms.shadow_pass.value=R.map.texture,h.uniforms.resolution.value=R.mapSize,h.uniforms.radius.value=R.radius,r.setRenderTarget(R.mapPass),r.clear(),r.renderBufferDirect(E,null,L,h,p,null),d.uniforms.shadow_pass.value=R.mapPass.texture,d.uniforms.resolution.value=R.mapSize,d.uniforms.radius.value=R.radius,r.setRenderTarget(R.map),r.clear(),r.renderBufferDirect(E,null,L,d,p,null)}function T(R,E,L){const k=R<<0|E<<1|L<<2;let N=a[k];return N===void 0&&(N=new Er({depthPacking:3201,morphTargets:R,skinning:E}),a[k]=N),N}function S(R,E,L){const k=R<<0|E<<1|L<<2;let N=s[k];return N===void 0&&(N=new Tr({morphTargets:R,skinning:E}),s[k]=N),N}function b(R,E,L,k,N,D,z){let W=null,F=T,K=R.customDepthMaterial;if(k.isPointLight===!0&&(F=S,K=R.customDistanceMaterial),K===void 0){let G=!1;L.morphTargets===!0&&(G=E.morphAttributes&&E.morphAttributes.position&&E.morphAttributes.position.length>0);let _=!1;R.isSkinnedMesh===!0&&(L.skinning===!0?_=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",R)),W=F(G,_,R.isInstancedMesh===!0)}else W=K;if(r.localClippingEnabled&&L.clipShadows===!0&&L.clippingPlanes.length!==0){const G=W.uuid,_=L.uuid;let Z=l[G];Z===void 0&&(Z={},l[G]=Z);let X=Z[_];X===void 0&&(X=W.clone(),Z[_]=X),W=X}return W.visible=L.visible,W.wireframe=L.wireframe,W.side=z===3?L.shadowSide!==null?L.shadowSide:L.side:L.shadowSide!==null?L.shadowSide:u[L.side],W.clipShadows=L.clipShadows,W.clippingPlanes=L.clippingPlanes,W.clipIntersection=L.clipIntersection,W.wireframeLinewidth=L.wireframeLinewidth,W.linewidth=L.linewidth,k.isPointLight===!0&&W.isMeshDistanceMaterial===!0&&(W.referencePosition.setFromMatrixPosition(k.matrixWorld),W.nearDistance=N,W.farDistance=D),W}function I(R,E,L,k,N){if(R.visible===!1)return;if(R.layers.test(E.layers)&&(R.isMesh||R.isLine||R.isPoints)&&(R.castShadow||R.receiveShadow&&N===3)&&(!R.frustumCulled||n.intersectsObject(R))){R.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse,R.matrixWorld);const z=t.update(R),W=R.material;if(Array.isArray(W)){const F=z.groups;for(let K=0,G=F.length;K<G;K++){const _=F[K],Z=W[_.materialIndex];if(Z&&Z.visible){const X=b(R,z,Z,k,L.near,L.far,N);r.renderBufferDirect(L,null,z,X,R,_)}}}else if(W.visible){const F=b(R,z,W,k,L.near,L.far,N);r.renderBufferDirect(L,null,z,F,R,null)}}const D=R.children;for(let z=0,W=D.length;z<W;z++)I(D[z],E,L,k,N)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(R,E,L){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||R.length===0)return;const k=r.getRenderTarget(),N=r.getActiveCubeFace(),D=r.getActiveMipmapLevel(),z=r.state;z.setBlending(0),z.buffers.color.setClear(1,1,1,1),z.buffers.depth.setTest(!0),z.setScissorTest(!1);for(let W=0,F=R.length;W<F;W++){const K=R[W],G=K.shadow;if(G===void 0){console.warn("THREE.WebGLShadowMap:",K,"has no shadow.");continue}if(G.autoUpdate===!1&&G.needsUpdate===!1)continue;i.copy(G.mapSize);const _=G.getFrameExtents();if(i.multiply(_),A.copy(G.mapSize),(i.x>c||i.y>c)&&(i.x>c&&(A.x=Math.floor(c/_.x),i.x=A.x*_.x,G.mapSize.x=A.x),i.y>c&&(A.y=Math.floor(c/_.y),i.y=A.y*_.y,G.mapSize.y=A.y)),G.map===null&&!G.isPointLightShadow&&this.type===3){const X={minFilter:1006,magFilter:1006,format:1023};G.map=new ze(i.x,i.y,X),G.map.texture.name=K.name+".shadowMap",G.mapPass=new ze(i.x,i.y,X),G.camera.updateProjectionMatrix()}if(G.map===null){const X={minFilter:1003,magFilter:1003,format:1023};G.map=new ze(i.x,i.y,X),G.map.texture.name=K.name+".shadowMap",G.camera.updateProjectionMatrix()}r.setRenderTarget(G.map),r.clear();const Z=G.getViewportCount();for(let X=0;X<Z;X++){const $=G.getViewport(X);o.set(A.x*$.x,A.y*$.y,A.x*$.z,A.y*$.w),z.viewport(o),G.updateMatrices(K,X),n=G.getFrustum(),I(E,L,G.camera,K,this.type)}G.isPointLightShadow||this.type!==3||f(G,L),G.needsUpdate=!1}m.needsUpdate=!1,r.setRenderTarget(k,N,D)}}function Ea(r,t,e){const n=e.isWebGL2,i=new function(){let v=!1;const Y=new Et;let O=null;const it=new Et(0,0,0,0);return{setMask:function(Q){O===Q||v||(r.colorMask(Q,Q,Q,Q),O=Q)},setLocked:function(Q){v=Q},setClear:function(Q,rt,et,pt,bt){bt===!0&&(Q*=pt,rt*=pt,et*=pt),Y.set(Q,rt,et,pt),it.equals(Y)===!1&&(r.clearColor(Q,rt,et,pt),it.copy(Y))},reset:function(){v=!1,O=null,it.set(-1,0,0,0)}}},A=new function(){let v=!1,Y=null,O=null,it=null;return{setTest:function(Q){Q?X(2929):$(2929)},setMask:function(Q){Y===Q||v||(r.depthMask(Q),Y=Q)},setFunc:function(Q){if(O!==Q){if(Q)switch(Q){case 0:r.depthFunc(512);break;case 1:r.depthFunc(519);break;case 2:r.depthFunc(513);break;case 3:r.depthFunc(515);break;case 4:r.depthFunc(514);break;case 5:r.depthFunc(518);break;case 6:r.depthFunc(516);break;case 7:r.depthFunc(517);break;default:r.depthFunc(515)}else r.depthFunc(515);O=Q}},setLocked:function(Q){v=Q},setClear:function(Q){it!==Q&&(r.clearDepth(Q),it=Q)},reset:function(){v=!1,Y=null,O=null,it=null}}},o=new function(){let v=!1,Y=null,O=null,it=null,Q=null,rt=null,et=null,pt=null,bt=null;return{setTest:function(nt){v||(nt?X(2960):$(2960))},setMask:function(nt){Y===nt||v||(r.stencilMask(nt),Y=nt)},setFunc:function(nt,dt,mt){O===nt&&it===dt&&Q===mt||(r.stencilFunc(nt,dt,mt),O=nt,it=dt,Q=mt)},setOp:function(nt,dt,mt){rt===nt&&et===dt&&pt===mt||(r.stencilOp(nt,dt,mt),rt=nt,et=dt,pt=mt)},setLocked:function(nt){v=nt},setClear:function(nt){bt!==nt&&(r.clearStencil(nt),bt=nt)},reset:function(){v=!1,Y=null,O=null,it=null,Q=null,rt=null,et=null,pt=null,bt=null}}};let a={},s=null,l={},c=null,u=!1,h=null,d=null,g=null,p=null,m=null,f=null,T=null,S=!1,b=null,I=null,R=null,E=null,L=null;const k=r.getParameter(35661);let N=!1,D=0;const z=r.getParameter(7938);z.indexOf("WebGL")!==-1?(D=parseFloat(/^WebGL (\d)/.exec(z)[1]),N=D>=1):z.indexOf("OpenGL ES")!==-1&&(D=parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),N=D>=2);let W=null,F={};const K=new Et(0,0,r.canvas.width,r.canvas.height),G=new Et(0,0,r.canvas.width,r.canvas.height);function _(v,Y,O){const it=new Uint8Array(4),Q=r.createTexture();r.bindTexture(v,Q),r.texParameteri(v,10241,9728),r.texParameteri(v,10240,9728);for(let rt=0;rt<O;rt++)r.texImage2D(Y+rt,0,6408,1,1,0,6408,5121,it);return Q}const Z={};function X(v){a[v]!==!0&&(r.enable(v),a[v]=!0)}function $(v){a[v]!==!1&&(r.disable(v),a[v]=!1)}Z[3553]=_(3553,3553,1),Z[34067]=_(34067,34069,6),i.setClear(0,0,0,1),A.setClear(1),o.setClear(0),X(2929),A.setFunc(3),B(!1),H(1),X(2884),y(0);const st={100:32774,101:32778,102:32779};if(n)st[103]=32775,st[104]=32776;else{const v=t.get("EXT_blend_minmax");v!==null&&(st[103]=v.MIN_EXT,st[104]=v.MAX_EXT)}const M={200:0,201:1,202:768,204:770,210:776,208:774,206:772,203:769,205:771,209:775,207:773};function y(v,Y,O,it,Q,rt,et,pt){if(v!==0){if(u===!1&&(X(3042),u=!0),v===5)Q=Q||Y,rt=rt||O,et=et||it,Y===d&&Q===m||(r.blendEquationSeparate(st[Y],st[Q]),d=Y,m=Q),O===g&&it===p&&rt===f&&et===T||(r.blendFuncSeparate(M[O],M[it],M[rt],M[et]),g=O,p=it,f=rt,T=et),h=v,S=null;else if(v!==h||pt!==S){if(d===100&&m===100||(r.blendEquation(32774),d=100,m=100),pt)switch(v){case 1:r.blendFuncSeparate(1,771,1,771);break;case 2:r.blendFunc(1,1);break;case 3:r.blendFuncSeparate(0,0,769,771);break;case 4:r.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",v)}else switch(v){case 1:r.blendFuncSeparate(770,771,1,771);break;case 2:r.blendFunc(770,1);break;case 3:r.blendFunc(0,769);break;case 4:r.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",v)}g=null,p=null,f=null,T=null,h=v,S=pt}}else u===!0&&($(3042),u=!1)}function B(v){b!==v&&(v?r.frontFace(2304):r.frontFace(2305),b=v)}function H(v){v!==0?(X(2884),v!==I&&(v===1?r.cullFace(1029):v===2?r.cullFace(1028):r.cullFace(1032))):$(2884),I=v}function C(v,Y,O){v?(X(32823),E===Y&&L===O||(r.polygonOffset(Y,O),E=Y,L=O)):$(32823)}function tt(v){v===void 0&&(v=33984+k-1),W!==v&&(r.activeTexture(v),W=v)}return{buffers:{color:i,depth:A,stencil:o},enable:X,disable:$,bindFramebuffer:function(v,Y){Y===null&&s!==null&&(Y=s),l[v]!==Y&&(r.bindFramebuffer(v,Y),l[v]=Y,n&&(v===36009&&(l[36160]=Y),v===36160&&(l[36009]=Y)))},bindXRFramebuffer:function(v){v!==s&&(r.bindFramebuffer(36160,v),s=v)},useProgram:function(v){return c!==v&&(r.useProgram(v),c=v,!0)},setBlending:y,setMaterial:function(v,Y){v.side===2?$(2884):X(2884);let O=v.side===1;Y&&(O=!O),B(O),v.blending===1&&v.transparent===!1?y(0):y(v.blending,v.blendEquation,v.blendSrc,v.blendDst,v.blendEquationAlpha,v.blendSrcAlpha,v.blendDstAlpha,v.premultipliedAlpha),A.setFunc(v.depthFunc),A.setTest(v.depthTest),A.setMask(v.depthWrite),i.setMask(v.colorWrite);const it=v.stencilWrite;o.setTest(it),it&&(o.setMask(v.stencilWriteMask),o.setFunc(v.stencilFunc,v.stencilRef,v.stencilFuncMask),o.setOp(v.stencilFail,v.stencilZFail,v.stencilZPass)),C(v.polygonOffset,v.polygonOffsetFactor,v.polygonOffsetUnits),v.alphaToCoverage===!0?X(32926):$(32926)},setFlipSided:B,setCullFace:H,setLineWidth:function(v){v!==R&&(N&&r.lineWidth(v),R=v)},setPolygonOffset:C,setScissorTest:function(v){v?X(3089):$(3089)},activeTexture:tt,bindTexture:function(v,Y){W===null&&tt();let O=F[W];O===void 0&&(O={type:void 0,texture:void 0},F[W]=O),O.type===v&&O.texture===Y||(r.bindTexture(v,Y||Z[v]),O.type=v,O.texture=Y)},unbindTexture:function(){const v=F[W];v!==void 0&&v.type!==void 0&&(r.bindTexture(v.type,null),v.type=void 0,v.texture=void 0)},compressedTexImage2D:function(){try{r.compressedTexImage2D.apply(r,arguments)}catch(v){console.error("THREE.WebGLState:",v)}},texImage2D:function(){try{r.texImage2D.apply(r,arguments)}catch(v){console.error("THREE.WebGLState:",v)}},texImage3D:function(){try{r.texImage3D.apply(r,arguments)}catch(v){console.error("THREE.WebGLState:",v)}},scissor:function(v){K.equals(v)===!1&&(r.scissor(v.x,v.y,v.z,v.w),K.copy(v))},viewport:function(v){G.equals(v)===!1&&(r.viewport(v.x,v.y,v.z,v.w),G.copy(v))},reset:function(){r.disable(3042),r.disable(2884),r.disable(2929),r.disable(32823),r.disable(3089),r.disable(2960),r.disable(32926),r.blendEquation(32774),r.blendFunc(1,0),r.blendFuncSeparate(1,0,1,0),r.colorMask(!0,!0,!0,!0),r.clearColor(0,0,0,0),r.depthMask(!0),r.depthFunc(513),r.clearDepth(1),r.stencilMask(4294967295),r.stencilFunc(519,0,4294967295),r.stencilOp(7680,7680,7680),r.clearStencil(0),r.cullFace(1029),r.frontFace(2305),r.polygonOffset(0,0),r.activeTexture(33984),r.bindFramebuffer(36160,null),n===!0&&(r.bindFramebuffer(36009,null),r.bindFramebuffer(36008,null)),r.useProgram(null),r.lineWidth(1),r.scissor(0,0,r.canvas.width,r.canvas.height),r.viewport(0,0,r.canvas.width,r.canvas.height),a={},W=null,F={},s=null,l={},c=null,u=!1,h=null,d=null,g=null,p=null,m=null,f=null,T=null,S=!1,b=null,I=null,R=null,E=null,L=null,K.set(0,0,r.canvas.width,r.canvas.height),G.set(0,0,r.canvas.width,r.canvas.height),i.reset(),A.reset(),o.reset()}}}function Ta(r,t,e,n,i,A,o){const a=i.isWebGL2,s=i.maxTextures,l=i.maxCubemapSize,c=i.maxTextureSize,u=i.maxSamples,h=new WeakMap;let d,g=!1;try{g=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(M,y){return g?new OffscreenCanvas(M,y):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function m(M,y,B,H){let C=1;if((M.width>H||M.height>H)&&(C=H/Math.max(M.width,M.height)),C<1||y===!0){if(typeof HTMLImageElement!="undefined"&&M instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&M instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&M instanceof ImageBitmap){const tt=y?zi:Math.floor,v=tt(C*M.width),Y=tt(C*M.height);d===void 0&&(d=p(v,Y));const O=B?p(v,Y):d;return O.width=v,O.height=Y,O.getContext("2d").drawImage(M,0,0,v,Y),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+M.width+"x"+M.height+") to ("+v+"x"+Y+")."),O}return"data"in M&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+M.width+"x"+M.height+")."),M}return M}function f(M){return jn(M.width)&&jn(M.height)}function T(M,y){return M.generateMipmaps&&y&&M.minFilter!==1003&&M.minFilter!==1006}function S(M,y,B,H){r.generateMipmap(M),n.get(y).__maxMipLevel=Math.log2(Math.max(B,H))}function b(M,y,B){if(a===!1)return y;if(M!==null){if(r[M]!==void 0)return r[M];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+M+"'")}let H=y;return y===6403&&(B===5126&&(H=33326),B===5131&&(H=33325),B===5121&&(H=33321)),y===6407&&(B===5126&&(H=34837),B===5131&&(H=34843),B===5121&&(H=32849)),y===6408&&(B===5126&&(H=34836),B===5131&&(H=34842),B===5121&&(H=32856)),H!==33325&&H!==33326&&H!==34842&&H!==34836||t.get("EXT_color_buffer_float"),H}function I(M){return M===1003||M===1004||M===1005?9728:9729}function R(M){const y=M.target;y.removeEventListener("dispose",R),function(B){const H=n.get(B);H.__webglInit!==void 0&&(r.deleteTexture(H.__webglTexture),n.remove(B))}(y),y.isVideoTexture&&h.delete(y),o.memory.textures--}function E(M){const y=M.target;y.removeEventListener("dispose",E),function(B){const H=B.texture,C=n.get(B),tt=n.get(H);if(!!B){if(tt.__webglTexture!==void 0&&r.deleteTexture(tt.__webglTexture),B.depthTexture&&B.depthTexture.dispose(),B.isWebGLCubeRenderTarget)for(let v=0;v<6;v++)r.deleteFramebuffer(C.__webglFramebuffer[v]),C.__webglDepthbuffer&&r.deleteRenderbuffer(C.__webglDepthbuffer[v]);else r.deleteFramebuffer(C.__webglFramebuffer),C.__webglDepthbuffer&&r.deleteRenderbuffer(C.__webglDepthbuffer),C.__webglMultisampledFramebuffer&&r.deleteFramebuffer(C.__webglMultisampledFramebuffer),C.__webglColorRenderbuffer&&r.deleteRenderbuffer(C.__webglColorRenderbuffer),C.__webglDepthRenderbuffer&&r.deleteRenderbuffer(C.__webglDepthRenderbuffer);n.remove(H),n.remove(B)}}(y),o.memory.textures--}let L=0;function k(M,y){const B=n.get(M);if(M.isVideoTexture&&function(H){const C=o.render.frame;h.get(H)!==C&&(h.set(H,C),H.update())}(M),M.version>0&&B.__version!==M.version){const H=M.image;if(H===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(H.complete!==!1)return void K(B,M,y);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}e.activeTexture(33984+y),e.bindTexture(3553,B.__webglTexture)}function N(M,y){const B=n.get(M);M.version>0&&B.__version!==M.version?function(H,C,tt){if(C.image.length!==6)return;F(H,C),e.activeTexture(33984+tt),e.bindTexture(34067,H.__webglTexture),r.pixelStorei(37440,C.flipY),r.pixelStorei(37441,C.premultiplyAlpha),r.pixelStorei(3317,C.unpackAlignment),r.pixelStorei(37443,0);const v=C&&(C.isCompressedTexture||C.image[0].isCompressedTexture),Y=C.image[0]&&C.image[0].isDataTexture,O=[];for(let nt=0;nt<6;nt++)O[nt]=v||Y?Y?C.image[nt].image:C.image[nt]:m(C.image[nt],!1,!0,l);const it=O[0],Q=f(it)||a,rt=A.convert(C.format),et=A.convert(C.type),pt=b(C.internalFormat,rt,et);let bt;if(W(34067,C,Q),v){for(let nt=0;nt<6;nt++){bt=O[nt].mipmaps;for(let dt=0;dt<bt.length;dt++){const mt=bt[dt];C.format!==1023&&C.format!==1022?rt!==null?e.compressedTexImage2D(34069+nt,dt,pt,mt.width,mt.height,0,mt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):e.texImage2D(34069+nt,dt,pt,mt.width,mt.height,0,rt,et,mt.data)}}H.__maxMipLevel=bt.length-1}else{bt=C.mipmaps;for(let nt=0;nt<6;nt++)if(Y){e.texImage2D(34069+nt,0,pt,O[nt].width,O[nt].height,0,rt,et,O[nt].data);for(let dt=0;dt<bt.length;dt++){const mt=bt[dt].image[nt].image;e.texImage2D(34069+nt,dt+1,pt,mt.width,mt.height,0,rt,et,mt.data)}}else{e.texImage2D(34069+nt,0,pt,rt,et,O[nt]);for(let dt=0;dt<bt.length;dt++){const mt=bt[dt];e.texImage2D(34069+nt,dt+1,pt,rt,et,mt.image[nt])}}H.__maxMipLevel=bt.length}T(C,Q)&&S(34067,C,it.width,it.height),H.__version=C.version,C.onUpdate&&C.onUpdate(C)}(B,M,y):(e.activeTexture(33984+y),e.bindTexture(34067,B.__webglTexture))}const D={1e3:10497,1001:33071,1002:33648},z={1003:9728,1004:9984,1005:9986,1006:9729,1007:9985,1008:9987};function W(M,y,B){if(B?(r.texParameteri(M,10242,D[y.wrapS]),r.texParameteri(M,10243,D[y.wrapT]),M!==32879&&M!==35866||r.texParameteri(M,32882,D[y.wrapR]),r.texParameteri(M,10240,z[y.magFilter]),r.texParameteri(M,10241,z[y.minFilter])):(r.texParameteri(M,10242,33071),r.texParameteri(M,10243,33071),M!==32879&&M!==35866||r.texParameteri(M,32882,33071),y.wrapS===1001&&y.wrapT===1001||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),r.texParameteri(M,10240,I(y.magFilter)),r.texParameteri(M,10241,I(y.minFilter)),y.minFilter!==1003&&y.minFilter!==1006&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const H=t.get("EXT_texture_filter_anisotropic");if(y.type===1015&&t.has("OES_texture_float_linear")===!1||a===!1&&y.type===1016&&t.has("OES_texture_half_float_linear")===!1)return;(y.anisotropy>1||n.get(y).__currentAnisotropy)&&(r.texParameterf(M,H.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(y.anisotropy,i.getMaxAnisotropy())),n.get(y).__currentAnisotropy=y.anisotropy)}}function F(M,y){M.__webglInit===void 0&&(M.__webglInit=!0,y.addEventListener("dispose",R),M.__webglTexture=r.createTexture(),o.memory.textures++)}function K(M,y,B){let H=3553;y.isDataTexture2DArray&&(H=35866),y.isDataTexture3D&&(H=32879),F(M,y),e.activeTexture(33984+B),e.bindTexture(H,M.__webglTexture),r.pixelStorei(37440,y.flipY),r.pixelStorei(37441,y.premultiplyAlpha),r.pixelStorei(3317,y.unpackAlignment),r.pixelStorei(37443,0);const C=function(et){return!a&&(et.wrapS!==1001||et.wrapT!==1001||et.minFilter!==1003&&et.minFilter!==1006)}(y)&&f(y.image)===!1,tt=m(y.image,C,!1,c),v=f(tt)||a,Y=A.convert(y.format);let O,it=A.convert(y.type),Q=b(y.internalFormat,Y,it);W(H,y,v);const rt=y.mipmaps;if(y.isDepthTexture)Q=6402,a?Q=y.type===1015?36012:y.type===1014?33190:y.type===1020?35056:33189:y.type===1015&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),y.format===1026&&Q===6402&&y.type!==1012&&y.type!==1014&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),y.type=1012,it=A.convert(y.type)),y.format===1027&&Q===6402&&(Q=34041,y.type!==1020&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),y.type=1020,it=A.convert(y.type))),e.texImage2D(3553,0,Q,tt.width,tt.height,0,Y,it,null);else if(y.isDataTexture)if(rt.length>0&&v){for(let et=0,pt=rt.length;et<pt;et++)O=rt[et],e.texImage2D(3553,et,Q,O.width,O.height,0,Y,it,O.data);y.generateMipmaps=!1,M.__maxMipLevel=rt.length-1}else e.texImage2D(3553,0,Q,tt.width,tt.height,0,Y,it,tt.data),M.__maxMipLevel=0;else if(y.isCompressedTexture){for(let et=0,pt=rt.length;et<pt;et++)O=rt[et],y.format!==1023&&y.format!==1022?Y!==null?e.compressedTexImage2D(3553,et,Q,O.width,O.height,0,O.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):e.texImage2D(3553,et,Q,O.width,O.height,0,Y,it,O.data);M.__maxMipLevel=rt.length-1}else if(y.isDataTexture2DArray)e.texImage3D(35866,0,Q,tt.width,tt.height,tt.depth,0,Y,it,tt.data),M.__maxMipLevel=0;else if(y.isDataTexture3D)e.texImage3D(32879,0,Q,tt.width,tt.height,tt.depth,0,Y,it,tt.data),M.__maxMipLevel=0;else if(rt.length>0&&v){for(let et=0,pt=rt.length;et<pt;et++)O=rt[et],e.texImage2D(3553,et,Q,Y,it,O);y.generateMipmaps=!1,M.__maxMipLevel=rt.length-1}else e.texImage2D(3553,0,Q,Y,it,tt),M.__maxMipLevel=0;T(y,v)&&S(H,y,tt.width,tt.height),M.__version=y.version,y.onUpdate&&y.onUpdate(y)}function G(M,y,B,H){const C=y.texture,tt=A.convert(C.format),v=A.convert(C.type),Y=b(C.internalFormat,tt,v);H===32879||H===35866?e.texImage3D(H,0,Y,y.width,y.height,y.depth,0,tt,v,null):e.texImage2D(H,0,Y,y.width,y.height,0,tt,v,null),e.bindFramebuffer(36160,M),r.framebufferTexture2D(36160,B,H,n.get(C).__webglTexture,0),e.bindFramebuffer(36160,null)}function _(M,y,B){if(r.bindRenderbuffer(36161,M),y.depthBuffer&&!y.stencilBuffer){let H=33189;if(B){const C=y.depthTexture;C&&C.isDepthTexture&&(C.type===1015?H=36012:C.type===1014&&(H=33190));const tt=X(y);r.renderbufferStorageMultisample(36161,tt,H,y.width,y.height)}else r.renderbufferStorage(36161,H,y.width,y.height);r.framebufferRenderbuffer(36160,36096,36161,M)}else if(y.depthBuffer&&y.stencilBuffer){if(B){const H=X(y);r.renderbufferStorageMultisample(36161,H,35056,y.width,y.height)}else r.renderbufferStorage(36161,34041,y.width,y.height);r.framebufferRenderbuffer(36160,33306,36161,M)}else{const H=y.texture,C=A.convert(H.format),tt=A.convert(H.type),v=b(H.internalFormat,C,tt);if(B){const Y=X(y);r.renderbufferStorageMultisample(36161,Y,v,y.width,y.height)}else r.renderbufferStorage(36161,v,y.width,y.height)}r.bindRenderbuffer(36161,null)}function Z(M){const y=n.get(M),B=M.isWebGLCubeRenderTarget===!0;if(M.depthTexture){if(B)throw new Error("target.depthTexture not supported in Cube render targets");(function(H,C){if(C&&C.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,H),!C.depthTexture||!C.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");n.get(C.depthTexture).__webglTexture&&C.depthTexture.image.width===C.width&&C.depthTexture.image.height===C.height||(C.depthTexture.image.width=C.width,C.depthTexture.image.height=C.height,C.depthTexture.needsUpdate=!0),k(C.depthTexture,0);const tt=n.get(C.depthTexture).__webglTexture;if(C.depthTexture.format===1026)r.framebufferTexture2D(36160,36096,3553,tt,0);else{if(C.depthTexture.format!==1027)throw new Error("Unknown depthTexture format");r.framebufferTexture2D(36160,33306,3553,tt,0)}})(y.__webglFramebuffer,M)}else if(B){y.__webglDepthbuffer=[];for(let H=0;H<6;H++)e.bindFramebuffer(36160,y.__webglFramebuffer[H]),y.__webglDepthbuffer[H]=r.createRenderbuffer(),_(y.__webglDepthbuffer[H],M,!1)}else e.bindFramebuffer(36160,y.__webglFramebuffer),y.__webglDepthbuffer=r.createRenderbuffer(),_(y.__webglDepthbuffer,M,!1);e.bindFramebuffer(36160,null)}function X(M){return a&&M.isWebGLMultisampleRenderTarget?Math.min(u,M.samples):0}let $=!1,st=!1;this.allocateTextureUnit=function(){const M=L;return M>=s&&console.warn("THREE.WebGLTextures: Trying to use "+M+" texture units while this GPU supports only "+s),L+=1,M},this.resetTextureUnits=function(){L=0},this.setTexture2D=k,this.setTexture2DArray=function(M,y){const B=n.get(M);M.version>0&&B.__version!==M.version?K(B,M,y):(e.activeTexture(33984+y),e.bindTexture(35866,B.__webglTexture))},this.setTexture3D=function(M,y){const B=n.get(M);M.version>0&&B.__version!==M.version?K(B,M,y):(e.activeTexture(33984+y),e.bindTexture(32879,B.__webglTexture))},this.setTextureCube=N,this.setupRenderTarget=function(M){const y=M.texture,B=n.get(M),H=n.get(y);M.addEventListener("dispose",E),H.__webglTexture=r.createTexture(),H.__version=y.version,o.memory.textures++;const C=M.isWebGLCubeRenderTarget===!0,tt=M.isWebGLMultisampleRenderTarget===!0,v=y.isDataTexture3D||y.isDataTexture2DArray,Y=f(M)||a;if(!a||y.format!==1022||y.type!==1015&&y.type!==1016||(y.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),C){B.__webglFramebuffer=[];for(let O=0;O<6;O++)B.__webglFramebuffer[O]=r.createFramebuffer()}else if(B.__webglFramebuffer=r.createFramebuffer(),tt)if(a){B.__webglMultisampledFramebuffer=r.createFramebuffer(),B.__webglColorRenderbuffer=r.createRenderbuffer(),r.bindRenderbuffer(36161,B.__webglColorRenderbuffer);const O=A.convert(y.format),it=A.convert(y.type),Q=b(y.internalFormat,O,it),rt=X(M);r.renderbufferStorageMultisample(36161,rt,Q,M.width,M.height),e.bindFramebuffer(36160,B.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(36160,36064,36161,B.__webglColorRenderbuffer),r.bindRenderbuffer(36161,null),M.depthBuffer&&(B.__webglDepthRenderbuffer=r.createRenderbuffer(),_(B.__webglDepthRenderbuffer,M,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(C){e.bindTexture(34067,H.__webglTexture),W(34067,y,Y);for(let O=0;O<6;O++)G(B.__webglFramebuffer[O],M,36064,34069+O);T(y,Y)&&S(34067,y,M.width,M.height),e.bindTexture(34067,null)}else{let O=3553;v&&(a?O=y.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(O,H.__webglTexture),W(O,y,Y),G(B.__webglFramebuffer,M,36064,O),T(y,Y)&&S(3553,y,M.width,M.height),e.bindTexture(3553,null)}M.depthBuffer&&Z(M)},this.updateRenderTargetMipmap=function(M){const y=M.texture;if(T(y,f(M)||a)){const B=M.isWebGLCubeRenderTarget?34067:3553,H=n.get(y).__webglTexture;e.bindTexture(B,H),S(B,y,M.width,M.height),e.bindTexture(B,null)}},this.updateMultisampleRenderTarget=function(M){if(M.isWebGLMultisampleRenderTarget)if(a){const y=M.width,B=M.height;let H=16384;M.depthBuffer&&(H|=256),M.stencilBuffer&&(H|=1024);const C=n.get(M);e.bindFramebuffer(36008,C.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,C.__webglFramebuffer),r.blitFramebuffer(0,0,y,B,0,0,y,B,H,9728),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,C.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(M,y){M&&M.isWebGLRenderTarget&&($===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),$=!0),M=M.texture),k(M,y)},this.safeSetTextureCube=function(M,y){M&&M.isWebGLCubeRenderTarget&&(st===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),st=!0),M=M.texture),N(M,y)}}function ba(r,t,e){const n=e.isWebGL2;return{convert:function(i){let A;if(i===1009)return 5121;if(i===1017)return 32819;if(i===1018)return 32820;if(i===1019)return 33635;if(i===1010)return 5120;if(i===1011)return 5122;if(i===1012)return 5123;if(i===1013)return 5124;if(i===1014)return 5125;if(i===1015)return 5126;if(i===1016)return n?5131:(A=t.get("OES_texture_half_float"),A!==null?A.HALF_FLOAT_OES:null);if(i===1021)return 6406;if(i===1022)return 6407;if(i===1023)return 6408;if(i===1024)return 6409;if(i===1025)return 6410;if(i===1026)return 6402;if(i===1027)return 34041;if(i===1028)return 6403;if(i===1029)return 36244;if(i===1030)return 33319;if(i===1031)return 33320;if(i===1032)return 36248;if(i===1033)return 36249;if(i===33776||i===33777||i===33778||i===33779){if(A=t.get("WEBGL_compressed_texture_s3tc"),A===null)return null;if(i===33776)return A.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===33777)return A.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===33778)return A.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===33779)return A.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(i===35840||i===35841||i===35842||i===35843){if(A=t.get("WEBGL_compressed_texture_pvrtc"),A===null)return null;if(i===35840)return A.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===35841)return A.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===35842)return A.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===35843)return A.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(i===36196)return A=t.get("WEBGL_compressed_texture_etc1"),A!==null?A.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===37492||i===37496)&&(A=t.get("WEBGL_compressed_texture_etc"),A!==null)){if(i===37492)return A.COMPRESSED_RGB8_ETC2;if(i===37496)return A.COMPRESSED_RGBA8_ETC2_EAC}return i===37808||i===37809||i===37810||i===37811||i===37812||i===37813||i===37814||i===37815||i===37816||i===37817||i===37818||i===37819||i===37820||i===37821||i===37840||i===37841||i===37842||i===37843||i===37844||i===37845||i===37846||i===37847||i===37848||i===37849||i===37850||i===37851||i===37852||i===37853?(A=t.get("WEBGL_compressed_texture_astc"),A!==null?i:null):i===36492?(A=t.get("EXT_texture_compression_bptc"),A!==null?i:null):i===1020?n?34042:(A=t.get("WEBGL_depth_texture"),A!==null?A.UNSIGNED_INT_24_8_WEBGL:null):void 0}}}class Sr extends Gt{constructor(t=[]){super(),this.cameras=t}}Sr.prototype.isArrayCamera=!0;class rn extends Rt{constructor(){super(),this.type="Group"}}rn.prototype.isGroup=!0;const Sa={type:"move"};class mi{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new rn,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new rn,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new w,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new w),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new rn,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new w,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new w),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let i=null,A=null,o=null;const a=this._targetRay,s=this._grip,l=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(a!==null&&(i=e.getPose(t.targetRaySpace,n),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(Sa))),l&&t.hand){o=!0;for(const p of t.hand.values()){const m=e.getJointPose(p,n);if(l.joints[p.jointName]===void 0){const T=new rn;T.matrixAutoUpdate=!1,T.visible=!1,l.joints[p.jointName]=T,l.add(T)}const f=l.joints[p.jointName];m!==null&&(f.matrix.fromArray(m.transform.matrix),f.matrix.decompose(f.position,f.rotation,f.scale),f.jointRadius=m.radius),f.visible=m!==null}const c=l.joints["index-finger-tip"],u=l.joints["thumb-tip"],h=c.position.distanceTo(u.position),d=.02,g=.005;l.inputState.pinching&&h>d+g?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!l.inputState.pinching&&h<=d-g&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else s!==null&&t.gripSpace&&(A=e.getPose(t.gripSpace,n),A!==null&&(s.matrix.fromArray(A.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),A.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(A.linearVelocity)):s.hasLinearVelocity=!1,A.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(A.angularVelocity)):s.hasAngularVelocity=!1));return a!==null&&(a.visible=i!==null),s!==null&&(s.visible=A!==null),l!==null&&(l.visible=o!==null),this}}class La extends Ne{constructor(t,e){super();const n=this,i=t.state;let A=null,o=1,a=null,s="local-floor",l=null;const c=[],u=new Map,h=new Gt;h.layers.enable(1),h.viewport=new Et;const d=new Gt;d.layers.enable(2),d.viewport=new Et;const g=[h,d],p=new Sr;p.layers.enable(1),p.layers.enable(2);let m=null,f=null;function T(N){const D=u.get(N.inputSource);D&&D.dispatchEvent({type:N.type,data:N.inputSource})}function S(){u.forEach(function(N,D){N.disconnect(D)}),u.clear(),m=null,f=null,i.bindXRFramebuffer(null),t.setRenderTarget(t.getRenderTarget()),k.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function b(N){const D=A.inputSources;for(let z=0;z<c.length;z++)u.set(D[z],c[z]);for(let z=0;z<N.removed.length;z++){const W=N.removed[z],F=u.get(W);F&&(F.dispatchEvent({type:"disconnected",data:W}),u.delete(W))}for(let z=0;z<N.added.length;z++){const W=N.added[z],F=u.get(W);F&&F.dispatchEvent({type:"connected",data:W})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(N){let D=c[N];return D===void 0&&(D=new mi,c[N]=D),D.getTargetRaySpace()},this.getControllerGrip=function(N){let D=c[N];return D===void 0&&(D=new mi,c[N]=D),D.getGripSpace()},this.getHand=function(N){let D=c[N];return D===void 0&&(D=new mi,c[N]=D),D.getHandSpace()},this.setFramebufferScaleFactor=function(N){o=N,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(N){s=N,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getSession=function(){return A},this.setSession=async function(N){if(A=N,A!==null){A.addEventListener("select",T),A.addEventListener("selectstart",T),A.addEventListener("selectend",T),A.addEventListener("squeeze",T),A.addEventListener("squeezestart",T),A.addEventListener("squeezeend",T),A.addEventListener("end",S),A.addEventListener("inputsourceschange",b);const D=e.getContextAttributes();D.xrCompatible!==!0&&await e.makeXRCompatible();const z={antialias:D.antialias,alpha:D.alpha,depth:D.depth,stencil:D.stencil,framebufferScaleFactor:o},W=new XRWebGLLayer(A,e,z);A.updateRenderState({baseLayer:W}),a=await A.requestReferenceSpace(s),k.setContext(A),k.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const I=new w,R=new w;function E(N,D){D===null?N.matrixWorld.copy(N.matrix):N.matrixWorld.multiplyMatrices(D.matrixWorld,N.matrix),N.matrixWorldInverse.copy(N.matrixWorld).invert()}this.getCamera=function(N){p.near=d.near=h.near=N.near,p.far=d.far=h.far=N.far,m===p.near&&f===p.far||(A.updateRenderState({depthNear:p.near,depthFar:p.far}),m=p.near,f=p.far);const D=N.parent,z=p.cameras;E(p,D);for(let F=0;F<z.length;F++)E(z[F],D);N.matrixWorld.copy(p.matrixWorld),N.matrix.copy(p.matrix),N.matrix.decompose(N.position,N.quaternion,N.scale);const W=N.children;for(let F=0,K=W.length;F<K;F++)W[F].updateMatrixWorld(!0);return z.length===2?function(F,K,G){I.setFromMatrixPosition(K.matrixWorld),R.setFromMatrixPosition(G.matrixWorld);const _=I.distanceTo(R),Z=K.projectionMatrix.elements,X=G.projectionMatrix.elements,$=Z[14]/(Z[10]-1),st=Z[14]/(Z[10]+1),M=(Z[9]+1)/Z[5],y=(Z[9]-1)/Z[5],B=(Z[8]-1)/Z[0],H=(X[8]+1)/X[0],C=$*B,tt=$*H,v=_/(-B+H),Y=v*-B;K.matrixWorld.decompose(F.position,F.quaternion,F.scale),F.translateX(Y),F.translateZ(v),F.matrixWorld.compose(F.position,F.quaternion,F.scale),F.matrixWorldInverse.copy(F.matrixWorld).invert();const O=$+v,it=st+v,Q=C-Y,rt=tt+(_-Y),et=M*st/it*O,pt=y*st/it*O;F.projectionMatrix.makePerspective(Q,rt,et,pt,O,it)}(p,h,d):p.projectionMatrix.copy(h.projectionMatrix),p};let L=null;const k=new $i;k.setAnimationLoop(function(N,D){if(l=D.getViewerPose(a),l!==null){const W=l.views,F=A.renderState.baseLayer;i.bindXRFramebuffer(F.framebuffer);let K=!1;W.length!==p.cameras.length&&(p.cameras.length=0,K=!0);for(let G=0;G<W.length;G++){const _=W[G],Z=F.getViewport(_),X=g[G];X.matrix.fromArray(_.transform.matrix),X.projectionMatrix.fromArray(_.projectionMatrix),X.viewport.set(Z.x,Z.y,Z.width,Z.height),G===0&&p.matrix.copy(X.matrix),K===!0&&p.cameras.push(X)}}const z=A.inputSources;for(let W=0;W<c.length;W++){const F=c[W],K=z[W];F.update(K,D,a)}L&&L(N,D)}),this.setAnimationLoop=function(N){L=N},this.dispose=function(){}}}function Ra(r){function t(n,i){n.opacity.value=i.opacity,i.color&&n.diffuse.value.copy(i.color),i.emissive&&n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),i.map&&(n.map.value=i.map),i.alphaMap&&(n.alphaMap.value=i.alphaMap),i.specularMap&&(n.specularMap.value=i.specularMap);const A=r.get(i).envMap;if(A){n.envMap.value=A,n.flipEnvMap.value=A.isCubeTexture&&A._needsFlipEnvMap?-1:1,n.reflectivity.value=i.reflectivity,n.refractionRatio.value=i.refractionRatio;const s=r.get(A).__maxMipLevel;s!==void 0&&(n.maxMipLevel.value=s)}let o,a;i.lightMap&&(n.lightMap.value=i.lightMap,n.lightMapIntensity.value=i.lightMapIntensity),i.aoMap&&(n.aoMap.value=i.aoMap,n.aoMapIntensity.value=i.aoMapIntensity),i.map?o=i.map:i.specularMap?o=i.specularMap:i.displacementMap?o=i.displacementMap:i.normalMap?o=i.normalMap:i.bumpMap?o=i.bumpMap:i.roughnessMap?o=i.roughnessMap:i.metalnessMap?o=i.metalnessMap:i.alphaMap?o=i.alphaMap:i.emissiveMap?o=i.emissiveMap:i.clearcoatMap?o=i.clearcoatMap:i.clearcoatNormalMap?o=i.clearcoatNormalMap:i.clearcoatRoughnessMap&&(o=i.clearcoatRoughnessMap),o!==void 0&&(o.isWebGLRenderTarget&&(o=o.texture),o.matrixAutoUpdate===!0&&o.updateMatrix(),n.uvTransform.value.copy(o.matrix)),i.aoMap?a=i.aoMap:i.lightMap&&(a=i.lightMap),a!==void 0&&(a.isWebGLRenderTarget&&(a=a.texture),a.matrixAutoUpdate===!0&&a.updateMatrix(),n.uv2Transform.value.copy(a.matrix))}function e(n,i){n.roughness.value=i.roughness,n.metalness.value=i.metalness,i.roughnessMap&&(n.roughnessMap.value=i.roughnessMap),i.metalnessMap&&(n.metalnessMap.value=i.metalnessMap),i.emissiveMap&&(n.emissiveMap.value=i.emissiveMap),i.bumpMap&&(n.bumpMap.value=i.bumpMap,n.bumpScale.value=i.bumpScale,i.side===1&&(n.bumpScale.value*=-1)),i.normalMap&&(n.normalMap.value=i.normalMap,n.normalScale.value.copy(i.normalScale),i.side===1&&n.normalScale.value.negate()),i.displacementMap&&(n.displacementMap.value=i.displacementMap,n.displacementScale.value=i.displacementScale,n.displacementBias.value=i.displacementBias),r.get(i).envMap&&(n.envMapIntensity.value=i.envMapIntensity)}return{refreshFogUniforms:function(n,i){n.fogColor.value.copy(i.color),i.isFog?(n.fogNear.value=i.near,n.fogFar.value=i.far):i.isFogExp2&&(n.fogDensity.value=i.density)},refreshMaterialUniforms:function(n,i,A,o){i.isMeshBasicMaterial?t(n,i):i.isMeshLambertMaterial?(t(n,i),function(a,s){s.emissiveMap&&(a.emissiveMap.value=s.emissiveMap)}(n,i)):i.isMeshToonMaterial?(t(n,i),function(a,s){s.gradientMap&&(a.gradientMap.value=s.gradientMap),s.emissiveMap&&(a.emissiveMap.value=s.emissiveMap),s.bumpMap&&(a.bumpMap.value=s.bumpMap,a.bumpScale.value=s.bumpScale,s.side===1&&(a.bumpScale.value*=-1)),s.normalMap&&(a.normalMap.value=s.normalMap,a.normalScale.value.copy(s.normalScale),s.side===1&&a.normalScale.value.negate()),s.displacementMap&&(a.displacementMap.value=s.displacementMap,a.displacementScale.value=s.displacementScale,a.displacementBias.value=s.displacementBias)}(n,i)):i.isMeshPhongMaterial?(t(n,i),function(a,s){a.specular.value.copy(s.specular),a.shininess.value=Math.max(s.shininess,1e-4),s.emissiveMap&&(a.emissiveMap.value=s.emissiveMap),s.bumpMap&&(a.bumpMap.value=s.bumpMap,a.bumpScale.value=s.bumpScale,s.side===1&&(a.bumpScale.value*=-1)),s.normalMap&&(a.normalMap.value=s.normalMap,a.normalScale.value.copy(s.normalScale),s.side===1&&a.normalScale.value.negate()),s.displacementMap&&(a.displacementMap.value=s.displacementMap,a.displacementScale.value=s.displacementScale,a.displacementBias.value=s.displacementBias)}(n,i)):i.isMeshStandardMaterial?(t(n,i),i.isMeshPhysicalMaterial?function(a,s){e(a,s),a.reflectivity.value=s.reflectivity,a.clearcoat.value=s.clearcoat,a.clearcoatRoughness.value=s.clearcoatRoughness,s.sheen&&a.sheen.value.copy(s.sheen),s.clearcoatMap&&(a.clearcoatMap.value=s.clearcoatMap),s.clearcoatRoughnessMap&&(a.clearcoatRoughnessMap.value=s.clearcoatRoughnessMap),s.clearcoatNormalMap&&(a.clearcoatNormalScale.value.copy(s.clearcoatNormalScale),a.clearcoatNormalMap.value=s.clearcoatNormalMap,s.side===1&&a.clearcoatNormalScale.value.negate()),a.transmission.value=s.transmission,s.transmissionMap&&(a.transmissionMap.value=s.transmissionMap)}(n,i):e(n,i)):i.isMeshMatcapMaterial?(t(n,i),function(a,s){s.matcap&&(a.matcap.value=s.matcap),s.bumpMap&&(a.bumpMap.value=s.bumpMap,a.bumpScale.value=s.bumpScale,s.side===1&&(a.bumpScale.value*=-1)),s.normalMap&&(a.normalMap.value=s.normalMap,a.normalScale.value.copy(s.normalScale),s.side===1&&a.normalScale.value.negate()),s.displacementMap&&(a.displacementMap.value=s.displacementMap,a.displacementScale.value=s.displacementScale,a.displacementBias.value=s.displacementBias)}(n,i)):i.isMeshDepthMaterial?(t(n,i),function(a,s){s.displacementMap&&(a.displacementMap.value=s.displacementMap,a.displacementScale.value=s.displacementScale,a.displacementBias.value=s.displacementBias)}(n,i)):i.isMeshDistanceMaterial?(t(n,i),function(a,s){s.displacementMap&&(a.displacementMap.value=s.displacementMap,a.displacementScale.value=s.displacementScale,a.displacementBias.value=s.displacementBias),a.referencePosition.value.copy(s.referencePosition),a.nearDistance.value=s.nearDistance,a.farDistance.value=s.farDistance}(n,i)):i.isMeshNormalMaterial?(t(n,i),function(a,s){s.bumpMap&&(a.bumpMap.value=s.bumpMap,a.bumpScale.value=s.bumpScale,s.side===1&&(a.bumpScale.value*=-1)),s.normalMap&&(a.normalMap.value=s.normalMap,a.normalScale.value.copy(s.normalScale),s.side===1&&a.normalScale.value.negate()),s.displacementMap&&(a.displacementMap.value=s.displacementMap,a.displacementScale.value=s.displacementScale,a.displacementBias.value=s.displacementBias)}(n,i)):i.isLineBasicMaterial?(function(a,s){a.diffuse.value.copy(s.color),a.opacity.value=s.opacity}(n,i),i.isLineDashedMaterial&&function(a,s){a.dashSize.value=s.dashSize,a.totalSize.value=s.dashSize+s.gapSize,a.scale.value=s.scale}(n,i)):i.isPointsMaterial?function(a,s,l,c){a.diffuse.value.copy(s.color),a.opacity.value=s.opacity,a.size.value=s.size*l,a.scale.value=.5*c,s.map&&(a.map.value=s.map),s.alphaMap&&(a.alphaMap.value=s.alphaMap);let u;s.map?u=s.map:s.alphaMap&&(u=s.alphaMap),u!==void 0&&(u.matrixAutoUpdate===!0&&u.updateMatrix(),a.uvTransform.value.copy(u.matrix))}(n,i,A,o):i.isSpriteMaterial?function(a,s){a.diffuse.value.copy(s.color),a.opacity.value=s.opacity,a.rotation.value=s.rotation,s.map&&(a.map.value=s.map),s.alphaMap&&(a.alphaMap.value=s.alphaMap);let l;s.map?l=s.map:s.alphaMap&&(l=s.alphaMap),l!==void 0&&(l.matrixAutoUpdate===!0&&l.updateMatrix(),a.uvTransform.value.copy(l.matrix))}(n,i):i.isShadowMaterial?(n.color.value.copy(i.color),n.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function Mt(r){const t=(r=r||{}).canvas!==void 0?r.canvas:function(){const x=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return x.style.display="block",x}(),e=r.context!==void 0?r.context:null,n=r.alpha!==void 0&&r.alpha,i=r.depth===void 0||r.depth,A=r.stencil===void 0||r.stencil,o=r.antialias!==void 0&&r.antialias,a=r.premultipliedAlpha===void 0||r.premultipliedAlpha,s=r.preserveDrawingBuffer!==void 0&&r.preserveDrawingBuffer,l=r.powerPreference!==void 0?r.powerPreference:"default",c=r.failIfMajorPerformanceCaveat!==void 0&&r.failIfMajorPerformanceCaveat;let u=null,h=null;const d=[],g=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const p=this;let m=!1,f=0,T=0,S=null,b=-1,I=null;const R=new Et,E=new Et;let L=null,k=t.width,N=t.height,D=1,z=null,W=null;const F=new Et(0,0,k,N),K=new Et(0,0,k,N);let G=!1;const _=new zn;let Z=!1,X=!1;const $=new ct,st=new w,M={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function y(){return S===null?D:1}let B,H,C,tt,v,Y,O,it,Q,rt,et,pt,bt,nt,dt,mt,he,xi,vi,Mi,Xt,Jt,j=e;function yi(x,J){for(let P=0;P<x.length;P++){const U=x[P],V=t.getContext(U,J);if(V!==null)return V}return null}try{const x={alpha:n,depth:i,stencil:A,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:s,powerPreference:l,failIfMajorPerformanceCaveat:c};if(t.addEventListener("webglcontextlost",Ei,!1),t.addEventListener("webglcontextrestored",Ti,!1),j===null){const J=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&J.shift(),j=yi(J,x),j===null)throw yi(J)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}j.getShaderPrecisionFormat===void 0&&(j.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(x){throw console.error("THREE.WebGLRenderer: "+x.message),x}function wi(){B=new cA(j),H=new sA(j,B,r),B.init(H),Xt=new ba(j,B,H),C=new Ea(j,B,H),tt=new dA(j),v=new pa,Y=new Ta(j,B,C,v,H,Xt,tt),O=new lA(p),it=new nA(j,H),Jt=new AA(j,B,it,H),Q=new uA(j,it,tt,Jt),rt=new gA(j,Q,it,tt),xi=new fA(j),dt=new oA(v),et=new da(p,O,B,H,Jt,dt),pt=new Ra(v),bt=new ga(v),nt=new wa(B,H),he=new rA(p,O,C,rt,a),mt=new br(p,rt,H),vi=new aA(j,B,tt,H),Mi=new hA(j,B,tt,H),tt.programs=et.programs,p.capabilities=H,p.extensions=B,p.properties=v,p.renderLists=bt,p.shadowMap=mt,p.state=C,p.info=tt}wi();const qt=new La(p,j);function Ei(x){x.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function Ti(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1;const x=tt.autoReset,J=mt.enabled,P=mt.autoUpdate,U=mt.needsUpdate,V=mt.type;wi(),tt.autoReset=x,mt.enabled=J,mt.autoUpdate=P,mt.needsUpdate=U,mt.type=V}function bi(x){const J=x.target;J.removeEventListener("dispose",bi),function(P){(function(U){const V=v.get(U).programs;V!==void 0&&V.forEach(function(lt){et.releaseProgram(lt)})})(P),v.remove(P)}(J)}this.xr=qt,this.getContext=function(){return j},this.getContextAttributes=function(){return j.getContextAttributes()},this.forceContextLoss=function(){const x=B.get("WEBGL_lose_context");x&&x.loseContext()},this.forceContextRestore=function(){const x=B.get("WEBGL_lose_context");x&&x.restoreContext()},this.getPixelRatio=function(){return D},this.setPixelRatio=function(x){x!==void 0&&(D=x,this.setSize(k,N,!1))},this.getSize=function(x){return x===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),x=new ft),x.set(k,N)},this.setSize=function(x,J,P){qt.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(k=x,N=J,t.width=Math.floor(x*D),t.height=Math.floor(J*D),P!==!1&&(t.style.width=x+"px",t.style.height=J+"px"),this.setViewport(0,0,x,J))},this.getDrawingBufferSize=function(x){return x===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),x=new ft),x.set(k*D,N*D).floor()},this.setDrawingBufferSize=function(x,J,P){k=x,N=J,D=P,t.width=Math.floor(x*P),t.height=Math.floor(J*P),this.setViewport(0,0,x,J)},this.getCurrentViewport=function(x){return x===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),x=new Et),x.copy(R)},this.getViewport=function(x){return x.copy(F)},this.setViewport=function(x,J,P,U){x.isVector4?F.set(x.x,x.y,x.z,x.w):F.set(x,J,P,U),C.viewport(R.copy(F).multiplyScalar(D).floor())},this.getScissor=function(x){return x.copy(K)},this.setScissor=function(x,J,P,U){x.isVector4?K.set(x.x,x.y,x.z,x.w):K.set(x,J,P,U),C.scissor(E.copy(K).multiplyScalar(D).floor())},this.getScissorTest=function(){return G},this.setScissorTest=function(x){C.setScissorTest(G=x)},this.setOpaqueSort=function(x){z=x},this.setTransparentSort=function(x){W=x},this.getClearColor=function(x){return x===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),x=new vt),x.copy(he.getClearColor())},this.setClearColor=function(){he.setClearColor.apply(he,arguments)},this.getClearAlpha=function(){return he.getClearAlpha()},this.setClearAlpha=function(){he.setClearAlpha.apply(he,arguments)},this.clear=function(x,J,P){let U=0;(x===void 0||x)&&(U|=16384),(J===void 0||J)&&(U|=256),(P===void 0||P)&&(U|=1024),j.clear(U)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Ei,!1),t.removeEventListener("webglcontextrestored",Ti,!1),bt.dispose(),nt.dispose(),v.dispose(),O.dispose(),rt.dispose(),Jt.dispose(),qt.dispose(),qt.removeEventListener("sessionstart",Si),qt.removeEventListener("sessionend",Li),we.stop()},this.renderBufferImmediate=function(x,J){Jt.initAttributes();const P=v.get(x);x.hasPositions&&!P.position&&(P.position=j.createBuffer()),x.hasNormals&&!P.normal&&(P.normal=j.createBuffer()),x.hasUvs&&!P.uv&&(P.uv=j.createBuffer()),x.hasColors&&!P.color&&(P.color=j.createBuffer());const U=J.getAttributes();x.hasPositions&&(j.bindBuffer(34962,P.position),j.bufferData(34962,x.positionArray,35048),Jt.enableAttribute(U.position),j.vertexAttribPointer(U.position,3,5126,!1,0,0)),x.hasNormals&&(j.bindBuffer(34962,P.normal),j.bufferData(34962,x.normalArray,35048),Jt.enableAttribute(U.normal),j.vertexAttribPointer(U.normal,3,5126,!1,0,0)),x.hasUvs&&(j.bindBuffer(34962,P.uv),j.bufferData(34962,x.uvArray,35048),Jt.enableAttribute(U.uv),j.vertexAttribPointer(U.uv,2,5126,!1,0,0)),x.hasColors&&(j.bindBuffer(34962,P.color),j.bufferData(34962,x.colorArray,35048),Jt.enableAttribute(U.color),j.vertexAttribPointer(U.color,3,5126,!1,0,0)),Jt.disableUnusedAttributes(),j.drawArrays(4,0,x.count),x.count=0},this.renderBufferDirect=function(x,J,P,U,V,lt){J===null&&(J=M);const at=V.isMesh&&V.matrixWorld.determinant()<0,ut=Ci(x,J,U,V);C.setMaterial(U,at);let gt=P.index;const ot=P.attributes.position;if(gt===null){if(ot===void 0||ot.count===0)return}else if(gt.count===0)return;let xt,At=1;U.wireframe===!0&&(gt=Q.getWireframeAttribute(P),At=2),(U.morphTargets||U.morphNormals)&&xi.update(V,P,U,ut),Jt.setup(V,U,ut,P,gt);let wt=vi;gt!==null&&(xt=it.get(gt),wt=Mi,wt.setIndex(xt));const te=gt!==null?gt.count:ot.count,Tt=P.drawRange.start*At,Ee=P.drawRange.count*At,Lt=lt!==null?lt.start*At:0,Te=lt!==null?lt.count*At:1/0,Ht=Math.max(Tt,Lt),Ft=Math.min(te,Tt+Ee,Lt+Te)-1,St=Math.max(0,Ft-Ht+1);if(St!==0){if(V.isMesh)U.wireframe===!0?(C.setLineWidth(U.wireframeLinewidth*y()),wt.setMode(1)):wt.setMode(4);else if(V.isLine){let be=U.linewidth;be===void 0&&(be=1),C.setLineWidth(be*y()),V.isLineSegments?wt.setMode(1):V.isLineLoop?wt.setMode(2):wt.setMode(3)}else V.isPoints?wt.setMode(0):V.isSprite&&wt.setMode(4);if(V.isInstancedMesh)wt.renderInstances(Ht,St,V.count);else if(P.isInstancedBufferGeometry){const be=Math.min(P.instanceCount,P._maxInstanceCount);wt.renderInstances(Ht,St,be)}else wt.render(Ht,St)}},this.compile=function(x,J){h=nt.get(x),h.init(),x.traverseVisible(function(P){P.isLight&&P.layers.test(J.layers)&&(h.pushLight(P),P.castShadow&&h.pushShadow(P))}),h.setupLights(),x.traverse(function(P){const U=P.material;if(U)if(Array.isArray(U))for(let V=0;V<U.length;V++)Fn(U[V],x,P);else Fn(U,x,P)})};let Jn=null;function Si(){we.stop()}function Li(){we.start()}const we=new $i;function Ri(x,J,P,U){if(x.visible===!1)return;if(x.layers.test(J.layers)){if(x.isGroup)P=x.renderOrder;else if(x.isLOD)x.autoUpdate===!0&&x.update(J);else if(x.isLight)h.pushLight(x),x.castShadow&&h.pushShadow(x);else if(x.isSprite){if(!x.frustumCulled||_.intersectsSprite(x)){U&&st.setFromMatrixPosition(x.matrixWorld).applyMatrix4($);const lt=rt.update(x),at=x.material;at.visible&&u.push(x,lt,at,P,st.z,null)}}else if(x.isImmediateRenderObject)U&&st.setFromMatrixPosition(x.matrixWorld).applyMatrix4($),u.push(x,null,x.material,P,st.z,null);else if((x.isMesh||x.isLine||x.isPoints)&&(x.isSkinnedMesh&&x.skeleton.frame!==tt.render.frame&&(x.skeleton.update(),x.skeleton.frame=tt.render.frame),!x.frustumCulled||_.intersectsObject(x))){U&&st.setFromMatrixPosition(x.matrixWorld).applyMatrix4($);const lt=rt.update(x),at=x.material;if(Array.isArray(at)){const ut=lt.groups;for(let gt=0,ot=ut.length;gt<ot;gt++){const xt=ut[gt],At=at[xt.materialIndex];At&&At.visible&&u.push(x,lt,At,P,st.z,xt)}}else at.visible&&u.push(x,lt,at,P,st.z,null)}}const V=x.children;for(let lt=0,at=V.length;lt<at;lt++)Ri(V[lt],J,P,U)}function Pi(x,J,P){const U=J.isScene===!0?J.overrideMaterial:null;for(let V=0,lt=x.length;V<lt;V++){const at=x[V],ut=at.object,gt=at.geometry,ot=U===null?at.material:U,xt=at.group;if(P.isArrayCamera){const At=P.cameras;for(let wt=0,te=At.length;wt<te;wt++){const Tt=At[wt];ut.layers.test(Tt.layers)&&(C.viewport(R.copy(Tt.viewport)),h.setupLightsView(Tt),Ni(ut,J,Tt,gt,ot,xt))}}else Ni(ut,J,P,gt,ot,xt)}}function Ni(x,J,P,U,V,lt){if(x.onBeforeRender(p,J,P,U,V,lt),x.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse,x.matrixWorld),x.normalMatrix.getNormalMatrix(x.modelViewMatrix),x.isImmediateRenderObject){const at=Ci(P,J,V,x);C.setMaterial(V),Jt.reset(),function(ut,gt){ut.render(function(ot){p.renderBufferImmediate(ot,gt)})}(x,at)}else p.renderBufferDirect(P,J,U,V,x,lt);x.onAfterRender(p,J,P,U,V,lt)}function Fn(x,J,P){J.isScene!==!0&&(J=M);const U=v.get(x),V=h.state.lights,lt=h.state.shadowsArray,at=V.state.version,ut=et.getParameters(x,V.state,lt,J,P),gt=et.getProgramCacheKey(ut);let ot=U.programs;U.environment=x.isMeshStandardMaterial?J.environment:null,U.fog=J.fog,U.envMap=O.get(x.envMap||U.environment),ot===void 0&&(x.addEventListener("dispose",bi),ot=new Map,U.programs=ot);let xt=ot.get(gt);if(xt!==void 0){if(U.currentProgram===xt&&U.lightsStateVersion===at)return Ii(x,ut),xt}else ut.uniforms=et.getUniforms(x),x.onBuild(ut,p),x.onBeforeCompile(ut,p),xt=et.acquireProgram(ut,gt),ot.set(gt,xt),U.uniforms=ut.uniforms;const At=U.uniforms;(x.isShaderMaterial||x.isRawShaderMaterial)&&x.clipping!==!0||(At.clippingPlanes=dt.uniform),Ii(x,ut),U.needsLights=function(Tt){return Tt.isMeshLambertMaterial||Tt.isMeshToonMaterial||Tt.isMeshPhongMaterial||Tt.isMeshStandardMaterial||Tt.isShadowMaterial||Tt.isShaderMaterial&&Tt.lights===!0}(x),U.lightsStateVersion=at,U.needsLights&&(At.ambientLightColor.value=V.state.ambient,At.lightProbe.value=V.state.probe,At.directionalLights.value=V.state.directional,At.directionalLightShadows.value=V.state.directionalShadow,At.spotLights.value=V.state.spot,At.spotLightShadows.value=V.state.spotShadow,At.rectAreaLights.value=V.state.rectArea,At.ltc_1.value=V.state.rectAreaLTC1,At.ltc_2.value=V.state.rectAreaLTC2,At.pointLights.value=V.state.point,At.pointLightShadows.value=V.state.pointShadow,At.hemisphereLights.value=V.state.hemi,At.directionalShadowMap.value=V.state.directionalShadowMap,At.directionalShadowMatrix.value=V.state.directionalShadowMatrix,At.spotShadowMap.value=V.state.spotShadowMap,At.spotShadowMatrix.value=V.state.spotShadowMatrix,At.pointShadowMap.value=V.state.pointShadowMap,At.pointShadowMatrix.value=V.state.pointShadowMatrix);const wt=xt.getUniforms(),te=Me.seqWithValue(wt.seq,At);return U.currentProgram=xt,U.uniformsList=te,xt}function Ii(x,J){const P=v.get(x);P.outputEncoding=J.outputEncoding,P.instancing=J.instancing,P.numClippingPlanes=J.numClippingPlanes,P.numIntersection=J.numClipIntersection,P.vertexAlphas=J.vertexAlphas}function Ci(x,J,P,U){J.isScene!==!0&&(J=M),Y.resetTextureUnits();const V=J.fog,lt=P.isMeshStandardMaterial?J.environment:null,at=S===null?p.outputEncoding:S.texture.encoding,ut=O.get(P.envMap||lt),gt=P.vertexColors===!0&&U.geometry&&U.geometry.attributes.color&&U.geometry.attributes.color.itemSize===4,ot=v.get(P),xt=h.state.lights;if(Z===!0&&(X===!0||x!==I)){const St=x===I&&P.id===b;dt.setState(P,x,St)}let At=!1;P.version===ot.__version?ot.needsLights&&ot.lightsStateVersion!==xt.state.version||ot.outputEncoding!==at||U.isInstancedMesh&&ot.instancing===!1?At=!0:U.isInstancedMesh||ot.instancing!==!0?ot.envMap!==ut||P.fog&&ot.fog!==V?At=!0:ot.numClippingPlanes===void 0||ot.numClippingPlanes===dt.numPlanes&&ot.numIntersection===dt.numIntersection?ot.vertexAlphas!==gt&&(At=!0):At=!0:At=!0:(At=!0,ot.__version=P.version);let wt=ot.currentProgram;At===!0&&(wt=Fn(P,J,U));let te=!1,Tt=!1,Ee=!1;const Lt=wt.getUniforms(),Te=ot.uniforms;if(C.useProgram(wt.program)&&(te=!0,Tt=!0,Ee=!0),P.id!==b&&(b=P.id,Tt=!0),te||I!==x){if(Lt.setValue(j,"projectionMatrix",x.projectionMatrix),H.logarithmicDepthBuffer&&Lt.setValue(j,"logDepthBufFC",2/(Math.log(x.far+1)/Math.LN2)),I!==x&&(I=x,Tt=!0,Ee=!0),P.isShaderMaterial||P.isMeshPhongMaterial||P.isMeshToonMaterial||P.isMeshStandardMaterial||P.envMap){const St=Lt.map.cameraPosition;St!==void 0&&St.setValue(j,st.setFromMatrixPosition(x.matrixWorld))}(P.isMeshPhongMaterial||P.isMeshToonMaterial||P.isMeshLambertMaterial||P.isMeshBasicMaterial||P.isMeshStandardMaterial||P.isShaderMaterial)&&Lt.setValue(j,"isOrthographic",x.isOrthographicCamera===!0),(P.isMeshPhongMaterial||P.isMeshToonMaterial||P.isMeshLambertMaterial||P.isMeshBasicMaterial||P.isMeshStandardMaterial||P.isShaderMaterial||P.isShadowMaterial||P.skinning)&&Lt.setValue(j,"viewMatrix",x.matrixWorldInverse)}if(P.skinning){Lt.setOptional(j,U,"bindMatrix"),Lt.setOptional(j,U,"bindMatrixInverse");const St=U.skeleton;if(St){const be=St.bones;if(H.floatVertexTextures){if(St.boneTexture===null){let re=Math.sqrt(4*be.length);re=Wi(re),re=Math.max(re,4);const Bn=new Float32Array(re*re*4);Bn.set(St.boneMatrices);const Fr=new _i(Bn,re,re,1023,1015);St.boneMatrices=Bn,St.boneTexture=Fr,St.boneTextureSize=re}Lt.setValue(j,"boneTexture",St.boneTexture,Y),Lt.setValue(j,"boneTextureSize",St.boneTextureSize)}else Lt.setOptional(j,St,"boneMatrices")}}var Ht,Ft;return(Tt||ot.receiveShadow!==U.receiveShadow)&&(ot.receiveShadow=U.receiveShadow,Lt.setValue(j,"receiveShadow",U.receiveShadow)),Tt&&(Lt.setValue(j,"toneMappingExposure",p.toneMappingExposure),ot.needsLights&&(Ft=Ee,(Ht=Te).ambientLightColor.needsUpdate=Ft,Ht.lightProbe.needsUpdate=Ft,Ht.directionalLights.needsUpdate=Ft,Ht.directionalLightShadows.needsUpdate=Ft,Ht.pointLights.needsUpdate=Ft,Ht.pointLightShadows.needsUpdate=Ft,Ht.spotLights.needsUpdate=Ft,Ht.spotLightShadows.needsUpdate=Ft,Ht.rectAreaLights.needsUpdate=Ft,Ht.hemisphereLights.needsUpdate=Ft),V&&P.fog&&pt.refreshFogUniforms(Te,V),pt.refreshMaterialUniforms(Te,P,D,N),Me.upload(j,ot.uniformsList,Te,Y)),P.isShaderMaterial&&P.uniformsNeedUpdate===!0&&(Me.upload(j,ot.uniformsList,Te,Y),P.uniformsNeedUpdate=!1),P.isSpriteMaterial&&Lt.setValue(j,"center",U.center),Lt.setValue(j,"modelViewMatrix",U.modelViewMatrix),Lt.setValue(j,"normalMatrix",U.normalMatrix),Lt.setValue(j,"modelMatrix",U.matrixWorld),wt}we.setAnimationLoop(function(x){Jn&&Jn(x)}),typeof window!="undefined"&&we.setContext(window),this.setAnimationLoop=function(x){Jn=x,qt.setAnimationLoop(x),x===null?we.stop():we.start()},qt.addEventListener("sessionstart",Si),qt.addEventListener("sessionend",Li),this.render=function(x,J){let P,U;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),P=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),U=arguments[3]),J!==void 0&&J.isCamera!==!0)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(m===!0)return;x.autoUpdate===!0&&x.updateMatrixWorld(),J.parent===null&&J.updateMatrixWorld(),qt.enabled===!0&&qt.isPresenting===!0&&(J=qt.getCamera(J)),x.isScene===!0&&x.onBeforeRender(p,x,J,P||S),h=nt.get(x,g.length),h.init(),g.push(h),$.multiplyMatrices(J.projectionMatrix,J.matrixWorldInverse),_.setFromProjectionMatrix($),X=this.localClippingEnabled,Z=dt.init(this.clippingPlanes,X,J),u=bt.get(x,d.length),u.init(),d.push(u),Ri(x,J,0,p.sortObjects),u.finish(),p.sortObjects===!0&&u.sort(z,W),Z===!0&&dt.beginShadows();const V=h.state.shadowsArray;mt.render(V,x,J),h.setupLights(),h.setupLightsView(J),Z===!0&&dt.endShadows(),this.info.autoReset===!0&&this.info.reset(),P!==void 0&&this.setRenderTarget(P),he.render(u,x,J,U);const lt=u.opaque,at=u.transparent;lt.length>0&&Pi(lt,x,J),at.length>0&&Pi(at,x,J),S!==null&&(Y.updateRenderTargetMipmap(S),Y.updateMultisampleRenderTarget(S)),x.isScene===!0&&x.onAfterRender(p,x,J),C.buffers.depth.setTest(!0),C.buffers.depth.setMask(!0),C.buffers.color.setMask(!0),C.setPolygonOffset(!1),Jt.resetDefaultState(),b=-1,I=null,g.pop(),h=g.length>0?g[g.length-1]:null,d.pop(),u=d.length>0?d[d.length-1]:null},this.getActiveCubeFace=function(){return f},this.getActiveMipmapLevel=function(){return T},this.getRenderTarget=function(){return S},this.setRenderTarget=function(x,J=0,P=0){S=x,f=J,T=P,x&&v.get(x).__webglFramebuffer===void 0&&Y.setupRenderTarget(x);let U=null,V=!1,lt=!1;if(x){const at=x.texture;(at.isDataTexture3D||at.isDataTexture2DArray)&&(lt=!0);const ut=v.get(x).__webglFramebuffer;x.isWebGLCubeRenderTarget?(U=ut[J],V=!0):U=x.isWebGLMultisampleRenderTarget?v.get(x).__webglMultisampledFramebuffer:ut,R.copy(x.viewport),E.copy(x.scissor),L=x.scissorTest}else R.copy(F).multiplyScalar(D).floor(),E.copy(K).multiplyScalar(D).floor(),L=G;if(C.bindFramebuffer(36160,U),C.viewport(R),C.scissor(E),C.setScissorTest(L),V){const at=v.get(x.texture);j.framebufferTexture2D(36160,36064,34069+J,at.__webglTexture,P)}else if(lt){const at=v.get(x.texture),ut=J||0;j.framebufferTextureLayer(36160,36064,at.__webglTexture,P||0,ut)}},this.readRenderTargetPixels=function(x,J,P,U,V,lt,at){if(!x||!x.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let ut=v.get(x).__webglFramebuffer;if(x.isWebGLCubeRenderTarget&&at!==void 0&&(ut=ut[at]),ut){C.bindFramebuffer(36160,ut);try{const gt=x.texture,ot=gt.format,xt=gt.type;if(ot!==1023&&Xt.convert(ot)!==j.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const At=xt===1016&&(B.has("EXT_color_buffer_half_float")||H.isWebGL2&&B.has("EXT_color_buffer_float"));if(!(xt===1009||Xt.convert(xt)===j.getParameter(35738)||xt===1015&&(H.isWebGL2||B.has("OES_texture_float")||B.has("WEBGL_color_buffer_float"))||At))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");j.checkFramebufferStatus(36160)===36053?J>=0&&J<=x.width-U&&P>=0&&P<=x.height-V&&j.readPixels(J,P,U,V,Xt.convert(ot),Xt.convert(xt),lt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const gt=S!==null?v.get(S).__webglFramebuffer:null;C.bindFramebuffer(36160,gt)}}},this.copyFramebufferToTexture=function(x,J,P=0){const U=Math.pow(2,-P),V=Math.floor(J.image.width*U),lt=Math.floor(J.image.height*U),at=Xt.convert(J.format);Y.setTexture2D(J,0),j.copyTexImage2D(3553,P,at,x.x,x.y,V,lt,0),C.unbindTexture()},this.copyTextureToTexture=function(x,J,P,U=0){const V=J.image.width,lt=J.image.height,at=Xt.convert(P.format),ut=Xt.convert(P.type);Y.setTexture2D(P,0),j.pixelStorei(37440,P.flipY),j.pixelStorei(37441,P.premultiplyAlpha),j.pixelStorei(3317,P.unpackAlignment),J.isDataTexture?j.texSubImage2D(3553,U,x.x,x.y,V,lt,at,ut,J.image.data):J.isCompressedTexture?j.compressedTexSubImage2D(3553,U,x.x,x.y,J.mipmaps[0].width,J.mipmaps[0].height,at,J.mipmaps[0].data):j.texSubImage2D(3553,U,x.x,x.y,at,ut,J.image),U===0&&P.generateMipmaps&&j.generateMipmap(3553),C.unbindTexture()},this.copyTextureToTexture3D=function(x,J,P,U,V=0){if(p.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const{width:lt,height:at,data:ut}=P.image,gt=Xt.convert(U.format),ot=Xt.convert(U.type);let xt;if(U.isDataTexture3D)Y.setTexture3D(U,0),xt=32879;else{if(!U.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");Y.setTexture2DArray(U,0),xt=35866}j.pixelStorei(37440,U.flipY),j.pixelStorei(37441,U.premultiplyAlpha),j.pixelStorei(3317,U.unpackAlignment);const At=j.getParameter(3314),wt=j.getParameter(32878),te=j.getParameter(3316),Tt=j.getParameter(3315),Ee=j.getParameter(32877);j.pixelStorei(3314,lt),j.pixelStorei(32878,at),j.pixelStorei(3316,x.min.x),j.pixelStorei(3315,x.min.y),j.pixelStorei(32877,x.min.z),j.texSubImage3D(xt,V,J.x,J.y,J.z,x.max.x-x.min.x+1,x.max.y-x.min.y+1,x.max.z-x.min.z+1,gt,ot,ut),j.pixelStorei(3314,At),j.pixelStorei(32878,wt),j.pixelStorei(3316,te),j.pixelStorei(3315,Tt),j.pixelStorei(32877,Ee),V===0&&U.generateMipmaps&&j.generateMipmap(xt),C.unbindTexture()},this.initTexture=function(x){Y.setTexture2D(x,0),C.unbindTexture()},this.resetState=function(){f=0,T=0,S=null,C.reset(),Jt.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class fi extends Rt{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.background!==null&&(e.object.background=this.background.toJSON(t)),this.environment!==null&&(e.object.environment=this.environment.toJSON(t)),this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}fi.prototype.isScene=!0;class Lr extends It{constructor(t=1,e=8,n=6,i=0,A=2*Math.PI,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:t,widthSegments:e,heightSegments:n,phiStart:i,phiLength:A,thetaStart:o,thetaLength:a},e=Math.max(3,Math.floor(e)),n=Math.max(2,Math.floor(n));const s=Math.min(o+a,Math.PI);let l=0;const c=[],u=new w,h=new w,d=[],g=[],p=[],m=[];for(let f=0;f<=n;f++){const T=[],S=f/n;let b=0;f==0&&o==0?b=.5/e:f==n&&s==Math.PI&&(b=-.5/e);for(let I=0;I<=e;I++){const R=I/e;u.x=-t*Math.cos(i+R*A)*Math.sin(o+S*a),u.y=t*Math.cos(o+S*a),u.z=t*Math.sin(i+R*A)*Math.sin(o+S*a),g.push(u.x,u.y,u.z),h.copy(u).normalize(),p.push(h.x,h.y,h.z),m.push(R+b,1-S),T.push(l++)}c.push(T)}for(let f=0;f<n;f++)for(let T=0;T<e;T++){const S=c[f][T+1],b=c[f][T],I=c[f+1][T],R=c[f+1][T+1];(f!==0||o>0)&&d.push(S,b,R),(f!==n-1||s<Math.PI)&&d.push(b,I,R)}this.setIndex(d),this.setAttribute("position",new Ot(g,3)),this.setAttribute("normal",new Ot(p,3)),this.setAttribute("uv",new Ot(m,2))}}class Pa extends It{constructor(t=1,e=.4,n=8,i=6,A=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:t,tube:e,radialSegments:n,tubularSegments:i,arc:A},n=Math.floor(n),i=Math.floor(i);const o=[],a=[],s=[],l=[],c=new w,u=new w,h=new w;for(let d=0;d<=n;d++)for(let g=0;g<=i;g++){const p=g/i*A,m=d/n*Math.PI*2;u.x=(t+e*Math.cos(m))*Math.cos(p),u.y=(t+e*Math.cos(m))*Math.sin(p),u.z=e*Math.sin(m),a.push(u.x,u.y,u.z),c.x=t*Math.cos(p),c.y=t*Math.sin(p),h.subVectors(u,c).normalize(),s.push(h.x,h.y,h.z),l.push(g/i),l.push(d/n)}for(let d=1;d<=n;d++)for(let g=1;g<=i;g++){const p=(i+1)*d+g-1,m=(i+1)*(d-1)+g-1,f=(i+1)*(d-1)+g,T=(i+1)*d+g;o.push(p,m,T),o.push(m,f,T)}this.setIndex(o),this.setAttribute("position",new Ot(a,3)),this.setAttribute("normal",new Ot(s,3)),this.setAttribute("uv",new Ot(l,2))}}class Un extends ue{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new vt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new vt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new ft(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.skinning=t.skinning,this.morphTargets=t.morphTargets,this.morphNormals=t.morphNormals,this.flatShading=t.flatShading,this.vertexTangents=t.vertexTangents,this}}Un.prototype.isMeshStandardMaterial=!0;const Rr={enabled:!1,files:{},add:function(r,t){this.enabled!==!1&&(this.files[r]=t)},get:function(r){if(this.enabled!==!1)return this.files[r]},remove:function(r){delete this.files[r]},clear:function(){this.files={}}},Na=new class{constructor(r,t,e){const n=this;let i,A=!1,o=0,a=0;const s=[];this.onStart=void 0,this.onLoad=r,this.onProgress=t,this.onError=e,this.itemStart=function(l){a++,A===!1&&n.onStart!==void 0&&n.onStart(l,o,a),A=!0},this.itemEnd=function(l){o++,n.onProgress!==void 0&&n.onProgress(l,o,a),o===a&&(A=!1,n.onLoad!==void 0&&n.onLoad())},this.itemError=function(l){n.onError!==void 0&&n.onError(l)},this.resolveURL=function(l){return i?i(l):l},this.setURLModifier=function(l){return i=l,this},this.addHandler=function(l,c){return s.push(l,c),this},this.removeHandler=function(l){const c=s.indexOf(l);return c!==-1&&s.splice(c,2),this},this.getHandler=function(l){for(let c=0,u=s.length;c<u;c+=2){const h=s[c],d=s[c+1];if(h.global&&(h.lastIndex=0),h.test(l))return d}return null}}};class An{constructor(t){this.manager=t!==void 0?t:Na,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(i,A){n.load(t,i,e,A)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}class Pr extends An{constructor(t){super(t)}load(t,e,n,i){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const A=this,o=Rr.get(t);if(o!==void 0)return A.manager.itemStart(t),setTimeout(function(){e&&e(o),A.manager.itemEnd(t)},0),o;const a=document.createElementNS("http://www.w3.org/1999/xhtml","img");function s(){a.removeEventListener("load",s,!1),a.removeEventListener("error",l,!1),Rr.add(t,this),e&&e(this),A.manager.itemEnd(t)}function l(c){a.removeEventListener("load",s,!1),a.removeEventListener("error",l,!1),i&&i(c),A.manager.itemError(t),A.manager.itemEnd(t)}return a.addEventListener("load",s,!1),a.addEventListener("error",l,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),A.manager.itemStart(t),a.src=t,a}}class Ia extends An{constructor(t){super(t)}load(t,e,n,i){const A=new Cn,o=new Pr(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function s(l){o.load(t[l],function(c){A.images[l]=c,a++,a===6&&(A.needsUpdate=!0,e&&e(A))},void 0,i)}for(let l=0;l<t.length;++l)s(l);return A}}class an extends An{constructor(t){super(t)}load(t,e,n,i){const A=new Bt,o=new Pr(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(t,function(a){A.image=a;const s=t.search(/\.jpe?g($|\?)/i)>0||t.search(/^data\:image\/jpeg/)===0;A.format=s?1022:1023,A.needsUpdate=!0,e!==void 0&&e(A)},n,i),A}}class Hn extends Rt{constructor(t,e=1){super(),this.type="Light",this.color=new vt(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}Hn.prototype.isLight=!0;const Nr=new ct,Ir=new w,Cr=new w,Wr=new ct,sn=new w,gi=new w;class zr extends class{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new ft(512,512),this.map=null,this.mapPass=null,this.matrix=new ct,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new zn,this._frameExtents=new ft(1,1),this._viewportCount=1,this._viewports=[new Et(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Ir.setFromMatrixPosition(t.matrixWorld),e.position.copy(Ir),Cr.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Cr),e.updateMatrixWorld(),Nr.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Nr),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),this.mapSize.x===512&&this.mapSize.y===512||(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}{constructor(){super(new Gt(90,1,.5,500)),this._frameExtents=new ft(4,2),this._viewportCount=6,this._viewports=[new Et(2,1,1,1),new Et(0,1,1,1),new Et(3,1,1,1),new Et(1,1,1,1),new Et(3,0,1,1),new Et(1,0,1,1)],this._cubeDirections=[new w(1,0,0),new w(-1,0,0),new w(0,0,1),new w(0,0,-1),new w(0,1,0),new w(0,-1,0)],this._cubeUps=[new w(0,1,0),new w(0,1,0),new w(0,1,0),new w(0,1,0),new w(0,0,1),new w(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,i=this.matrix,A=t.distance||n.far;A!==n.far&&(n.far=A,n.updateProjectionMatrix()),sn.setFromMatrixPosition(t.matrixWorld),n.position.copy(sn),gi.copy(n.position),gi.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(gi),n.updateMatrixWorld(),i.makeTranslation(-sn.x,-sn.y,-sn.z),Wr.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Wr)}}zr.prototype.isPointLightShadow=!0;class Ur extends Hn{constructor(t,e,n=0,i=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new zr}get power(){return 4*this.intensity*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}Ur.prototype.isPointLight=!0;class Hr extends Hn{constructor(t,e){super(t,e),this.type="AmbientLight"}}Hr.prototype.isAmbientLight=!0;const Ca="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]";/((?:WC+[\/:])*)/.source.replace("WC","[^\\[\\]\\.:\\/]"),/(WCOD+)?/.source.replace("WCOD",Ca),/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC","[^\\[\\]\\.:\\/]"),/\.(WC+)(?:\[(.+)\])?/.source.replace("WC","[^\\[\\]\\.:\\/]");const Wa=new yn({side:1,depthWrite:!1,depthTest:!1});new Zt(new In,Wa),An.prototype.extractUrlBase=function(r){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),class{static decodeText(t){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(t);let e="";for(let n=0,i=t.length;n<i;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.substr(0,e+1)}}.extractUrlBase(r)},An.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Vt.prototype.center=function(r){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(r)},Vt.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Vt.prototype.isIntersectionBox=function(r){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(r)},Vt.prototype.isIntersectionSphere=function(r){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(r)},Vt.prototype.size=function(r){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(r)},pn.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},zn.prototype.setFromMatrix=function(r){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(r)},Wt.prototype.flattenToArrayOffset=function(r,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(r,t)},Wt.prototype.multiplyVector3=function(r){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),r.applyMatrix3(this)},Wt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},Wt.prototype.applyToBufferAttribute=function(r){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),r.applyMatrix3(this)},Wt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},Wt.prototype.getInverse=function(r){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(r).invert()},ct.prototype.extractPosition=function(r){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(r)},ct.prototype.flattenToArrayOffset=function(r,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(r,t)},ct.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new w().setFromMatrixColumn(this,3)},ct.prototype.setRotationFromQuaternion=function(r){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(r)},ct.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},ct.prototype.multiplyVector3=function(r){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)},ct.prototype.multiplyVector4=function(r){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)},ct.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},ct.prototype.rotateAxis=function(r){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),r.transformDirection(this)},ct.prototype.crossVector=function(r){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)},ct.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},ct.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},ct.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},ct.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},ct.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},ct.prototype.applyToBufferAttribute=function(r){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)},ct.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},ct.prototype.makeFrustum=function(r,t,e,n,i,A){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(r,t,n,e,i,A)},ct.prototype.getInverse=function(r){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(r).invert()},ee.prototype.isIntersectionLine=function(r){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(r)},Ae.prototype.multiplyVector3=function(r){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),r.applyQuaternion(this)},Ae.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},gn.prototype.isIntersectionBox=function(r){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(r)},gn.prototype.isIntersectionPlane=function(r){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(r)},gn.prototype.isIntersectionSphere=function(r){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(r)},Pt.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},Pt.prototype.barycoordFromPoint=function(r,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(r,t)},Pt.prototype.midpoint=function(r){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(r)},Pt.prototypenormal=function(r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(r)},Pt.prototype.plane=function(r){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(r)},Pt.barycoordFromPoint=function(r,t,e,n,i){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Pt.getBarycoord(r,t,e,n,i)},Pt.normal=function(r,t,e,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Pt.getNormal(r,t,e,n)},ft.prototype.fromAttribute=function(r,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,t,e)},ft.prototype.distanceToManhattan=function(r){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(r)},ft.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},w.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},w.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},w.prototype.getPositionFromMatrix=function(r){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(r)},w.prototype.getScaleFromMatrix=function(r){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(r)},w.prototype.getColumnFromMatrix=function(r,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,r)},w.prototype.applyProjection=function(r){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(r)},w.prototype.fromAttribute=function(r,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,t,e)},w.prototype.distanceToManhattan=function(r){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(r)},w.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Et.prototype.fromAttribute=function(r,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,t,e)},Et.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Rt.prototype.getChildByName=function(r){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(r)},Rt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},Rt.prototype.translate=function(r,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,r)},Rt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},Rt.prototype.applyMatrix=function(r){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(r)},Object.defineProperties(Rt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(r){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=r}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Zt.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(Zt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Gt.prototype.setLens=function(r,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(r)},Object.defineProperties(Hn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(r){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=r}},shadowCameraLeft:{set:function(r){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=r}},shadowCameraRight:{set:function(r){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=r}},shadowCameraTop:{set:function(r){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=r}},shadowCameraBottom:{set:function(r){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=r}},shadowCameraNear:{set:function(r){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=r}},shadowCameraFar:{set:function(r){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=r}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(r){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=r}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(r){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=r}},shadowMapHeight:{set:function(r){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=r}}}),Object.defineProperties(jt.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===35048},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),jt.prototype.setDynamic=function(r){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(r===!0?35048:35044),this},jt.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},jt.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},It.prototype.addIndex=function(r){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(r)},It.prototype.addAttribute=function(r,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute?r==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(r,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(r,new jt(arguments[1],arguments[2])))},It.prototype.addDrawCall=function(r,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(r,t)},It.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},It.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},It.prototype.removeAttribute=function(r){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(r)},It.prototype.applyMatrix=function(r){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(r)},Object.defineProperties(It.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),fi.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},Object.defineProperties(ue.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new vt}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(r){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=r===1}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(r){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=r}}}),Object.defineProperties(Ve.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(r){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=r}}}),Mt.prototype.clearTarget=function(r,t,e,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(r),this.clear(t,e,n)},Mt.prototype.animate=function(r){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(r)},Mt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},Mt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},Mt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},Mt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},Mt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},Mt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},Mt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},Mt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},Mt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},Mt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},Mt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},Mt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},Mt.prototype.enableScissorTest=function(r){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(r)},Mt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},Mt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},Mt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},Mt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},Mt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},Mt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},Mt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},Mt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},Mt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},Mt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(Mt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(r){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=r}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(r){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=r}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(r){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=r===!0?3001:3e3}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(br.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(ze.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(r){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=r}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(r){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=r}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(r){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=r}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(r){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=r}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(r){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=r}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(r){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=r}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(r){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=r}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(r){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=r}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(r){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=r}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(r){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=r}}}),hi.prototype.updateCubeMap=function(r,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(r,t)},hi.prototype.clear=function(r,t,e,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(r,t,e,n)},We.crossOrigin=void 0,We.loadTexture=function(r,t,e,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const i=new an;i.setCrossOrigin(this.crossOrigin);const A=i.load(r,e,void 0,n);return t&&(A.mapping=t),A},We.loadTextureCube=function(r,t,e,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const i=new Ia;i.setCrossOrigin(this.crossOrigin);const A=i.load(r,e,void 0,n);return t&&(A.mapping=t),A},We.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},We.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"128"}})),typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="128");const ye=new fi,Re=new Gt(75,window.innerWidth/window.innerHeight,.1,1e3),on=new Mt({canvas:document.querySelector("#bg")});on.setPixelRatio(window.devicePixelRatio),on.setSize(window.innerWidth,window.innerHeight),Re.position.setZ(30),Re.position.setX(-3),on.render(ye,Re);const za=new Pa(10,3,16,100),Ua=new Un({color:10202562}),Dn=new Zt(za,Ua);ye.add(Dn);const Dr=new Ur(16777215);Dr.position.set(5,5,5);const Ha=new Hr(16777215);ye.add(Dr,Ha),Array(200).fill().forEach(function(){const r=new Lr(.25,24,24),t=new Un({color:16777215}),e=new Zt(r,t),[n,i,A]=Array(3).fill().map(()=>kr.randFloatSpread(100));e.position.set(n,i,A),ye.add(e)});const Da=new an().load("data:image/jpeg;base64,/9j/4AAQSkZJRgABAQIAHAAcAAD/2wBDAAMCAgICAgMCAgIDAwMDBAYEBAQEBAgGBgUGCQgKCgkICQkKDA8MCgsOCwkJDRENDg8QEBEQCgwSExIQEw8QEBD/2wBDAQMDAwQDBAgEBAgQCwkLEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBD/wAARCAQ4B4ADASIAAhEBAxEB/8QAHgABAAEEAwEBAAAAAAAAAAAAAAYCBQcIAQMECQr/xABJEAEAAgEEAQIEBAQDBAYIBQUAAQIDBAUGEQcSIQgTMUEUIlFhCTJxgRUjQhZSkaEXM2JysdEYJCU0U4KTwTdDVHODVWOSorX/xAAYAQEBAQEBAAAAAAAAAAAAAAAAAQIDBP/EACURAQEBAAICAgIDAAMBAAAAAAABEQIhAzESQQRRE2FxBSKRgf/aAAwDAQACEQMRAD8A+dgDqAAAAAAAlfjDB4x1PNNFh8w63kWk4vNM06nLsNMN9XGSMczijrLE19E36ievf3jr7yisxSJ6x2y2pH8s5YrF5j7eqKzMRP69T1+gOAAAAAAAAAAAAAAAAAAAAAAASu+9+PJ8X4+PU4Hqa82rvc6vJyP/ABbJOK+3/Jmsaf8ACzHoiYvPfcfXqJ7+wIoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACjHnw5bWrizUvak9Witomaz+/wCitKua+S+Tc/2niWy8gw7Tj03Ctmx7Ftn4DQV01raanXVs1omZy5JmO5tPUfXqI7nuKgAAAAAAAALjh4/u+o2DVcnw6T1bbo9Tj0mbN66x6cl47rHp79U/b3iPvH79W5z3Pp9Pf5e/V19u/wBWec52T4WTue5vX39zvPV+v1W/HeEt/klvVzLnedX1dkvudb62e3ADTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATMRHcz1EDmJtWYtT0+qPePVSt47/etomto/aYmJ+8AoxZsWevrw5aZK/TutomP+SpJ/JXkbkvlnmmv55y3HtePc9xjDXLj2zQ00mmrGPFTHWK4699e1ImZmZmZmft1ERgAAAAAAAAAHp2/bN03jVfgdm2nX7lqvRbL8jRaXJqMvor/ADW9GOJt6Y7jueuo7gHmHFL0yVi9LRato7iYnuJhyAAAAAAAAAAAAAAAAAAAAAAAJBwfx9zfyXvGp2DgHGtVvm46Tb9RuufT6fJjpbHpMEV+blmclq16r6q+0T3PcdRKO48lM2OuXHPdb1i1Z/WJBUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlHHPHe98o4fyvm+g3bj+l2/h+PR5Ndh1+51warP+Jyzix102H0zOWfVE9+9ft1Myi6m2LFe9cl8dbWp/LaY7mv9P0BUAAAAAAAAAAAAAAAAAAAAAAlPjXZOB8h5dp9r8lc4z8S2G2n1GTNueHbcmuvXJTFa2LHGLH7/mvFY7/t9ZiUWAU47erHW0zM9xE+9fTP/D36/p2qAAAAAAABfOL8F5rzeu7X4dxXcd6rsO25t33OdHi9f4TR4pj5ma/vHtHqj2ju0+/UT1KxvVod23ja8esxbTvW46Cm46TJoNbXR6zLgrqtNk69eHLFLR8zHbqO627ievoDygAAAAAAAAAAAJP483Hxttm963P5U4nvPIdpy7Tq8Gk021bh+DzYdxtFfw+e1/VX1Y6dX7r3Pfqj2nrpGA9jikWilYvMTaIjuY+8uQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASDx/ruC7ZzbZ9w8ncd3PfuKYM97brtu2av8LqdTj+VeKVpl9VfT1knHafzR7VmPv0j4Du1ltHfW6m+3afLp9HbNktpsOXL8y+LDNp9FLX/wBVor1E2+8x26QAAAAAAAAAABJeQbf440vEOL6zi/Kt73Hk+rrrJ5Jt+q22MOk0Fq5YjTRp8v1yerH3Nv5vePrT+WY0AAAAAAAAAAAAAAAAAAAAADOvwi/FVunwm803zlm3cH2/k1N+2yu35sOp1VtNkwzS83pbHkil/abWmL1694is9x174KD2PfyDetTyXkO78m1un0+n1G9bjqtyzYdPExixXz5rZbUpE/6Ym8xH7RDwAAAAAAAAAAAAAAAAAAAAAAADv0mt1235rajbtdqdJlvivgtk0+a2K1sV46vSZrMTNbR7TX6T93REREdRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7tPotdrK6i+i2/V6qukwW1Wptg098sYMFevVlyTWJ9FI7ju1uojv3kHSAAAAAAAAAAAAv/A+Ac28ocq0fCPHnGddv++6/1Tg0WkrHqmtf5r2taYrSle47vaYrHcR33MRNgbS/w7PiG8e/Dv5t3DePJvzNLs/Idona67pTDfN+AzfOpes2pSJt6L9TFrf6fRXv27L6GGfL/gXzB4F3TR7T5a4LruP5Nypa+iy5MmLNg1MV/mimXFe9fVH3rMxbr36690AfQv8Aic/Ft4V808P4r408Ub5pOVZtFusb3rN201LzptLSuDLiripknr1ZLTl94iJitaT31M1fPRJdABQAAAAAAEk8dbh472vmW367yrxfeOQ8YxfN/G7ftOvjR6nLM4rxjmuT29oyTS0x6q9xE+8/yzHJmkzM48VsdZ/lpbJ65rH6TbqPV1+vUd/oDgAAAASnBuPjGPGeq2nU8R3u3P7bxTPpd7ruXW30235VYtgtp+/fJN/VMW6+8T6v9KLAAAAAAuXGuNci5lyHbeJcR2PWbxvW76iNLodBo8fry58sxM9RH0iIiJmZmYiIiZmYiJkFtF45fw3lvj/kmu4fznjmu2Le9tyfK1eh1lIrkxzMRMT7TNbRMTExaszExP1WcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGe+b/B5zXg3wv8AF/ik1vMdi1e0cl/B3/wjDS9dTpsWqtMYZ+ZM+nJb+X10iK+nu3vPp98CPbn3zftVtGl49qt/3TPtGhyzn0m3ZddlvpNPkmJib48M2+XS0xa0d1rE+8/rLxE37AAAAAAAAAAAABfNm4LzTkXHd+5dsHFtx3DZeL0wZN612nxerFoaZrzTHbJ799Tas9zET6Yju3Ue6xvXpN23fQaPX7doN31+l0e6Ux49fp8GqyY8Wrpjv66Vy0rMVyRW3vEWiepmevrIPIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACUbn425PtHjfj/lfWZNqnYeS6/WbboaYtdW+sjLprTXJOXBEd0p3Werdz37e0dwCLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJH494jo+dcu0XF9fzLYuLYNXGa1tz3rPOHS4fRitfq1oj6z6eo76+v1+0xwcvyOHk8ni5cPFy+PKyycsly/Vy9XPeXqrLJdqvLjjDlvijPhzei01+Zhv68d+p/mrbqO6z9YnqO4UA6xAAAAAAAAAAAAAAAAHFrVpHqvaKx3EdzPXvPtBS9clYvS0WraO4mJ7iYX7gfNN78cc12Tn/Go0c7rx/VxrdHGs00ajB8yK2rHrxz7Wjq0z9vfqfst+97vruQ73uXId0vjtrd21ufX6m2LFXHSc2bJbJf00rERWPVaeoj6QDxAAAADY/hvlz4Zto+DflHivfvEVdZ5X3LUZ50nILaDDe3qtm9WnzxqZt8ykYMduvR1Hc1mI7izXAl0AAAAAAAAT3xfxjxxyHBvWTnvLP8ACL6XBWdHT51cUWmYt3fu0fnmJ9MemP19++4QOYrEzFb+qIn2t6eu4/Xr7OB5fD+Nz8Xn8nm5eS8pyzONzOOTOut793Xt8/5fj8343i8HHxcePLh8t5Tflz27Pltz/r6mQAep4gABIeJ+Q+dcE0nINBwzlOs2fT8q2vJs28009cc/jNHf+bFabVma/f8ANXq0dz1KPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACXeKPKvNfCnP8AafJfj7XafS71s+S18P4nD87BlrelqXx5KdxNq2raY9pifpMTHSIgJt5k8xc588+Qtx8m+RNVo8287lXFitXRaecGnw4sdIpTHjpNrTEREd+9rT3aff7RCQAAAAAAAAAAAAAAAAAU2y4q5K4rZaRe/wDLWbR3P9IVJTsXkbfeO8D5V470G18fy7dy6+gvrdVq9srm12CdLmnJSNPmmf8ALiZmYn8sz79xMT7giwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2p/hy+AfG3xAec9dtPlLBTcNp4/s87ri2e+S1Kbjn+dSkev0zE2x44mZtSfa3rr37RMTnD+J58J/gzxBwPjXkzxbxjbeJbhqd3rs+q2/Q2nFp9bitgy5IvXD6vTGSs447tWO5rM9/SOpveD5zAKAAAAAAAAAAAAL7q+B840HDtH5D1/Dd70vF9w1P4TSbxn0GXHo9Rl67iKZbRFbRP2tE+mZiYiZn2WJmnlHxbeV+W/DnsHwxbnTZK8U2H8PWufFo711moxae8X0+O9/X6OqzETMxTu3UfT37wsTfsAAAAFFcGGuWc1cNIyWjqbxWPVMf1/srAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASTdeS8Y1/AuPcW0XjzQbdvu0arW5tfyTFrcts+64s14tixZcMx6K/Kj8sTEzPUe3XqmARsAAAAAAAAAAAAAAAAAAAAAAAAAAAAXfifEOVc83/AEvFeF8e1+97vrfX8jRaHBOXLk9NJvaYiPtFazMzP6LVkx5cN7Ys2LJiyUma3pkpNL0tH1i1Z94mPvE+8ApAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAenb9s3TeNV+B2badfuWq9FsvyNFpcmoy+iv81vRjibemO47nrqO4eZm34UPin5B8J/NN65fsPC9q5LG+7bXbs+m1uovp7Y/Rk9dL48ta26jubRas1/N+X3j0+6jCNL0yVi9LRato7iYnuJhyuPJN91XKeS7zyrXabTafU75uer3TNh01ZrhxX1Ga+W1KRP0rWbzEftELcAAAAAAAAAJB4/4FyzylzbZvHnBdqnct+37UTptFpvm1xxa0Ute1rXtMRWtaUvaZn7VnqJnqJ93lXxRzvwpzjX+OvI+z127fNujHbLjx5q5seTHesWpkx3r7WrMT7T7T7T7AiIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANi+Bbx8G2n+EPmG1c42fW5/N2fLq/8H1EaXVTamSZj8HOLNSPk1wxEROStp959XcT3HeugEmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC88P5lyzx7yXQ8y4LyLW7Fvm22m2l1+jvFcuPuOrR7xMWrMfWtomJ+8L95S83+XfN2v0e5eWvIO68nzbdWaaONV8vHi08T9ZpixVpji0/e3p9U/TtCAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKt72Hgei8f8X37Zed5dx5RueXXV3vZJ23JipttMeWK6e1c9vy39dPeYjv8AafZFT2AAAAAAAAAJTwLhW181yb3i3PyNxbiU7Rs2p3TTzvuqnDG45cUR6dJgmI98l+/b9OvaLfYIsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC4bDyDf+Lbrh33jG+7js+5aaLxh1m36rJp8+OL0mlvTfHMWjutrR9fu8FrXvab5Ml8l7T3a97Ta1p+8zM+8z+8uAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGT/AIdPh75r8TPkvT+NeE6rRaHL+Fya/XbhrYtbDo9LjtStrzWv5r2m2SkRWJjuZ+sdHoYwGznxZ/AX5A+FLZNq5druYbdyzj256qNBk1el0N9Hl0mpmtr1rfHa+SJpatJ6tFvr7de/bWMl0AAAAAAAAAAAAAAX3g3OeXeNOW7Zzvgm+59n33Z8s5tHrMNa2tjmaWpaJreJraJra1ZiYmOpd/kXyLzTyxzPc/IHkHf8+8b5u2St9Rqcta0iIrWK0pSlIitKVrWIiIj957mZmY2AAAAAAAAAAAAAA92ybHvPJt50PHeO7Zn3HdNz1GPSaPSYIicmbNe0VrWO5iPeZj3mYiPrMxDPPnx8fG8+dyTu29ST909vCPbvOzbvx3d9bsG/7bn2/ctt1GTSavS569ZMOalpres9e3tMT7xMxP1iZj3eI4c+Pk4znwuy9yz1T0ANAAAAAAAAA2Evwz4Ra/B3XmMc912Tzf8A4j6J2mmrvFopOs9HonSz+T5MaeYtOX6zMdxPf5WvYWaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAl3iLjXDOZeU+K8T8i8ttxfjG77lTS7pvFbUrOjwzW0xaLZItSnd4pT1WiYj19ymHxXeNfFfiXzXuXCvDfPP9rOOYdFptTGqnPjzzptRk9fr005ccRTJ6axjv3Edx8zqfob3gxCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATMRHcyL1wvk+ThXMNl5hh2Xad3ybLrcWupod2034jR6i1J7iuXH3Hqr37/X6xE+/XQLLE9+8D3b9u+bkO/bnyDUaHb9Fl3TW6jXX0236f5GmwzlyWvNMWPufRSvq6iO59o+rwgAAAAAAAAMx/Cn8Sm+/C15Ww+Q9s2am86DU6W+27tts5YxWz6W96Wmcd5iYrlrbHWa9+0+8T133GHAvY3B+NX+IJq/il4ztnj3iXCdVxnjOl1tdx11tw1GPLq9bmpW1cdOsfdKY6+v1d+qZmYj6RHvp8BJgAAAACTbv425vsHB+P+R942G+m47yjNqsG1ayc+K34i2nvFMv5K3m9ff6eqsd9f07jIAAAADb3wT/AAzfM3nLxVpPK2Dluw8b0u8YfxWy6DX4MuXNrdPMd0y3tSYjDW/1r7WnqYmYjvqNQn0P+Gz+KhxvxD4S4/4v554u37dNy4pt9Nr2/WbRn0/yNVpsVfTh+bGW9LY7xWK1t6YvE9dx9eonLfoaD8u4nyLgfKd24Ty7bZ2/e9j1eTQ6/SzeL/KzUnqY7j2mJjqYn7xMT91oSvyt5G3ny/5L5N5R5DpcGl3Hk+45NfmwYJmceGJiK0x1mept6aVpX1dR36e+o76RRYAAAOzBgz6rNXTaXBkzZr9+jHjpN726rNp6iPeeqxMz+0TP2B1jitq3rF6Wi1bR3ExPcTDkAAAmYiO5kbPfw4fH3jbyV8Ue2bH5O0Wi3DRaPaNZuW3bfrOpxarcMV8MY4tSfbJ6aXy3ik/etZ6n0+y3Bq/jy4s1PmYclb1n/VWe4VPqn/Fb8NeDuOeGtq57tHGNh49zPFvGl0G332/S4tNl3DT2i3zsN60iPXSlPVkjv+WaR+vU/KxJdABQdmm1Oq0WoxazQ6vPpdRgvXLiz4MtseTHes9xat6zE1mJjuJie3WFksyivNmzajNl1Opz5c+bPktly5ct5vfJe0zNrWtPc2tMzMzMz3MzMqAJM6gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdUn2yUven+qtMny7Wj7xFup9M/v1PX6Sk3kndPHu9c03Hc/FnD9w4xxnPOKdHtmv3G2tzYpjFSMk2yWmZ/Nki8xHcxET/aIyAAAAAAAAAAAAAAAAAAAAAAABMxEdzK78k4hyvhufRaXlvG9y2bNuWgw7po6a7TXw2z6TNEzjy1i0R3W3U/v7e/QLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAu/D9o2rkPL9h4/v2/wCLY9s3TdNJodbueWvddFgy5qUyZp79vy1tNvf29vf27WgBnb4wfA3jT4fPIu28S8Y+U55rodbtOPXam+XNp8ubR5pvaPTa2CIp6bVitqx13Hv3M+zBKnHixYafLw460rH+msdQqIAAAAAAAOzT6fUavUYdHo9Nm1Oo1GSmHDhwY7ZMmXJaYrWlKViZtaZmIiIiZmZiIB1ivNhz6bPl0uq0+XBnwZLYc2HNjmmTFkrM1tS1bRE1tExMTEx3ExMSoAAAAAAAAAAAAAAASTQco47pPHO88L1PjjadZvu5bpptfo+V5NReNbt2DHWsX0mPH1NbY7+m3c+qOvXPtPUI2AAAAAAAAAAAAAAAAAAAAAAAAAAAAArtly3w4tPbJacWCbzipMz6cc3mJv6Y+keqYiZ6+sxHagAAAAAAAAAAAEl8eeSOa+KOUYuZ+P8AfLbTvGHBn01NTXBizTGPNjml49OWtq+8T9eu+4hGgHFYtFYi17XmI97WnubT+s/u5AAAB3aLW63bdbg3LbNdqdFrNLkjLp9Tpc1sObDePpal6TFq2/eJiXSAvvMOd838hbji3bnnMd85HrNPj+TgzbruGbVWw06iJrT5lp9ET6Y79PXcx3PcrEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC+8D4zpOac547w/X8g02x6bfN20m3Zty1Md49JjzZq47ZJ+3cRaZjv2767mI7lYnFq1vWaXrFq2jqYmO4mAZ1+ML4deMfDR5Q0vBuJ+RY5botXtOHcZyZZw/idNe98lZpkjF+XqYpFqz1E9TP16YLUYsGHBWaYMNMdZnuYpWIjv8AsrIAAAAAAAAExEx1MPfvG/7/AMizabUch33ct1y6LR4dv019dq8monDpsXfy8NJvM+mlfVPVY9veXgAAAAAAAAAAAAAAAAAAAB26XS6nXarBodFgvn1Oqy0wYcVP5smS9orWsd+3vMxHv7Lvy/hXJuB7t/gvKdrvotTbFXNTu1b0yUnv3raszE+8TEx9Y6/p31nh8nLx3yzjfjMludS31t/tw5fk+Dh5uP4/LnJz5S2cdm2TNsnuybNWMBydwAAAAAAAEm3TavHmDx9x/eNo5jues5jrNXrMe9bJl22cWl0GnpfrT5Meo+mWb1mJmImeu59q9TCMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ74j8D+XPO+t3bQeJuE6rkOXYtLXV7h8nPhxRgpeL/AC4mct6+q15xXrWte57j36j3QXNhz6bNk02qwZMGbDe2PLiyV9N8d6z1ato+0xMTEx+sAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAe/Yd+3vi296DkvGt11O2brtWpx6zRazTW9OTBmx2i1L1n6e0xHtMTE/SYmJmHgAe7fd93rk+9a/knI901G5brumpy6zW6zUW7yZ82S02ve3XUe8zPtEREfSIiPZ4QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABctRxvkWk47oeX6rYNyw7FueqzaLRbnk0mSul1GoxRE5MdMsx6bWr37xE/a3+7boLaAAAAAAAAAAAAAAAAAAAAAAAAAAAAkvj3xxzPypv+fjHBNn/wAT3LTbbq92yYZ1OLB1ptPSLZLerLatZn3rERE9zNo+3cxGj79/f02r3/2bVmto/pNZmJ/WJmAU4slM2OmbHPdb1i1Z/aVREREdRAAAAAAAAAAknEeVbFxrbOVaHePHeycm1HINmybXt+r3G9oybHntPtrNPERMTljv276+ke8e/cbAAAAAAAAAAAAAAAAAAAAAXrh3C+YeQ+R6TiHA+MbjyDe9dM/I0Ogw/MyWiJiJtP0ilI7ju1pisdx3PvC5eSfE3k7w7vWHjvlPgu68Y3DVYZz6fFrsdfTnxxMRNseSk2pfqZiJ9NpmO47iO472P/hnedvFvgvzVvup8qblpNm0fJtnx7fo951VOsOjzY83r9GTJ1/lUyRb+aeq944iZ94ZR/in/Ev4R8vbBwrx94v5XtvLNy2rdcm8azc9ryV1Gl0uD8PkxRg+fXutr3tkrb01meox9267r3nbuD55gNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACU+NeEabyJy7T8W1fNuOcTw5tPqM9tz3/V/h9JT5WK2T0Tbqe7W9PUR/Wft1IRYU47xkx1vFq2i0RPdZ7if6TMR7f2VAAAAAAA7tFrdZtus0+47fqb6fVaXLTPgy0/mx5KzFq2jv29piPr7fqvHMub8m59u8b1yncp1eppirgx9UrSmOkTM9RWsRH1mZmfr/wAlhHWeby8fHfDOV+Nu2b1bPWxw5fi+Dn5uP5PLhL5OMsnLJsl9yX3Jc7AHJ3AAAAAAAAAAAAAAAAEk5LxrjOzcZ4lveyeQdFvu4b9o9Tn3basOhy4Mux5seWKVw5b3ma5ZvWZtFqxEdV7juJiUbAAAAAAAAAAAAAAAAAAAAAZH8NfER5h8AZd8zeJ+Y5dktyHSV0utiNPiz1n0TaceWtctbRXJT136tH+9PcT7dY81Go1Or1GXWazUZNRqNRktmzZsk92yZLTM2vaf1mZmZ/eXWAAAAAAAAAAAJN451vjXb+UxqvLXHN+3zj0aLVU/B7Lra6XUfi5p/kXm9pr3Stu/VHcfWPr10jICjBGWuHHXPaLZIrEXmPpNuveVYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD37Bj2HLv22Y+U6nX6fZba3BG5ZdvpS+pppfmV+bbFW/5ZvFPV1337/afo9fNcXDsPMd7w+PNZuur4vj12Wu0ajdMVcWry6Xv8lslK+0T+n0nrruInuICygAAAAAAAA2L2fxL8Meb4NNx8sbx5fvi8r4twvg0/H8Wsw+qLfifl4tPOlmvzJrfDWcs5Yn2iZnv0x0W4NdAAAAAAAAAevZ9Tt2h3rbNdvG2f4lt2l12m1Gt0Pqiv4vT0y1tlw9z7R66Ravv7fm9weLHkx5a+rFkrevfXdZ7jtU2C+Mvzt4d8+cy41v3h3xZl4Xpdp2i2i18ZdHptPfWZLXrbHE1097VmMURasWn3/Pb7NfSAAAAAuep5PyTW8b2/h2r5BuObYdp1ObWaHbL6q9tLp8+b/rMlMUz6Ytbue567/Nb9Z7tgAAAAAAAAAAADKHwz8H8U+R/NGxcQ81c6vxLimsrlnNrq5seD5uorETi085ckTXFGSfVHq679oiJiZiT0MXid+dOO+NuI+X+Vca8Qctnk3DtBra02rdPm0zRnx2xUvaK5afly1pe16ReIjv0fefeYIAAAAAAAAAAAAAAAAAAAAAAAAAOYracd80Vn5eKaVvbr2rN5mKxM/buYnr9epcAAAAAAAAA69Rm/D6fLn9Pq+XS1+u+u+o7fU3if8ACA4Hr/Fely8i8ncipzbXaLHqrajSxp/wGmz2pFvlVxTjm18cTPUzN/VP1iYfLTJjpmx2xZI7pes1tH6xP1bhcY/ijfEpxfxVi8dYKce125aTSxotJyPWabJfWY8UR1E2pF4x5MkV6iLzEe8RM1lLv0NSt32jcOP7zuPHd3jFGv2jW6jbtX8qZmnz8OS2PJ6Zn3mvqpPUz9unkdmp1Oq1uqz67XanLqdVqst8+oz5bd3y5b2m172n72taZmZ/WZdagAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD16vaN42/RbfuW4bPr9Jo92x5M236nUaXJjxazHS3pvbDe0RXJFbdRM1mYjuP1h5F93jnfNuQ8b2Lh2/cr3LcNj4vTNj2bb9Rm9WHQ0y3i2SuOPr1MxHXcz6YjqvUeyxAAAAAAAAAAAAAAAuG1ce5Hv+LXZ+P8a3ndsW2Yoz66+37dm1VdJjnvq+WcdbRjrPpt1Nuo/LP6St8TFoi1ZiYn3iY+7Pvw2/GRzv4Y+H824dxPiex7xh5lWMnz9wvet9FqIwzi9fVY6zU9M1n5czX3rP5vze2v8AgxRgwY8FZmYx0ikTP36jo7FYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJNtXkjmGy+POQ+LNu3OmLjfKdZotfuelnTYrWyZtLb1YpjJNZvWO4r3ET1+WPp3PcZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASTU8a4zh8caDmODyDos/INTvWbbdTxeNDlrqNLpa4vXTWTnmfRelp6r1Ee02677rMI2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7K6bVX2/Pu9NJqLbfpckYc+srhtOnw5J66pfL16K2nuPyzMT7w8ut+Z+Dz/ACfV8z5VvT6fr31PXX7v0E+N9f8AD3T4ctntsWq4v/0b02HFFovbDGk/Dxi/PGSJ9vV7T6u/f1d/dLcH5/B7N5vsmXetyy8Ypemy312ovtdbxPqro5y2nBE9+/cY/RE9+/bxqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlXBOL8P5Lp+S5eW+R9LxS+z7JqNx2zFm27Lqp3bV06imkpNJj5drTaJ7nvuO+o9pRUAAAXbiNOLZOW7Hj5zn1mHjdtz0sbxk0dZtnrofnV+fNIj83q+X6+vT+b9ImeoZi+MXavhb2nyHtOD4U9yz6vYrbTW26xOfU5sFNV6vyfLvqO7Taad+uO+omI+kzJowOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJJ4+2jgm9cgzaPyNzDWca2mm3arUY9ZpNBbV5MmrpWJw4PRWJ6i8+ruf2iO4mYRnFOS2KlstYreaxNqx9p+8OXHzceXk5eKS7xkvqyd76uZb13JbnW5sXOtVAOqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJRwrD40y6LlF/Ier5Lh1eLZM9+N02euCcebdPpjpqrZYma4veJ7pH2t3P07i4AAAAAAAAAAAAAAAAAAAAAD1bXt2o3jddBs2kyafHqNx1eDRYb6nNGHDXJlyVpWcl59qUibR3afpHcrpz3hO+eNua7zwHk2Tb77rsWq/Caq+36yuq09r+mtommWvXqjq0fWImJ7iY9gWEAAAAAAAAAAAAAAAAAAO4iYiZjufoAAAAAAANwP4dfwi+P8A4neTcp3Tyjqddm2PiuHSRTbNFq7aa2rz55y++TJjmMkUrGL2isx3Nvr7NP2QfCXnryn8PHLr808Vchpt2t1GH8NrNPqMEZ9LrcXvNaZsczHq9MzM1mJiYmZ6nqZiZfQ2J/iK/B349+GTdOK8h8WZ9dp9j5N+J0+bbNbrbaq2n1GGKWi+K+SZyTS1b27i0z1MR11201ZD83ef/K/xFcp0/LvLHJI3LVaHBbTaHTafBGn0mjx2mJvGLFHfU2mtZtaZmZ9Me/URDHhOgAUAAAAAAAACtYrhvp6xEYst4y3xx/La8fS0x9Jn9wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABzE0ie8mnx6isfzYskzFckf7szHvET9Pb3B1482HN6vlZaX9M9W9Nonqf0lW2P+Ln4kfDnnzbuEaLxb4Rjg+XjWiyafWZ74NLhnJWa44pgxxgmfVjr6JmLXmJ949vq1wJ2AAAAC9ajhPMdJwzQ+RtXxnXYeLbpuGXadFu961jT6jWY62tfFX39XcRS/v11+WfdZXptue6ZNsw7Hk3bXX2zT6i+rw6C2qyTpsWe8dWy0wzPoreY9ptERM9z7+4PMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACceC+Ica8geaeDcF5nr7aLYt/wB+0m36/PXN8m0Ysl+vRF/9M3t6ccTHv3f2mJ6kEHH2d+L74PPhf2n4YeYbptfjfjXEdZxHYtTuG07vt+ipp8+HUYcc2x1vekerLF7RWtq29U29X6vjEkugAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACSca2rgGv4xyzXcq5pr9n37btNpMnG9vwbVfU4d1zWy2jPjy5a+2GK0isxaZj3t3+bqYRsAAAAAAAAAAAAAAAAAAAAAAHFq1vWaXrFq2jqYmO4mCtKUj00rFY7meojr6+8uQAAAAAAAEoxcq4rXxnqOFZvGe1ZOQ5N5puODlsazNXWYtLGL0W0c4vel8c2j1fWIiZmfT6o9UhFwAAAAAAAAAbJeFPNnw28J+GjyR438ieE43/nHIJyW2zda4cV5zTbFFdP3ntMZNN8jJWb/k7779Ve7TMNbQMwAAAAAAAAAAAAAAAAAAAAAABfeCcI5L5L5rsnj3huhprN85DrK6HQ4b5Yx0tkmJmZtefata1ra0z7z1Weomeom+eafCvkH4f+fajxt5M27S6XeMGmw62ltJqYz6fPp8vqimTHfqJmPVS9Zi1azE0n266mQgwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQch8f8ANeJcf4zyvknHNRoNo5jpM2u2PV5MmO1NbgxXil7VitptXqbV9rxWZi0dR9eo+7L6jUZcODTZdRlvh0sXrp8drzNcMXt6rxSJ9qxa35p667n3n3B1gAAAAAC4ce3HQbRvmi3Tddjwbzo9Nkm+bQZ7zTHqK+mY9NpiJ66mYn6T9Hk1OXHn1ObPh01NNjy5b3phpaZrirNpmKRM+8xET13+zfxnx+W9767/AK7/AF3/ALvX+Oc58v5Lw+NzJd6zdvWbuzJfWd9XdzqAYdAAAAAAAAAAAAAAAAAG4H8MfwZ4p83eaN/p5W2rSb3p+NbPj1u37LrfzabV5smWaXyZMc+2WMdax1S0TXvL3MdxHS3Bp+Pof/FW+Hbwn4o2PhPOvGnE9q4tu+77tn23W6Da8FdPg1mCcFsvz7Yq9Vi9L4619URHcZZ779uvngkugAoAAAAAAAAAAAAAAAAAAJPzDhu18V2riu5bd5C47yXJyTaKbpqtJtOWb5dmyzPU6TVRPvXLH9I+lvb294wAAAAAAAAzD8Juu+Hvb/NOj1PxObbbW8K/w7V1rS2LNlwV10zj+TbNjw/mtT0RmjrqY9U0mY+kwvQw8JP5Q1Pj/V+SOT6nxTpNZpeG5N11FtjxauLRlrpPXPo7i8zaI+vpi35or6YmInuEYAAAAAAAAAAAAAAAAAABkvfvhw8ycZ8L7N8QO9cTjBwjfsmKmk1sarHbLFcszGHJkxd+qlMk9RWfefzR3EdsaMhb38QHmLkXiTZ/Be8851ep4RsV6W0m1Ww4eojHPeKtsno+ZauOf5Ym3t7d99R1j0m/YAAAAAAOYm1bVvS9qXpaL0vS01tW0T3FomPeJiYiYmPeJhwAnfL/ADx5r8gcV0vBuceVeT79x/RXx3w7fr9ffLj9VP5JvM/myzExEx8ybdTETHU+6CAAAAAAAAAAAAAAAAAAAAAAkvjfg2o8lc42ng+l5FsOxZd1yZKRr971v4XSYfRivkn15Op95inUR17zMI0ArzYvkZsmH5+DN8u01+bgyevFfqevVS3Ueqs/WJ694UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJTk8Z8uxeMcPl/Lg0FONajep2DFknX4vxN9XGG2WesHfr9EVrMerrvv7dfmRYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ2+Ff4O/JXxY7pu2PiO57fsey7D6Ka/eNwxXy44z3r6qYMeOkxN79dWn3iKxMfXvpZ/ia+GHyF8LHNtHw/nWo0G4YN10ttZte6aCbRg1eOkxXLHot+bHelrV7rPcdXrMTPcxDfoYhAAAAAAABcOP8AIN94nv238p4vu+q2reNp1NNXoddpb+jLp81Z7ras/wDKYnuJiZiYmJmFz8geRud+VuUZ+a+SOU6zkO+6nFjw5Ndq4pF5x079FIrSta1rHc9RERHvP6yjgAAAAAAAAAAAAAAAAAAAAAKM+O2XDkxVyTS16zWLR9azMfVLvJnNdn5/yTBv2xeOuO8J02Ha9Lt9tt2LFOPT5cmGLRbU2jqO8mT1R6vb/TX3n6gigAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC78S5fyrgPItHy/hHIdfse97fNp0uv0OWceXF6o6tET9JiY+tZiYn27haAEo8g+UPI/lneMPIfJvNt35NuOnw/h8Oo3DP65xY++5rSsRFaRM9d+mI76jvvqEXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFHyMHzfnfJx/Mn39fpj1fTr6/09lYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2v8AgS+NvQ/CdquRbByziOu3vjPJs+HWXvtt6Rq9JqqV+X6orktWl8dqenuPVExNI69XftHPja+LvP8AFrzzZ902zjOo2DjPGdJm0216XV5K31ebJntS2bNm9EzSv/VY61rWbdREzM/m6jXMTO9ABQAAAAAABJuG+NuaeQNFyTcOJbP+N0/Etnzb7u+SdRixRp9Hi69V/wDMtX1T7z7R3PtP7dhGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJtr4rx3X+POQcy1nkbadu3raNdo9JoeMZtPe2s3XFmmIyZ8V4t1WuOJmZ7rP8s9zHcIyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACjPljDhyZp66x1m3v8AT2j+6X+UPH2bxfzDLw7PyvjnIsmHSaXVX1uwa78VpYnNii84vX6a/nr31MdfSaz9+oiYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArxZs2CMsYct8cZ8VsGX02mPmYrdeqluvrWeo7ifaeoUAAAAAAAAJRot28e4vGO67DruHbhm5vn3vBrNv36m4WrpsG3VxRXJpr6fvq1pv6rRaI/wBUTM/liJCLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACW/wCzfA58VRy2PIUxzCN8nQW4zO25OvwPyfVGpjUd+n+f2/T7fX3RIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG9vwkfwzNJ8QHiPT+WOe+SN04/i3vJmjaNDtWmwZLVxY8t8c5c18nq9XqmncUrFZrH1mZn21X+IPwpv3w9eXd/wDFG/6zHrr7TlpfSa6lPRXWaXLSL4svp7n0z1b0zHf81bde3TN/wx/xGvJfw1eOf+jDDwjaeW7RpdRn1G2W1muyaXNo/m3nJfHNq0vGSnrtaYjqsx312158s+UuX+avIu9+TudazHn3ffM8ZclcNZrhwY60rTHhxVmZmtK0rWPr7z3P1mWZuiIgNAAAAAAAAAAAAAAAAAAAAAAAAAlW6+MuV7L43495X3D/AAuNg5PrtXt+3Ri19MmrnLprTXJOTBHvjp3WYiZn9O4juEVUxixVvOSuOsXnvu0R7z9Pv/aP+EAqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlTnfwwea/GninjPmjmXFsOk4vyyMM6HLj1dcmfFGbHbJi+fi6icXqpXuPefrET1LFadco87eZObcD2Txfy3yPu26cU45GKu2bVmjFXFgjHjnHj7tSkXyemkzEfMtbr6/X3QUm/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlXjPxly7y9y7Dwfg2m0eo3fPptRq8ePVazHpqWx4cc3vEXvMR6uo9q/WZ/buYilZmaxMx13HfXcT1/ePaf7OZiJmJmI7jvqf07iYn/lMx/dxWtaVilKxWtY6iIjqIgHIAAAALzw3ddh2Lluzb1ynjFOR7Podbh1Gu2m+qvp663DW0TbFOSkTNYmP29/pPtMgsw92+67b9033c9z2jY8ezaDWa3PqNJt2PUXz00eG+S1seGMl4i14pWYr3MR319IeEAAAAAAAAAAAAAAAAAAAABxN6RMxN691iJmO/pEz1H/Gfb+rlKdl8mcx4/wCPuS+L9q3LFh4/yzU6PVbng/DYpyXyaa8Xx+nLNfXWJmtYmsT1MR9I7nsIsAAAAAAAAAAAAAAAANiN31/wbR8G+26HZtq3evnW2txTq8uT8VP+ZXPWM9/XPenjTWwWmaU9pm32i8T1ruS6AAAAAAAADi9646WyXtFa1iZmZ+0Q5U5sVc+K+G/fpyVms9fpMdAmnPPDPlnxdtOw795G8e7xx3b+T4Zz7TqNbjrFdTWKxbrqtpnHf02i3ovFbddz17T1DWWvNfxT+ZviD4/xji/k3etv1e38SpMaGuk0MYL5ck0jH87Pb1T68nojr8vpr+a0+nv6YlJv2AAAAAAAAAAAAA68ep0+W9sWLUY73r/NWt4mY/rDsAAAAAAAAAAAAAAAAAAAAAAAHHqrFvT6o7n7d+7lTQBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZC8K+AfLfxDck1HGPE3E77tqNFijNrdTlzVwaTR0t36Jy5be0TaazEREWtPX067lj1vH/DT+LzxX8PH+1vBfK1s206Lkmsw7npN7x6fJnpXLTFGO2ny1x1m1Y6rFq36mO7WievbuXoaneWPD/kfwfy7JwfyhxjUbLutMUZ8db2rkxajDM9RkxZKTNb17iY9p7iY94hDW2/8AEe+Jvxx8SXkvjU+MLanWbTxDQavR33PNpb4I1mbPkx2tGOt4i80pGGOrTWImbz13DUgnoAFAAAAAAAAAAAAAAAAAAASDx/ybaeGc22fle/cI2nmO37Znvl1GxbtMxpNdE4r0iuXqtvatrVvHtPvSP6rLrM+LU63U6rBosGjxZ82TLj02CJjFgra0zGOnfc+msTFY79+ogHSAAAAAAAAAAAAAAAAAAAAAAAAzf4w+Cr4mfMXB7+RuB+Ncuq2GcVs2jz6nW4NNfca1m0T+Gx3tFr+9fabemtu4mtphhB9YvhY/iP8Aw3cN+HbivD/IO6bjx3feF7Lpdnz7fj2vU6qNV8ilcVcmC+Olq2i8RFurWi1ff1fTtLbPQ+Ues0es23W6nbNy0mXS6zRZ8mm1Onyx1fDmx2ml8do+1q2rMT+8OlNPNfkPTeW/L3MfJ2i2a+06bk28Z9wwaK9om2DFaeqRb09x65iItaImY9VrdTP1QtQAAABI/H3jjnvljlODhPjXimt5FvuoxZNRTRaSaVt8rH1672tktWlax6q+82j6wte/7BvnFN93Di/J9o1W1bxtOpvpNdotVT05dPmpPVqWj/nEx3ExMTEzExKUeG/M3kLwHzvB5G8Y7rp9DvWHTZtFadTpq6jDm0+X0+vHek9dx3SlomJiYmke/XcTYua8y5H5D5fvHO+X7h+O3vftZfXa7UeitPmZbfpWsRERERFYj7RWDvRZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASTiOm8c6nbeVW55unI9HuGHZMuXjNdpw4b4dRukTHoxauckTNcUxP1p1Ptb3ifT2EbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT3wFx/hvK/OXAONeQ9Vj0/Gdy5Do9Pulsk9Uvhm/cYr9/6cl4pjt/2ck/1QJxelclZpesWraOpiY7iYKPtx8cXhTwHo/hI5nl13COObLXjWzZdVx7UaLRYtPk0uupTrTVwzT0zM2t6aejvq0WmJiYl8SF83vnnO+T7Vo9h5Nzrkm8bZt0VjSaLcd31Gp0+D0z+WaY8l5rWY79piO4j2j2WNJMABQAAAAAAAAAAAAAAAAAAABdNPyPctNxzWcVxxpp0Ou1OPV5ZtgrOWMlIiI9N/rEe0dx/wCcrWDHDx8PHbeEzbt/u+t/8kdPJ5fJ5ZxnO2/GZP6m25P623/0AbcwAAAAAAAAAAAAAAAAAAAAAAAAEh3Tx5zrY+G7H5D3ji2r0fGuS5tTp9p3LJfFOPV5MFvTlrWtbzevU9/zVjuI7jsEeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABctXk45bZNvx6DTbjXd63yzr8uW9Pw96zP+XGOI94mI+vfX3Y5c/jZMt25/nVu3+us/2x04cPnOV2TJvf33Jk/vvfrqVbQG3MAAABRmy1wYb57xM1x1m09fXqI7SryJ435T4s33Scc5d/hc6zW7VpN5wzt2vpq8U6fU1mcfd6e0X/ACz3X7e3vMT2jCjFhw4K+nDipjiffqtYiP8AkCsAAAAAAAAAAAAAAAAAAAAHu0Gw8g3XQbhuu08e3bX6Hacfzdw1ek0GbNg0VOu/VmyUrNcUde/dpj29weEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZj8e/CX5o8oeHeS+dOJbdtGTjHFo1M6mNTr5x6vURp8UZM04MUUtW3prP8AqvTufp+rDhoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAO2+p1WTTYdFk1ee+m01sl8GC2W04sVskxN7UpM+ms2mI9UxEd9R3306gAAAAAAAAAAAAAAAAAAAAAAAAASblO4+ONZxnh+j4ZxPd9r3/Q6HPj5VrtZr5z4Nz1c5Kziy6fHNp+TWtIvE16r/NHtPXaMgAAAAAAAAAAA4vNq0talfVaImYjvruf0ByJLz7jPGOK7rtui4l5E0XMtJrdl0e5Z9Zpdvy6ONJqssWnJo7UyWmZvj9Ne59v5uuomEaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZ48CfGJ5B+HvxlzjxdxXjmxbjoebTky21WujJ83Q5r6eMF7VrWfTlrNK06rbrqYme576jA4WaKcWOmHFTDjjqtKxWv8ASFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlWx+VfJnGeFb34447zzetu4tyT1Ru+06fUTXT6yLVilvVH1jutYifTMeqI6nuEVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASXfvHvIeN8N4tzzcdVsuTbOYRrZ2/HpNzx59Vj/C5YxZPn4a/mxd2mJj6+319M+yNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJL4zwcB1XkfjGn8q6rW6bht9108b7l0cX+dXR+ru8V+X+fqeoiZr+aKzaY94hGgGZ/i40/wAOmm8yainwxZ8+TiVtu098/dtRbBXXTbJOSMM5/wA/p9E4u4/lie4j79YYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGefLnwf8z8O+B+Ceed85nsGt0POPw8V2vTxNc+ktn09s+OIyeqa55itLRb0xHU+/vBowMAAAApyZcWKPVlyVpH62nr7d/+ESqSjxn5I5T4k5rt/P8Ahl9BXd9tjNXBOu0VNVh6y4r4r90v9/Te3UxMTE/t3EhFq2resXpaLVtHcTE9xMOVV75Mt7Zct/Ve8za1vTFe5n6z1EREf0iIhSAAAMp/Dd8OvNvie8k08ccK1Wl0FsWkybhuG56zHa+DRaalq19U1r72va16xWncd/mnv8ssgfFt8DPPvhN0Wzcg3Xlm3cp4/vWpnQ01+k0d9LfT6qKWvGPJite/tatLzFov9a9dQmz0NbAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAASXlu+cM3bZeIaHivBp2HX7Ps/4TftdO55dV/jOtnJNvxPy7x1h6iZj01/3uvpSqNAAAAAAAAAAAAAAAAAAAAADv0Gjz7luGj2vS2w1z6/U4dJhnNkjHjjJlvFKze8+1a92ju32juV68hcF37xjzjevHvKMm35N22HUV02qvt+qjU6a1px0yROPJER6o9N69+0dT3H2BHgAAAAAAAAAAAAAFGalsuG+OmSaWvWaxaPrWZj6qwEp8jcw2Pm++6TduP+OeP8K0ul2vS7dbQbLS1cWfLii0W1WTv65cnqj1T1/pjuZ+qLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACmuLFS9stcVIvf+a0Vjuf6yqAAAAAAAAAAAAAAAAAAABJt04lsG3+PuPcz0nkfZdx3fedVrdPreM6fFeNbtOPDf0482a8z6ZjLETasemPaY6m3vKMgAAAAAAAAAAAAAAAAAAAAAAKJzYa5a4bZaRktHdaTaPVMftCtsbwj4kPEPGfhA5V8P27+EcO4cz37JqrYOTfJ01qRbJk9eHPkvafnRlwR6a0isTH5Ke8e7XIgAAAAAAAAJJxfi3H9+47y3ed38i7Tx7Xce0ODVbZtWs098mffst8lq3wae1ZiKWpWsWmZi0fnjvqO5RsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAevU7xvOt27R7Prd63HU7ft3f4LR59XkyYNL3338rHa01x/Wf5Yj6vIAAAAAAAAAAAzl8IHxQ7p8KXlDPzbBx+N82nddDO3bvoK5flZsmKLRfHfFefyxetonqLe0xe3vDIPxt/Hlq/iu23Y+G8a4dquM8W2jVzuWaut1Ncmr1mq+XbHSLRjn5dMda3vPXdpm0xP5fT1Opgmd6ACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADi1a3rNL1i1bR1MTHcTDimPHir6MVK0rH2rHUKgAAAAFWPHky/N+Vjvk+RinPl9FZt8vFExE3t19KxMxE2n2juFKS8R8kc24Js/LNh4lvttv0XN9pnZN7xxp8OX8TpJtMzTvJS00n3vHdep6vP36mI0AAAAAAAAAAAAAAAAAAAAAAAAAETE/SYnr2AAAAAAAAAAAAAAABxa0UrNp76iO/aJmf+EfVeuX8M5d4/wB9y8X5zxrcNh3fDixZ76PXYZx5Ix5aRfHeI+k1tWfaYmY+sfWJiAswAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACTcR0fjjVbLy/NzrfN90G66XZ/mcVwbbpqZcWt3P1T/AJeqtaJ+XiisR7x6Z/NPv3EQjIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACVc78h63n2Pj2LWcY4xs8cc2XTbJhnZdsjSW1WPD31l1ExafmZJm0z37fX6IqNhuHfCNPLPhH5L8Us+Uto0t9jy6muPj86b1ZLxp8s47Y75fmfly5Pa2Ovo+k1779XcTqDXkBQAAAAAAAAAAABxelclZpesWraOpifpMLjvvIeQco18bryff9y3jWxhxaeNTuGryanLGLHWK0p68kzPprEe0d/r+sreAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT3ETMR3P6ACT884rxjiuo2XHxbyTtPMcO57JpNz1WXQabLgnb9VlrPzNHlrfv/MxzEd+/f5o7rX27jAAACS6/f+IajxvsvFtDwOmk5Pot21et3Hkn+JZcltfpL16w6b8NMejHFJn6xP8Aoifre3UaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJfHPFuPc05ptnGuV+RNq4NtOstl/E77uenyZ8GliuK96xNKTHc2tWtI7tWPzfXvqJjmSuKmS1cGpjUY4tMUzRjtjjJX7W9Nvevf16n3j7gpAAAAAAAAAAAAABK/GXONu8e8mzch3TgPHeYYMu16zbo27fdPObTUvnpFY1EV/+JSInqf0taPbvtEcOOcWHHim83mlYrNp+s9R9VYAAAAAAAuGq4/yDQ7Nt/ItdsO5abat2tmpoNdm0mSmn1VsNvTljFkmIrf02nqeplb153HmXLN445tHEN15JuWr2TYJz22zb82pvbBpJzX9eWaUmeom1vf9vpHUAswAAAAACS7JyjjW18J5PxncfG21bxvO920M7byHU6zLTUbNGHN68sYcdY9Nvm0n0zM2j7dxaPZGgAAAAAAAABVa97af8Ja0zg+dGo+VM/k+bEemL9fT1RHt39elIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACSbXyrYtv8f8h4bqfHeybhu29azR6nScm1F7fjtqxYbRa+DBER16cvUxae49rW+vtAI2AAAAAAAAAAJNyjc/H2t4zxDRcR4hr9q3zb9Dnxcm1+o3K2oxbrqrZInHlxYp9sNa19UdR19YjqeolGQAAAAAAAAAAAUXz4cVq0y5qUteeqxa0RNp/b9QVgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADmtMuS0Y8GHJmyWn00x447te0/SsR95n6Mqea/he82fDzodg3LyvxfBtum5JitfR5NPraaiKZK1ra2HL6f5MsRaO4juPaerT0DFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALzwvUcO0nMNl1fkPad03Ti+HWVtu+i2vUxg1efT9T3XFkmYitu/TP1juImO47BZh6dyttmTdNdk2TT6rT7ZfV57aHDqskZM+LTTktOGmS0e1rxT0xaY9pmJeYAAAAAAAAF/27x/zfd+E7z5J2zjGs1PFuPavT6DdN1pbH8rS6jPNYxY7Vm0XmZ9dPetZiPVHcwsDvprtdj0Oba8eu1NNDqMtM+bS1zWjDly1/lvbH36bWj7WmO4+zoAAAAAAAAAAAAAAAEn3TbfGuHx5x7dNl5bvWq5vqdXrce+7Pn2/5ei0WmrfrTZMOf0/5lr16m0eqepmfavXSMAAAAAAAAAAAAAAAAAAAAAAAAAAAAkvFdu8da3j/AC7U805XvG071oduxZuLaTRaD5+Dc9bOSYvh1F+p+VSK+iYt3X+a09z10CNAAAAAAAAAAAAOLXpSPVe0VjuI7mevefaHK8cO5ZvnA+V7RzXjOqpp912TWY9dpMmTDTLWuSk9x6qXia2ifpMTH0n7T7gs/cdzHfvWZrP7TE9TH9pF15VyXd+Z8m3bl2/5sebct61ubX6u+PDTFS2XLeb2mKUiK1ju0+0QtQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACT8U8j8n4Xxvl/E9jrtk7fzjQ4Nu3adVoaZ80YcOS16fIyW98Vu7z3aImfp11MRKMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJDsXj3nPJ+Ncg5jx3i+r1+x8Ux4Mu9a/HbHXHoq5rzTHNvVaLW7tE+1ItMde4I8AAAAAAAAAAAAAAAAABMdxMd2j96zMTH9Jj3hN/I/m/y/5f02zaPyj5E3bkuDj+CdPtuPWfLiuCsxWJnrHSvrvMVrE3v6re31957hAAAAAAAAAAAAAAAAAAKLZ8FctcFs1IyWjuKTaPVMftCsAAAAAAAAAAEn3Dx9u22+Ntj8o5t64/l27f9z1e14Nvwbj8zcsF9P6vXkz6eK/5eOZrPptNpmfVT2/MjB1Hfq6jv9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB249VrMOn1Gjwa3U4tNrPl/icGPPemLUfLt6sfzKRPpv6bfmr6onqfeOpdQAAAAAAAAAAAAAAAAAAAAAAAAAAAAA69VlnT6bLniO5x0tfr9eo7dhMRMdTHcSD7HeOf4YHwwavwttG0ci2vct333c9uw6vU8kx7lqMOe2oy4629eKlb/LpjiZ/LTqY6+vfcy+Q/LthjinL+QcTrrq62Ni3fW7VGqr11qI0+e+L5kde35vR6vb9WXuOfG98UXE/GU+Jtj8ra7DstMMaXTZr6fDk1uk08R18nFqLUm8V69u57tET7WjqOsF+/wB7WtP1mbWmZmf1mZ95n92ZLAAaAAEo2PyTynj3A+TeNtuja7bJy3Lo8+4RqduxZtRS+mvN8c4cto7xdzMRb6+0R16Z7mYuAAAAAAAAAAAAAAAAAAAAAJVTZPHs+Mr8hvzzVV5rG9fhKcd/wnJOG23/ACYtOo/Fd+iLeueuv2mOu/dFQAAAAAAAAAAAAAAAAAAAI970xx73yW9NK/e0/pEfeRJfHHkTlXijmu2eQOFa3Fpd52m2S2myZdPjz0j147Y7RNLxMT+W9v3BGa2resXpaLVtHcTE9xMOXZqNTqNZqMur1eacufPe2TLkmIib3tPcz1EREdzP2iIdYAAAAAAAAAAAAAAAAAAAAAAAAAAANkfD3wr8A8k/C/5D898g8zU2LeOHxq502zUpitT/ACMNclI1ET3kmcs29NYp19Y+s+xbg1uAAAABxS9Mmpx6LHaL6jNaK48Nfe97TPURWv1mZn7QDkS3aPEXlffOp23xlyu9LV9cZMmz6jFjmv2n13pFf+a6/wDo9+bIitsvj7Nhi/8AL8/dNBi/5XzxMf3Ngx6Mhz8PXmyKzenj7PmrH1nBuegzdf2pnmVo3fxJ5V2O0xuXjPldKxET83Hs2oy4v/qUpNf+ZsETDN/6vq8mg1ETi1WKesmDJ+XJSf3rPvH9wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGxfmXy/8ADJyz4cfHfAvG/hD/AADyBs84o3reIwYqdRTDeuabaitvmar52Sa3iLx7fWerRENdAJMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEr8f+Otx8iZN/poORcb2enHti1W+58m9bnXSVzY8M0j5WLuJm+S03jqPp+s+8dxQmInruInr6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADrvp9PkyRlvgx2vXrq01iZjqe49/wCrsAATTjfjTLrNkw815vvOPivE8tusOuz45yavcZ95mmh00fmzz1H/AFk9Yq99zaYiYNwQ3Fjy58+LS6fFkzZ894xYcOKk3yZbz9K0rHva0/aIiZlO6+JNbsuLHq/JnJtr4VjtFbzoNX3qd5tjtPVb127HMXiJ/XLbF17zP0c5/KWLj2mzbR4i2GeJ6XNjtgz7tlyV1G+62k/zfM1fUfh626iflaeK1if9UoFaZvlyZslptkzXnJkvae7XvP1taZ95mf1lOxO8nJ/FGwY7Y+IeONbvuqmv5dx5hr5tWkz7WrGh0dqY+uvpN8uSYmf2VZPOvk/Fgy6Hj2/afi235a+iNDxrb8G14sUe/cUvhpGb6zae7ZLT3Pff06gIYPfvG/8AIOR1mvI9/wB03fue5ncdbl1UzP8AXJa0rTXQ6Gk900eCs/rGOId4o6LaDQ3n1X0WC0/rOOJ/+y7bRv8AyDj1Ypx3kG6bRFe5j/Dtbl0sx39ffHarwAJ7g85eTLaSu17/AL5g5TtsVis6Hkuiw7riv1PcTa2etsncTET3F4VRybxFyTJSvKfHGs4zmv1OXX8Q10zim3UREfgNXN8dafWZ+XlpPtHUIAJkGQo8N7hv+n/GeK+UbXzrHSk3zaLSVnRbtgrHfdraDNPrvWOuu8Vsncz7R90AzYc2m1GXR6rBlwajT3nHmw5qTTJivH1retupraPvExEqazNMuLPSZrlwXjLivWerY7xPcWrMe8TE/SY94T3F5SpyXT4do8v7Pk5XpMGOMOn3bFljBvmhrEREfL1Ux1qKx138rUReJme/VHR3BARMuQ+NtRpNj1HNuGbvj5RxPBf0Ztdgxzj1W3T3EenXaafzYJ9/bJHqx2j80Wr6ohDV3QAAAAAAAAAAHX+J00Zvw/4jH83/AHPXHq/X6fV2AAAAAAAAAAAAAAkuk45xPN4z3Tl+r5/g0/JtLveDbtFxf/Dctsmr0dsUWyav8TE+ila2tMdTHv8ALmO+7R0EaAAAAAAAAAAAAU2y463rjtkrF79+msz726+vUfdUlXHfJG9cZ4RyrgGi2Tjep0HL40f4zVa7a659dp/w2WclPw+abR8ruZnv2n9Y6kEVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJd64rxza+Eca5ToPJO0btu2+X1tddx3TabJXVbPXDlilLZ8kz6Z+bE+qsdR3HvHqiJkEaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0iItabTFa1rEzNpmeoiIj3mZnqIiPeZcWtWlZve0VrWO5mZ6iIZS275fgzQaffddocebyRuGHHqdq02oxxfFxzS5K911WbHaOra29Z/y8c/8AVRMWtHfVZUefDx3jnirR4918hbZpt75dnx0zbdxXNb1afb62juuo3SImJm33rpPaZiYm8xE9VhXJ+T7/AMz3zPyPlG55dfuGoiKzlydRGPHH8uLHWPy48de/alYiI9/vMzNuz59Rq9Rm1ms1ObU6nUZLZs+fNkm+TLktPdr3tPva0zMzMz7zKgwAAAAAAAAAAAAXTjHKOQcL3zByTi265tu3HT/ljLj6mMmOZibY8lLRNcmO3Ud0tExPUT13ETE1txvYPLGk/wAQ8ebXpdn5lS1KaviOntFMG5VjH+bU7Z659rR6L2vpZnuI96TPXVsbK8WXNp82LVaXPlwZ8GSubDmw3mmTFkrMTW9LR1NbRMRMTE9xMRMJYKPeJtW1bVtW01tW1ZratonqYmJ94mJiYmJ94mBlLcb4/Oe3Z950e15Y8l7dhnPueDRaePl8l0mOv59XXHXr0azHEROSlY/za/mrHq7rXFlLVvWL0tFq2juJifaYWUcgAAAAAAA2O2D4quGbV8HG8/DFq/C236je9w1GbJh5FW2L0R8zURmjUXi1ZyfiMf8ALXqfT+Sk91/ljXECTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFOTJTDjtlyT1SlZtaf0iPq2cr/AA4vixv4y/6UK8N2mdPOj/xCNmjc5ndpwder2wxj9Hr9Pv6Pmd/b6luDWUKz6qxbqY7jvqYmJ/vE/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFOTJjxUnJlvWlY+trT1EOa2resXpaLVtHcTE9xMA5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJ9i3Xx1peD8m2vkXCNfuXKtbk0c7BvGHd8mnwbdWl5nURk09Y9Ob1V6iO+/r/p6iZCMAAAAAAAAPRt2LQajctFp911+TQ6DNqsOPWavHhnNfT6e2SsZctcce95rSbWise8zHXu84C/c92/he0813rbPHHJNfyDi+m1Xo2rdNfo50uo1WH0VmbXxTETWYvN6x+WO4rE9R2sIAAAAAAAAAA9OPbNzy7dm3jDtmtybfp8sYM2spp72wYsk1i0UvkiPTW3UxPUzE+8fqCe8P0Wg8c8e0/lfk2hwavddZkvTh20aiO65M2O3V9z1FPrOHDb2x1nr5mWI/wBMRZAdw3DX7vuGq3fdtbm1mu12a+p1WpzW9WTNltPdr2n9Zn+0fSOojp0TM2mJtPc1r6I7+1e5nr+ndpn+sz+rgwAAAXrh3DOVeQeQafivC9j1O67pqZj04cNfy46/7+S/0x0j37tbqPbqO56iQsqS8L8aeRPI+WMXA+E7vvkWjuM2m0/Wn+vU957+nFE/tNu28PhX4C+E8Vx4N88tWw8q3fqLf4fMT/hunt+k0n/r5j9b/l7juKw2n0ei0e3aXFodv0uHTafDWKY8WGkUpSsR1EREe0QzeX6Hz14x/Dz8v7vjpm5LybjvH4t1b0VnJrssR39JrX0Viev0vMMg6L+G3s84ccbp5a3G2WKx8y2k2zHjrNvv1F7X6j6/q3PGflRpjrf4beyRitG1eWdzjJ3+WdXtuLJHXf39FqfZjzk/8PTzDtGO2XjXJeOcgrXufTa2TQ5Jjr6RW0XrM/1vEPoiHyo+O3O/FnkfxjkmnPuF7psuOLemNTnxerTW9+o6zUm2P3+0erv9kVfa3WaLR7jpsmi3DSYdTp8sTXJizUi9LR+kxPtLVrzX8BvCeW48+++KcmLi28+950PUzt2pnvvr0fXDM+/5qe3v71lqcv2PnuL1zHhfLPH2/wCfi3Ndi1O07np5/NhzR+XJX2/PjvH5clPePzVn79T1PcRZWgAB6Nv3Hcdn3DS7xs+vz6HcNDlrqNLqtPeaZcGWv0vWY+k/+MdxPcTMJ1zvRbXzPYa+XeM6XS6TJkz00vK9q08emNBuF/5NXjra9p/D6me5j7Vy+qvczPtj1J/HnMsfC+Q/itz0ttdsG5YL7bv+3R7xrdvyx1kr1/v19slJjqYvSOpiJlLPsRgSDnnENRwXlGq4/fVV1ul9OPV7br6Wi1Nft+avr0+ppMe0xekx317RaLx9kfUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU5MlMWO2XJPVaVm0z19oZA8o+BPMfhXT7JqvKnANw47h5Dgvn2++fJhy1yxWY9VZnFe8UvEWpPpt1PVvp7T1AZ76/Le1Z+1q2mJj94mPeJZP8x/Et5n8+6Djm2eVOVY910/F9NbT6GuPSUwTebRWLZs3p/nyzFKxNo6j9KwdjGAACnLjjNivim1qxes17rPUx3H2VAJR5G57l8j79ot9y8S4vx38Fs+i2iul4/t34PBkjT1tHzr09VonJabT3Pt7RWPfruYuAAAAAAAAAK8WbNpslNRp4xzlxWi9PmV9VfVHvHcfeO/rD62ab+Lp4Ip4sruuXjXJo5rj0UY/9n42//LtqevT3Gp9XyYxd/m7m3q9Pt6fV+V8kBLNHfrddqt01uo3PXVw11OszX1GauGvpxxe9ptaKx9q9zPUfp06AUAAAAAAAAXnhmxbXyjl+zcb3vlu38W27c9ZTTare9wpN9Nt+Oe+8uSsTEzWOuvrHvMdzEPJv236PaN93PaNu3zSb1pNDrc+l0+5aStq4Nbix5LVpnxxb3it4iLR9fafrP1nwgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATHcTHcx3+iUc85ntfM8uyZdr8ecY4n/hOzaXas9dj0tsMbhlxRPq1WbuZ9WS/fvP19veZBFwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZX+FvyjwHwx5v2PyJ5L4Pblex7fi1GK+ipixZb4cuSsRTU0plmKWtT3jqZj2vMx7xCPebebcX8k+X+X8+4VxCvF9i37c7avQ7VEY4/D0mla2ma4/yVte9b5JrXuInJPvP1QkM+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMPEvjDfvMPO9BwTj+bDp8+sply5dVnrM49PjpSbTe0R7z3b0V6j37v39pbSeVds3rwZ8Jei8ObBsG959633Xzt+963S7dly4bZbzF8847+n81MnthxzH5up9veGHvg04FtfNvNu36/etfpdPouM4rbpbHlz1x31GWO646Vife1YmZtbr6emPtKebj8bO9ce5zyvatl2jS63h+inW4eNae1O8uLWViKY898027titf52SOu7RF6dfpGb3Rqlkx5MOS+HNiviyY7TS9L1mtqWieprMT7xMTExMT9FL2bvrNNuO56nX6TRX0mPUZJyzivqr6i0Xn3tM5Mn57TNu57tMz7/WXjaAHZp9PqdZqMOi0WnvqNTqctMGDDjju2XLe0VpSv7zaYiP3kEn8YeMuV+XeY6ThXD9J8zVZ+smo1FqzOHRafvq2bJP6R9q992n2j7zH1G8LeEOGeDuLV49xfTTl1ObrJr9yzVj8Rrcv+9e0R7RH0ise0R7QsPwx+CNB4N4Bi0Gppjzcj3b06vedVHv3lmI6w0n7Y6R+WI+89zPvMpF5G5Zm0c/4Dt2WaZL0i2oyVn3rE/Skfp39/26c7dF53ryDx7ZsltP8AMy6zPT2nHpqxbqf0m0zFf7drLj8xbPW//r2y7lp8X/xIimSIj9Zitu2NhBn3at223e9FTcNq1mPU6fJHtek9/wBpj6xP7S8fIOU7TxvFFtfktbLeO6YcURa9v367iIj95mGL/GG45Np5jG2Y5mNLu+K/qxx9IzUj1RaP7dwtu/azU6/edZqtXNvmWzXjqf8ATET1Ff7QCfY/LuyfN9Op2nccOLv3y+ml4iP1mK2mf+ESmW3bloN20ePX7bqseo0+WO65KT3E/rH7T+zACZ+JNTqMO+7ht2OZ/DZ9NGptX7VyRaK9/wB4n/8A1BlVxMxWJtaYiI95mfs4jJjm/wAuL19X+737rVyzS6vWcd12m0PqnNfF+WK/W0RMTMR/WO4BA/LXjXxP8QGyTxTkOs02TX6f122/W6bLFdVo80x168c/6o/Ws91nr3h8y/KXjPk/iHm2u4NyzFH4nSz69PqsdLVw63BP8ubH39p+kx7+m3cdz7TO/wBeJrPfdqWxz6otHtNLR9Jj9JiV88/+Eq+ffEmmwZcVNPyvQaauu2vUTE19Oo9ETbDf/sZPesxPfUzEx7xCy4PlyOzUabU6LU59DrtNk0+p0uW+DPhyR1fFlpaa3paPtMWiYn94dboAAMgVvXm3iK2G9vXvnjjJWcMfXJqNh1WXq1fr3aNLqbVn7Vpi1DH6VeLuR6HjHOtt1e81xX2XX/M2jeaZZiKW27VVnDnm0z9qVv8AN/riqs3IuP7hxPkG58W3WbW1ez6zNoc17Y/R8y2K80+ZEfatuvVH7WhJ0LcAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9my5Nmw71t2bkej1mr2jHrMF9x0+jyxi1GbSxkrOamK8+1bzT1RWZ66mY94+oPGL3zbVcM13MN41njrZtz2jjGbV3vtWh3PUxqNVp9P7dVy5Itb1W77n+aeomI7npZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI/LeuSvtek+qto+tZ+ncT9vqREViK1iIiPaIj7JhfadoxeGMG+W0mKu8armOo01NRaP8AMtosO34LTjj/ALPzdRFp/eEPAAAbP/AV4mpzLyTqfIu66euTbeH1iNNFupi+4Zaz6Z6//t45tb+t6T9msD6hfBlwOnB/AWwZcmOsa3kcW33VWisRafn9Tirb9ZrhjFX+ycr0M4sHcvnJPJ9z+b/N+It/w+3/AC6ZxQfnPBs+7553faIrOpmIjLimevX1HtMT+v2cxi8e/Jx/fcWX5N9m1sX766+Raf8AnEL5sfjrfNzyVvr8c6DT/WbZI/PMftX/AMwPGWz5ddyaN3tSfkbbhvEW+05bxERH9q9z/eEi5b47ybnq8m6bNlx0y5Z9WTDf2ra33mJ+0z+6X7TtOh2TQ49v2/F6MWP9febT97TP3mXsBh/B435VlyxjvpMOGv3vfNX0x/w7n/kter1M7NbU7Vs+uvEXmKarU4p9Fs81/wBNZj3ikT31ET7+8yzllra+O9az1M1mIn92vup0+bS6jJptRSa5cV5peJ+sTH1B5p02H1/NinpyfX5lZmL9/r6o92T/ABhyjcNz/FbFu2otqMukpXNgz3n898Uz6fTb9ZiY+v37Y1ZG8X7JqNFi1vItVhtSM+OMWCJ+tqVmbWt1+kz1Ef0BK9ZtfFsetrq9fpNupqsk91tl9FbWn9ff6yu8dddx9Gve6Zp3jXZtw3CPn5c95tM5I9XUTPtWO/pEfom3irfdVj12Xjepz5MunvinPpYvM2nFNZiLUif93qYmI+3Ug06+PbxRj4d5I0nkTadN8vbuX1tGq9MRFabhirHf98mPq3/8dp+7V99RfjL4Vh5l8P3JMvo71XH8cb5prRT1WicH5r1j/vY5yV/u+XTpxvQAKOL0rkpbHesWraJiYn7wn/luf8ay8W8h1vXJblnH9Nl1uWO49e5aTvRar2n6R3p8dv39ff3QFO9d/wC0/BGza3PEfM47y/W7Vp4j26wa3R4tTMz+v+bpsv8A/lP7pRBAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABe9h4TzHlO0b/v/ABvjO4bntvFdJTX73qtPj9WPb9PebRXJlnv2rM0v9O/5Zn6LI9mh3re9r0m4bfte97lodJu+Gum3HT6XWZMOLW4YmZjHmpS0Vy1iZn8t4mPef1kHjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEp4h4r8meQNp3rfuC8B3zf9t47i+duuq2/SWzY9JX0zb83XvM+msz6a9266nrqYRWtq3rF6Wi1bR3ExPtMA5AAAAAAAAAAAAAAAAAAAAAAAAAAAAABPOWTbH4c8aUj8tdVrOS6q0Rb+aYz6TDFpj+mHqEDTrmMUjxL4rmPV3OLkP1767/xOe+v7ehBUgAKOa6PNuNq7fprRXNqpjBjmZ66vf8se/wDWYfZ7bMO3cY49t+35M+DS6bQ6XDpqTe0UrEUpFYj7R9nxy4xHfKtiiY7id20UTH6x+Ip2+pPk/XZs+/10M2n5Olw19Nft6re8z/4R/ZnkMqafUafVYoz6XPjzY7fS+O0WrP8AeHYwVx3kWv4vrfxeh7yYbT/n6abdVyR95j9LfpP/ABZt2/X6XdNFh3DRZIyYNRSL0tH6T/8AdgegAAABYt84Zse/5PxGqwWx5/pOXDPptP8AX7T/AHX0BF9t8c8b2/JXNfFl1d6z3Hz791j/AOWIiJ/uk8VrEemIiIiOuvt05AYi5PwXdtu1+XLtuiy6nR5LTbHOKvqtTv8A0zEe/svfjniW4aDXX3vdNNbB1inFgx39rT6pj1WmPt7REf3lkIB4N/23DvWxbjs+prFsWu0mbTXiY7ia3pNZ9v7vi7fSZtBe2h1F/Xl08zivb9bV9pn/AIw+2Pt9/o+MPLPT/tbv00/kndtb6P8Au/Pv6f8Al01xFqAbBPeKz+J8NeRsGaZtTbtfx3X4qx/pvfLq9Pa3/DNWECTvhX/4S+Wf/wBjjf8A/wBRKIIAoAAAAKIzYbZJwxlpOSsdzSLR3H9v7x/xVpPr/IvI9y8a7L4o1WHaZ2PYN01W76PLTb6V1vztRExkrfUfzWx/mmYr1H0juZ6gEYAAAAAAAAABIOU8W0HHNDx3W6Hmuw7/ADvu04tyz4NtzWtl2vLaZi2l1NZj8uSvX/j7R17x8HLw8Ofj4fHycvle+8k++vXXU6W9+gB1QAAAAAAAAAAAAEo4FvPAdlz75k5/wjU8lx6vY9Xo9rx4d1yaL8HuF/T8nU2mkT64p1b8s/r9J+0XAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIPH3AuVeUub7L464Ptsa/fuQar8JosFskY6zb02va17T7VpWlL3tPv+Ws9RM9ROwXxEfw8PNvw68Bx+Sd53PY+RbPhvSm6TtPzvmbd67RWlrVvWPmY5tMRN469Pcdx13MYh+HvzJuXgDzHxnyzt23TuMbFqb21WhjJ8udVpsmK+LLji0+0W9OSbV79vVWvfUdy3N+MP+JjwfzH4d3DxN4s4ZvePJybDhx7puG71x4selwxeL3xY6Y8lrZMkzSK9z1SItM9269KXdHzuAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZu+HD4RPKPxPaLle5cD1myaLS8U01L5cm5am1J1OpvW9qYKRStpj2pMze3tHdeon36wjHr6/PSaW+9Z67if09l/4nz/nPA43WOE8w3rYY3zRzoNxjbtdk08arB7/AJLxSY769Vup+seq3Ux3KP1rWlYpSsVrWOoiI9og7HIAAAAAAAAAAAAAAAMzeD/i18w/D1w3lvBfHOo2Wm3cvib6m+u0Ns2bTZ5xRhnLhtGSsRPoiI6tFo7iJ/WJwvix0w4qYccdVpWK1j9oVBgAAAAAAAAAAAk3EOW7HxrZ+XbZu/jrY+Tajkmzztm367cZmM2w55tM/jNN1E/5nvH+7/LHv9QRkAAAAAAAAAAAAAAAAAE75P8A+teGfHebDPzKbbuXI9BmtH+i98mj1Faz+8xmtKCJ3oYjcfBG86PBPqy7Dy/Rbnn79vRp9Zos2n9p+/eXS4Y6/ogiQAFHNdXm2+9dfp6zbNpZjPjiPrNqz6o/5xD6n80yYtzjaOT6W0X028bdg1GO8ffusT/4Wq+V76U/DNuuHyr8M/HtHTLFtz41jttFvVbu0X0/5aer3/14vlz7/wC9Es8hUyL4l3W9sWu2LLfuMMxqcETP0raerxH/AM0RP/zMeZMeTDktiy0ml6TNbVmOpiY+yWeLa5J5RkvSJ9NdFki/t+t6df8A3YGWgeXddTfRbZq9Zjju+DBfJX+sVmYBTm3raNPq66DUbppMept1EYr5qxee/p7TPb2NeM976q98mptOW+SfVeb+82n9ZZM8Wcg1Gt0up2LW5bZcmhit8F7z3M4bdx6Zn7+mY6/pMAnYAAAAAPDvu44dn2TcN21N4pi0Wlzai9pnqIrSk2n/AMHxcvq82vvbXaivpy6mZzZI/S1veY/4y+o3xi83pwnwDyScettp9bveOuzaT0T1ktbPaK5Jp7/WuL5lu/tEdvlu3xABoE74tSmm8OeRNTqf8uu4bhx3b9PaZiIyZK5NZqLUj9ZiMNZmI+3ugiea+tds8EbJpM1p+ZyLluu3XD1374NFpMWmj79dfM1OePp9Yn39kogYCgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC88O4byryFynbeEcH2PUbzv28ZbYdDocFqVvnvWlsloib2rWOqUvbuZj2ha9XpNXt+r1G36/TZNNqtJmvp9RhyderFlpaa3pbr7xaJif6OdHrddturw7htmv1Wi1ent68Op0ue+HNit1Md1vSYtWepmPafpMx93VMzaZta02taZmZme5mZ+szIOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHo2/btx3fcNNtOz7brNw1+tyxh02k0envnz58k/SmPHSJte0/pETLzpP4v8h8g8SeRuOeTuLRprbrxrXV1umpqcfzMWSfTalqXr3E9TS9o7iYmJmJj6AtnJ+Lcl4Vvuq4xzDj+47Lu2imsajRa/TXwZsfcd1ma3iJ6mJ7ifpK1slfER545T8SXlLWeU+Xbft+36vUaTBoMGk0NZjFg0+H1TWvqt+a9vVkvM2n9Yjr2Y1IAAAAAAAAAAAAAAAAAAAK8GHPqtRh0ek0+bUanU5K4cGDDjtkyZclvpSlKxM2tP2iImZBQOzU6bU6LU5dFrdLn0up09vl5sGfFbHlxW/3b0tEWrPvHtMdusAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEn5Lt3jTScT4jrOIcs3zcuS6zS6i/KdBrdujDpdu1EXrGGmmy9R82tqzfue7fSPev0mMAAAAAAAAAAAAAAAAAAAAAADPHj/AOBr4ofJ/jfH5W4f43+fsWpwTqtDXUa/Dg1e4YOu4yafDae7VtH8vqmsz9o667W4MDivLhz6fNl02q0+XBnwZLYs2HNjmmTFkrM1tS1Z6mtomJiYn3iYmJUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlPHvGPNeVcL5P5A2Lasep2Th/4Wd2zTqsVL4o1F5pjmuO1oteO6z31Ht+6LOYnqt6x7Rl9MXj7W9M917/XqfeP0lwAAAAAACfeIK5d41fJ/H+OsZbct47q8Gk08x3GXcdJ1rdLM+3cdfh8tY/fJ190ApeuSlclLRatoiYmPvErnxrkW4cQ5HtXLNqi1tZsutwa/DSuT0fMtivF/lzb7Vt1NZ/a0r55X49ouOc93LFs8f8AsXdPRvWy3jr0327V1+dg9PX2rFpx/wBcdk+xEQFBtD8A/lbHw/yPrfHW7aqMe3cvrW2k9UxFabhirPUf1yY+6/1x1/Vq87NNqdVotTg12h1OTTarS5aajT58c9XxZaWi1L1n9YtETH9CzR9jeQ8H2bkGSdVki+n1M/XLi6/N/wB6J9pd/GuJ7dxjFljS3yZc2fr5mXJ13MR9IiI+ke8sd/DJ530HnPx/h3DUWph5HtUU0u9aWO49Obr2y07+tLxHqiY+nc1n3iWX3IeTU7vtWjz102r3LS4ct/5aZM1a2n+0y9GXFj1GG+HJEWx5azW0frEwxPy/h+/Y941OrxaTNrcOqyWyVyY6zaY7n+WYj3jr6fom3j/R7xoOPxpt4pek1y2nBTJPdqYuo6if09++o+0AxjyLj2t47rr6XU45nFMzOHL1+W9ft7/r+sJb4p2jVY8+s3rLjtTDkxVwYptHXr9/VaY/b2j/AJsiZMePLX05cdb1/S0dw5iIrEVrEREe0RH2ByAAAADEXxL+d9t8G8CzbhjvTNyLdK302zaP72y9e+W36Y6d+qZ+/tEe8xANR/j28sY+ZeS9L472rNF9u4bS34q0T3GTcM1azaP/AOPH6Y7ifrkvH2awuzU6nVa3U59drtTk1Oq1WW+fPmyT3fLlvabXvb95tMzP9XW6yYAAOL3pjpbJe3VaRNpn9IhP/LmPLseXi3j7JFcOTivHdJj12mrX/qdy1fq1uq7tP1t3qMdZ6mYj0dR9JW3xTx/beSeQdn0e/Xpj2TRZZ3XecuSInHj2/Sx87P6+/aK2rSMXc+3eWsffpZeSci3Dl/It15Zu0WrrN61ufcM1LX9fy7Zbzf5cT/u19Xpj9qwn2LaAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgeBfMW5+A/LPH/LG0cf0G96jYsuW/wCB1tvRTNXJhvitEZIracdoi/cWis9ddfdj8BkX4gvNG4/EF5a3zyxuvGtv2HPvNsP/AKjoslstcdceKuOs2yWis5LzFO5t6a/aOvbucdAAAAAAAAAAlHj7mGxcM3Hc9byDxrx/mmHcNo1W2YdNvM3+Xos2WKxXV4/T7fNx9T6e47/NPVq/eLh7CImIiJnuf1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABRnxfOw5MM2mvzKzXuPrHcdPsH4T/ibfDXoPBmxzzjdddsPIuP7Tp9BrNkxbXqM9subDjjHH4e2Ok0vS/piYmbR1Fvzenqevj+JZokvkzmf/SL5H5Tz+u2U26nI961u6U0lOv8AIpmz3yVpPXtNoi0eqY9pt3MI0CgAAAAAAAAAAAAAAAAAA9W3bVu+858ml2XZ9w3LPhwZNVlxaHSZNRfHgxx3fLauOszFKxMd2n2juO5eVe+Ic35h4/3TUb1wjkmv2TX6vQ59sz6jR5PRfJpM0RGXFPtP5bemv7x1ExMSCyRMTETE9xP0kcVrWlYpWOorHUR+kOQAAAAAAAAAAAAAAAAGQcnfOPEGC9fVfd/G1748nvNr59j1WX1Vt9PeNNqLWr13EUx5+/sx8vvB+WZeE8o0fII0VddpKxfS7loL9TTX6DNX0ajTWifaYvjmeu/aLRSfsUWISTn/ABHBxDfowbTqsuu4/uWGm47DuN4/980GSO8dpn/4lffHkiepi9J7iImEbJ2AAJX4v8l8n8Rc10POOJ5+tTpbRXUaa95rh1uDv82HL19p+09T6Z6mO/eJ+o/hjzfwjzjxr/HuI6u1c+n9NNw2/PHp1GiyzWJ9N6/eP0tHdZ+0vkavfDua8s8e7/g5RwrfdTtW56eY6y4Z/Lkr7/kyUn8uSk9z+W0T9e46nqYlmj7MDVXwp8ePCeXY8GxeVqYuLbzPVI1vvO3am3fXfr+uGZ9vy39vfqLS2k0et0e46bHrdv1eHU6fLEWx5cOSL0vH6xaPaXPMHcAAAAOnV6zSbfpsmt1+qxabT4azbJly3ilKRH1mZn2hq15l+PXgnFsWfZvFFcXK93jun46JmNuwT/vRk/8Az59/pT8vcdTaDNGa/M/m3hfhDi2TkPKdV69Tli1Nv27FMTqNbm69qUj7R+tp6iI95l8ufKPk/lnl/mOr5ry/UxbU5/yafTY7T8nRYI/lxY4n7R97fW09zPXtEW3mfNuV+Q+RanlfNN6z7pueqn82XJPVcdftjx1j2pSPtWP6z3PczZHSTAAUASXx9w/FzTkE6Pctbfb9i23T5Ny37cax3+C2/FEzkvH/AG7TEY6R9ZveOonqQXqPVwjxJN+oxb15GyVik+qfmYdg02X1Tb7TT8TqqU6n3i+LT2/VAF+51y3PznlOs5Hk0ldHp8kY9Nt+hp7U0Ohw1imn09Y7mIilIjvqeptN7f6lhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANiPFHwCfE15n8b4vKfDeMbRi2XWY8mbbse57lOm1O4Y6/TJhxxjtHptMT6Zvavq67+kxM4B3Ta902PctVsu+bbqdu3HQZr6bVaTU45x5cGWlpralqz9JiYmH1E+Gn+J/4G4Z4I45wryRtu9bLyHiW1YdprpNv2m2bTa+uDHGPHkw2x91xxatY7rkmvpnv7dTPzh8weQ8vlrynyvyZl2yu3TyXddRuNdJFot8il7TNazMe02ivXcx7d9sy3exDwGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAABnv4NPJXw9+LfJG7798RHj2OU7Xqdmvpdsm2hpra6PUTb8/8Ak3mKzOSk+j19TNep+kWlhPkGq2fXci3jX8c2q+17Rq9y1Wo27QXt6raTSXzXthwzMTMTNMc1r7TMfl+svAGd6AAAAAAAAAAAAAAAAAAAAAAAAAknMfG/PPHuPZMvOOLarZq8j2vBvO1/iMmK06nR5Y7pk6pe01/7t4raP0RsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXTjuo4zptZqMnKtp1m4aa2ky0wY9LqfkWpqZ6+XktP3rH5u4/ePaVrjvr3+rd45xnLZ39fc/wB6zv6y1z4+S8ud4fGzM76y7+u96+9k9zNAGHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB26TSazcNZp9u27RanWazV5a4NPptNhtmzZslvpSlKRNrWn9IiZS7yH4X8u+JMehz+T/ABryDi+Hc5mujy7jpJpjz2iO/TF4maxbqJn0TMW6iZ66iU++CfydwXw/8TPDud+SPk4ti0uTUafNrc2L102++bBfHj1MxETMRW1oibR/LW9pn2iW+/8AEZ+KP4dOX/DVuHBOK8943zPfuQ6rQ5Nt021a7HqraaMeopktqbzjmflxWlbRHq69UzFfuzblHyXAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGbOTfCL5V4n8Nmy/FDuufZLcY3vJpbYtJh1VrazDptTaKYM16zSK92vasTStrTETE9z7xDcEU4LrdDzXY6eH+R6vTaW+TU31PFN01FvRTb9wydevS5LRS0/h9TMRE/auX026mZ9oNuG37jtG4araN40GfQ6/Q5rafVaXUU9GXBlr7WpaPtMf8AP2mO4mJea9K5KzS9YtW0dTE/SYZT26n/AE67fh2fXbtk/wCkvbcFdPteXW5q/L5Jo8dfyaS2S3Xp1uOO/l3tP+bXqtp9URas9DForzYc2nzZdLqsGXBnwZLYs2HLSaZMWSszFqXrPU1tExMTEx3ExMSoUAAEq4L5T8j+MskX4FzTdNmx99zp8GX1ae3v3PeG8Tj7n7z6e/3RUBtHxn+IZ5g2qk05Lxnje/xHUVmlcuhv1+9qzesz/SsMiaL+JFsXy4ndPFW5Vv17xpdyx5I7/wDnrVowJ8YN5tw/iRbLGC9to8UbhfN6Z9FdXuePHWZ69u5pS/Xux7yn+IX5d3fBbDxnjPHuPer2+ZaMmty1j396zb0Vifp9aTHs1bD4wSnnflLyL5OzfN57zHct5pHfpwZ8kV09Y77iIw0iMft9p9Pf7osCgAACvBg1Gr1GLSaPTZtRqNReuLDhw47ZMmW8z1FaVrEza0z7RER3IO3btu3Hedy0mzbPoc2t1+vzU02l02GveTNltPVaVj9Z/f2iO5nqImU557q9DwrZI8Pcd1mm1eTDnpquV7lprzamv3Knfo0uO3UerT6buYj/AHsvrt1Ex7+rVZtP4Z2jV7HpMtMnkXc8U4Nw1mnyxavHNLevV9JivHcTrLxPWTJWf8us+is992nGda1pWKUrFa1jqIiOoiE9jkBQAAAAAAAAAAAAAAAAAAAB2afDOp1GHTRn0+Gc+WmKMuoyxjw4/VaI9WS8+1KR33a32iJn7L/5F4LuPjPm+7cD3feth3bWbPlpizavY9dOr0d5tipk/JlmlfV1F4ifb2mJj7I4RERHURER+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJNr9x8dZfG+ybTtvEt003OdNueqy7tvV9ytfR6zQW9XyMNNNPtS9O6d2iI79M+9uwRkAAAAAAAAAAAAAAABTbJjpatb5K1teeqxM9TM/sqSjinkTeOH8Y5dxTbto2DVaXmej02i1mo1+3Vz6rS0w5ZyVtpcvcThtPqmJnqf9PXUx7hFwAAAAAAAAAAAAAAAAAAAdmfU6nUzinU6jLmnBhppsU5Lzb5eGkdUx17+lKxM9Vj2j7OsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcWtWlZvaeorHcz+kMu+S/hT83+IvGXG/LvOuO6HScd5RbFXSWwa+ubUYJy4py4oz44jqnqpWZj02t1PtPTEcxEx1MJfynzB5U5xw/YfH/ADHn+8bzxzjExbaNu1eWtsekmKWpWYmIi15il7VibzaYrPUF0RAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABe9Xznm2v4noeBa7mO+ajjO2ZJy6TZsm45raLDeZ77rgm3o9p949vy/bpZABzE2rat6XtS1LRetqWmtq2ie4tEx7xMTETEx7xMOAGR9Pv3GvKeinbOf7lptk5hi+Zk0fLdRHWDcqxT8um3OY94tHpitNV7zEe14nru0M5Rxjf+F77n41yna8237jp/zTiydTGTH3MRlx2iZrkx26nq9Zms9T79xMRa0y435Fvo9nw8K5ttFeUcTpki+PRZ81ser26euvXodTH5sH2mcfvit1MTWPVayehDRPsvi2vJdNm3jw/vF+V6TBScmo2nJjrg33Q1ivczk0sT1qKR7R83TzeJn2isdSgM91yZMN62pkw3nHlx2iYtjvHtNbRPvW0T9Yn3hdAAAAAAAAAc0pfLlx6fFS2TLmvGPFjpWbXyXn6VrEe8zP6R7p5h8XU49o8W8eW98nimmz44zabaMeONRvmupMe000vfWnrP0+bqJrET9ayaItxnjHIOZ73i47xba8u47hlrOT5WOYiMeOP5suS1piuPHX73tMRH69zETNcnItg8S4PwPjjesG8cwzY5x7jynT920231tHVtPtnfXqtMTMX1Ux3Me2Prvutp5L5GtrNnzcL4RsuPi3FMtu82iwZrZdVuUx9L67U2/Nnnr6Y46x1769M9RKGJ7D9ZmZmZmbTNp7mZn3mZmfeZmffsBQAAAAAABKvGu+8D45yfLuHkjguXluzZds1ukrocW45NFfFqsmKa4NRF6dTb0W/wBMz1+abfWsRIRUU4q3pipXLf13isRa3XXc9e8qgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUYs2HPWbYMtMkRPUzS0TET/YFYAAAAAAAAAAAAOrFq9LntNMGpxZLRHfVLxM9f2B2gAAAAAAAAAA2M+Ejinwd8n23nf/pScs1Wza7S6HHfj/p3DNpK27rk+ZbD8qY+dni0U6x29UdTHVfeS3BrmOKzjtWLYpyzSY7rOasVyTH29UR7RP6xH3cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArw5c2m1GLV6XPlwajT3jJhzYbzTJivH0tS1epraPtMTEp9bzFr+QYI0flTjG287pTH8vDrdZe2j3XDWJjqtNfgj12rHU+2WuXuZ956Y+DNE+jjPiXkuW9uMeR9XxnPeZjFt/LNBM4pt1M9/j9JF6Vp9IicmGk+09uM/gvyj+HvuGycdxcm2+lYvXXcc12DdMWWOu/wAlcFpy/t744nuJ9kCMX+Rqseuwf5epwz3jzU9r0n9rR7x/ZMo9277Fv/HqzbkWwbptER//AFHQ5dL+3/5la/eYWn/Edv8A/wBfp/8A6tf/ADTbafL3ljZM1c23eTuV19FfTWmXedRmxxH/AO3kvNftH2XWfiG82WvOS/kDLktMdd5tr0GWev63wTJ2Maf4jt//AOv0/wD9Wv8A5rrtGx77yGsW47sO57vE2mkf4dosuq94juY/y62+ybx8Q/m2JiaeQMuPqYn/ACdr0GKfb96YIn/mtG8eXfK2/ZLX3XyZyrLW8dWxV3jUY8M+3XvipeKfT2+nudj3x4N8n6fTRuHIdgwcW2+aza2t5Jr8G14qfp6qZrRl956iIjHMzMqo4t4n45ETy7yPreQauPa+38P0XeOkzHcTOv1la47V69p+XhyTEz9fZAsszn1OTWZp+ZqMs95Mtve95/WbT7y4UTy/ljPsePJpvFnF9BwfHmxzjya3TZPxu73raOr1/wAQy1jLjrPtPWGMXUx7SgubLl1GozavU5sufUai85c2bLeb5Mt5+tr2t3NrT95mZmVIYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAovmw47Vpky0pa89Vi1oibT+36qwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUYs+HPWb4M1MlYnrulomO/7ArAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6Nv1On0W5aLXavbsW46fS6rDqM2izW9OPVY6ZK2thtPU9VvWJrM9T7Wn2n6M7fGJ8QfjH4iOWcZ5B4y8Tf7D4Nl2m+36yt8Onx5NZab1tSJjBM1mmOIvFZme/8AMt7QwCGfYAAAAAAAAAAAAy38JXHvHXK/iV8ece8sYtJm4trd2mmswa30/hs94wZbYMWb1TEei2euKsxPcW7isx1Z9Sv4kXjvwxX4VOQ71v2wbLt+67JjxW4zqMOCmHNTXWyUrjxY5rETNbxM1tWPaazPb4s5MdMtJx5KVvW31i0dxK67zynlfJMOl03JeWb5vOHQ/wDuuPctzz6uun9uv8uMt7RT2mY/L0lm0WsBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABRlz4MERbPmx44n2ib2iO/+KtLfHHlDlPivcN33HiuHZ8uTe9n1Ox6uu57dTV0jTZ/T67Y4t/Jkj0R1b3j3nuJ9uolEdREfp7AAAAAAAAAAAAAAAAAknEuf73wvZ+W7HtO37JqdPzTaP8ABdwvuO3V1OXBh9fq9emvMxOHJ3M/m9/tPXcQjYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4vX1Vmvt7x171i0f3iYmJ/pMdJd5R8n8l8v8vzc35Zpdm024Z9Pp9LOPadBGj08Uw44pWYxxM/mmI9579/6REIkAAAAAAAAAAAAAAAAlPjffeCcc3/Wbj5E4Jk5dtuTZ9bpdNt9Nzy6H0a7JSK4M85Mf5uqfnnr395ieu4gEWAAAAAAAAAASfmPIuHb7tXE9Lxfx9i41rNn2Wmg3rU49yy6qN41lbzM6ua3iIxTNfrFe/5uveK1lGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHbpaaTJrNLj3HU5tNo76jFXVZ8OL5uTFgm8RkvSn+q1aeqYr95iIXjneg4XtfM9527xzyPcN/4vp9T6Nq3PcNH+F1Opw+iszbJi6j0zF5vX6R3FYnr3WIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASjx/wAv4/w3cN01nI/Gmw81w7htGq23Bpt3vkrTQ58vp9Osx+nvvJj9M9dxH809Wr79xcPYRExERM9z+oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrDjyanUY9Hp8dsufN38vFSPVe/Udz1Ee89R7ypfSf+Dnj8Yzm8g23Gm2zzydTpa6SdRNZ1H+Fzi+mGJn6fOjL6/THf8vft0luD5sT+XJkxT7Xw3nHkrP1pePrWY+0x+g3n/i408aU848Xnh1NtryOdmzzyb8H6PVM/Mx/hPnen/X6Yz/X39PX7NGFl0AAAAAAAAAAAAAAAAAAAAAAAAAmYiO5kie/eAAAAAAAF82rg3NN941vXM9l4rueu2Djk4K7vuWDD6sGinNf0Yovb/tW/SJ69pnqJ7WN68O8b1ptq1uxaXe9ywbXuVsWTW6DFrMtNNqrYrRfHbLiraKZJraImJtEzEx7A8gAAAAAAAAAAAAAAAAAAAAAAAAAAAOrLq9LgtFM+pxY7THfV7xE9f3dv194fbL+HNwrw7/6JfFdw4zsmzavWbtpb5OTZ8mDHkzZdx9Vq56Z5mJnqsxNa1n2ikREez5N/E/s/jvj/AMRPkPZPE2PS4+JaPe74ttx6S8W0+P8Ay6TnpimJmIpXPOatYj2rERWOoiISXRjEBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACZiI7mSJ794AAAAAAAAAAAAAAAAB79g2DfeVb5t/GeMbRqt13fddTj0ei0Wlp6sufNe0VrSsfT3mfrMxER3MzERMuvddp3TYd01mx75t2o2/cdu1GTSavS6inoyYM2O01vS0frFomP09vZ16HX7htWt0+57TuOr0Gt0mSubT6rSZ74M2HJWe4tTJSYtW0frExKnVarVa7V6jX6/V59VqtXmyajUajUZbZcubLe02ve97TNrWtaZmZme5mQdQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvXCuIb15B5lsXBeO1xTufIdy022aWcs9UpkzZa44vbr39NfV6p69+ol9APMX8JLRcE8NbpzPhXlTeN55XsG233HVaPW6bBj0OtjFjm+amGKU+ZjmYi3o9V7+/UT39UtwfOUImJjuJ7iRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAduk1Wq0Gsw7hoNTm02r08zbDnw3mmTHMx1M1tHU1nqZj2l1AObTN8uXPeZtkzXtly3me7XvPvNrT9ZmfvM+7gAAAAAAAAAAAAAAAAU5MuLDX15slaV+ndp6gFQAAAAAAALzwzk2XhfLtm5fg2fat1ybNrsOupot0034jSZ5x2i0Vy4+49Vfb9fr1P2eTft3zch37c+QajQ7fosu6a3Ua6+m2/T/ACNNhnLkteaYsfc+ilfV1Edz7R9XhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXDauQ8i2HFqMGw8j3ba8WsjrU49Dr82npqI666yVx2iLx1HX5u1urWtKxSlYrWsdRER1EQ5AAAAAAAAABJ9x5NxTVeNNi4fovHWh0XI9t3TV63cOU01mS+o3LTZO/laa+KY9Na4/V7TEz/ANXHtHqnqMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA92xbpbYt+2rfqaHRa6216/Ta+NLrcPzdPqPk5a5Pl5adx6qW9PptHf0mXu5zym3OOZ75zK+x7Ts1t712XWzt+06b5Gj003nv0Ysfc+mPvPv7zMz91jAAAAAAAAAASTl+p8b6jb+MRwHaeSaLXYdlw4+SW3bUYcuLUbpEz83LpYxzM1xT7dRbr6R1WJ77CNgAAAAAAAAAAAAAD1bVtmu3vdtBse2Y6ZNbumswaHTVvb01tmzZK46RM/aPVaO5+0Po/yP+Dvj27xbqd02bzFuGp51pNDbUzp82hxRtefPWvqnDWtY+dSJ6msXm9upmJmJ+ky3B81hTjvOTHW80tSbViZraOpr+0/uqUAAAAAAAAAAAAAAAAcZL0xUtkyW6rSJtaf0iGX/AC58KfmXwf464h5R8hbdtGn2Xmc46aKml185tTp8mTBOemPPT0VrWZx1vP5LXiJr12xDMRMdTHcSlXKfKvk3nHGtg4bzLnu9bzsXFaTTZtv1eo9WHRxNfT3EdRN5iv5YtebTWszETETPa6IqAAAAAAAAAAAAAAAAAAAAAAAD37Dvu78W33beT8f1ttHumz6zDr9Fnr9cefFeL0t1949VY7j7x3Dbzyp/FK83+UvEm4eMMnEOP7Dq960U7fue+7fqM05cuG9fTl+ThtHWC14mff139Pft39Wmglmh9PaAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE88D+Otl8ueZuIeM+R8rrxra+Q6+2m1W6TNInBSuDJl6rOT8kWtOOKR6u47vHtIIGMp/E54i4v4K80754x4fzmOWbZtdNPeuut8v5uO+TFF7YMs4/wAk3r333WI9rV9u4liw9gAAAAAAAAAAAAAAAAAAAAAAAAlXjHyJunirl+PmezbJsO7anHotXoY0296CNZpprqMU47X9EzExeIn2tExPU2j6WlFQFGDFGDBjwRPcY6RTvr69R0rAAAAAAAAAAAAAAAAAAAAAAAAAAAEy8M7r432LyzxPefMOxZt64To9ypk3vQ4qTec2n9NojukTE3rW80vake9q1tXqe+pk/wAU3IfA/KfNO6b18N/G77JwrLpdNTHp/wAJbSYsmritvnZcOC3vixzHy49PVe7Vvbr83c4mDO9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGyHwn7V8G+v4f5IzfE7u2v0m+Y9FWvHox5tTWsYvlzM209cMfn1PzYiOrd/l9PUdTbtbg1vHXppzTpsU6j/rfRX1/97r3+n7uwAAAAAAAAAAEo5V4z5nwri/DuY8k2vHptr55oM+5bJkrqsWW2bT4r1pa160tM45n11mIt1PU+8RMTERdx6azNLTWO8dZpSev5azabTEfpHqtM9frMz93IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOzT6nU6LU4NdotRfT6nS5aZ8GbHPVsWWlotS9f3i0RMfvDdXkP8WLz5vvivNwLDxXj+37/AKrQzoc/KcOfJbL7x6bZsemmvopkmvfUze0RaYnqeumkwWaKcWOmHHTFjjqtKxWsfpEKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIuL7VwjcNk5XrOV8u1m0bntu20z8e0eDQWz03TWTeYthyXiJjFWI9M+qZj+aZ76rMI6Dlw8fLhz587ztnKzJczjkkyZJcubdtu25kyS2gDqgAAAAAAAAAA4vjplpOPJSt6z9a2juJcgKceLHhpGPFjrSsfStY6iFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACT8M1HjLBt3LK+RNn5Hrtdl2W9OL22jV48OPT7p649N9TF/wCfF19o79vX+WZmvUYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEp8eeM+YeU9z3TZ+F6PSanV7Psur37U01Gsx6aPwumivzPROSYi1/wA9eq+3f6wi0TFoiY+k+4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOY6+4OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASTxxx7i3K+bbXx/mvOMPENl1l8ldVvObQ5NXTTRXFe1e8dJiZ9V61r331HqBGxXlrjpkvTDqI1GOtpiuWMdscZI+1vTb3r39ep94+6gAAAAAAAAAAAAAAAAAAAAAAHFseO893pW0xFq9zHftMdTH94mYn9nIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD6Mfwq/hw8IeVOLcx8heSeJ7Nyzetr3qm16TRbpgrqMOhwRp8WWMkYrx6fXe97/n6n2pERMe7D38TDwz4m8Leddr2zxPtmj2bDveyV3Hctl0XVNPocsZbY6Xx4o9scZa1mfTHVe8czERNpmZveDUgBQAAAAAAAAAAHqzbVu+m23S71qdm3HDtuvvfHpNdl0mSmm1N69+quPLNfReY6nuKzMx1P6S8oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALhx/jvIOW7zpuOcV2Hcd53XWer5Gi2/S5NTnyRWO7TFMcTbqI95nrqPu8WfBn0uozaTV6fNp9Rp8l8ObDmxzjyYslZmtqXraImtomJiYmImJiYlk34b/iA5P8M3lLB5S4psm27vqaaDU7Zn0WvtemPLgzTS09Xp70tFsVJiep9otHXv3EW8nc/wB38reReSeTOQabSafcuTbhk3DUYdJSa4cdrdRFaxMzPUVrWO5+sxM/c70RgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEo8e+UvJPiXd82/eMec7xxjcNTijDnzbdqJp86kTMxXJSe6X67nr1Vnr1T113K0ci5FyHl++6zlHLN93Ded33C/zNVrtfqb58+Wft3e8zPUR7RWPaI9oiIW4AAAAAAAAAAAABn/yB8YnK/IHwx8P+GHU8F2Tb9s4nGixzu+HPe+fV00uOa4/8qaxGK1pmLXtF7d9THX5pYAAkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEm5TxTj2wcZ4fvmz+R9o5DruR6HPqt02nR4bUz7Blx5K1rg1FptMWteLTMTEV/kn2mOpRkAAAAAAAAAAAAABxa1aVm1rRFYjuZmfaIByKceXHmpGTDkres/S1Z7hUAAAAAAAAAAAAAAAAAAAAAAAAACT+ONL421nK8Wn8tbryLbeOW0upm+p2HBhy6qupjFM4ImuWJr6Jv1FuomfePpHcwEYFOKck4qTljq81j1R+/Xv8Aef8AxVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL1wriuu51zLYOEbZrNJpNXyHdNJtWDUavJFMOG+fNXHF7zMx7RN++o9566j3mFlcxM1tW9ZmLUtF62iepraJ7iYn7TExExIM0fFX8LvIvhT53t/Cd+5dtnI67pttdx0+r0eC2nmseu1LUvite81mJrExb1fmifpHUsLPVue67tvettuW+btrtz1l61pbU67VZNRmtWv8tZvkmbTEdz1Hfs8pAAAAAAAAABJOI8u27jG28q2/X8E45yK3JNky7Tp9Tu2lnLm2fNeYmNXpJ7/ACZa+/v/AN2e466kI2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADu0Wj1m5a7S7ZtulyanWa3Pj0umwY+vVlzZLxSlI79u7WtER37e4Okbq8y/hSeeeIeKdT5Dry3j26bzt2jvr9bxrS6fLGWuOlJtemLUTPpy5IiPaPRWLT7dx9WlNL0y0rkx27reItE/rEkujkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB3aPVZtv12k3HT1w2zaLU4tVirnxRlxWvjvF6xek+1qzNY7rP1juHSAkfkbnu+eUedbz5C5Lp9swbnvmemfUYtt0kabS45pipirXHiiZ9MenHX7z3Pc/dHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABc83F+S6fjGl5rn4/uOPj+u12TbNNul9LeNLm1VKTe+KmXr02tFYtMxE/wCm0fWJ6C2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPdsW9bjxrftr5NtF8dNfs2v025aS2Ss2pGfBlrlx+qImJmPVSO4iY9vvDwgPpXzX+MDt++eJtbs3G/EW66LnO47dbSWzavU4b7Vps16em+Wtq3+dkrHczWs0rM+0TNfeXzRwYq4MOPBSZmuOsUiZ+vUR0rEkwAFAAAAAAADrv2nNTF37fMvW1q0/eYrE2mI/SImf0AEm8k8X41wzmm48b4h5D2/m+06ScX4fe9BpL6fDqPXipe0Vre1pn02tNZmJmJmv294iMgAAAAAAAAAAAAAAAAAAHcTMxEx3H1Ep5J5B3Hk3DuJcJz8f43oNJxDFrMeHV6Da64dZrp1GWuSb6rN3M5Jr6eo+nfczPc9dBFgAAAAAAAAAASTlnF+Pce2bie5bH5D23kmp5BtEbhumh0mlyYcmxaibRH4PNa1pjJfrue4iv8v06mJBGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6dt02n126aHQazccW3afVavDp82ty0m9NLjvkrW2a1a+9q0iZtMR7zFZe/mGy7Vxvle7bBsfKdJyXbtv1NsGl3jSYbYsOupERPzKUtMzEdzMfWe+u4nqXL+bhPLPD38rLfVzJZPefHe51u33Jkq51qzgOqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMxWJtaYiI95mfsPbsm7anj++bbyDR6fR6jUbVrdPr8OLWYIz6fJfDkrkrXLjn2vSZrEWr3HcTPvH1B4q2raItWYmJ94mPuLzzLlGr5vy3eOY6/bNq27U71rcuuzaXatJGm0mK+S02mMWKJn0x3P6z3MzP3WYAAAAAAAFF8+DHeMeTNStrTERE2iJmZ+n/Hqf+AKwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF1zcq5NqOLaXg+fkO45OPaLX5Nz02121N50uHVXp6L5a4+/TFprM99R/qtP1mZm1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJb4x3vx1sHI9XrvKHB9XyvZ8u0azTafQ6bcr6K+LXXrWMGom9JiZrTq/de/9UT7zEAiQpxVvTFSuW/rvFYi1uuu5695VAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPRt2HQ6jc9Fp903C2g0ObVYcer1ddPbPOmwWyVjJljFWYtkmtJtb0xPc9dR9XnAXznW08Z2Hmu+bJwzlX+02w6HW3w7dvH4O+k/G4YiOr/ACrzNq+8zX9J9Pqj2mFjAAAAAAAAAAAAABK+NeT+YcR4ZyzgOxajQY9o5rTR492jNoaZc8102WcmP5WSffH3Npi317ifbqfdFAAAAAAAE/8AAHjTQeZPN/CPFe7bpl27Q8m3amj1Wpw9fMrhil8l607+lrVxzSJ+02iep66fR74v/wCHh8N/Cfh05Rz3x3ses45vnCtpy7ng1M7rqM9dZXDHqtizVzXtW03iJrFoiJi0x1+j5WbXuu6bFuek3vY9y1O37jt+emp0mr02SaZcGak91vS0fSYmP/P2Zi8rfGd8SXmnhmn8f+QPJGfV7HjrSNVp9PpMGmncJpMTW2otjpE36mO/THprP3rLNlowmA0AAAAAAAAAAAAA3e/hy/Bd4w+JXbeWc78s6jcNdtmxa6mzaTZ9Hq76SLZpw0zW1GTLimMk+2Sta1iYj2tM+r29MF/iDfC1wz4XfJ+xbf483DWW4/yvbs+u0+g1mec+XQZMF6UvWMtpm98dvmVtX1dzExaO5jqIm94NWwFAAAAAAAAAAAAAAAUZ8sYMGTPaJmMdJvMR9+o7S3yX443vxVyq3Ed/3XYdx1UaPTa6uo2TcI1mmtiz0i9I+ZFa9XiJ96zHt7fWJiQRUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbFeUuDfB/tPwv8B5Z408iavXeWdfGlnftqvrrZrxa2KZ1Nc2n/l00Y79RWY676iO7dtdSXQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlTwH8TnmP4aN31+6+Kd/02nxbtWkbht2v0v4nR6q1ImKXtj9VbResWmItW1ZmPae4iOrJ5j82eSvPnMsnO/KPIZ3Pc7Yq6fDTHjjFp9LhiZmMWHFHtSvczP1m0zPvM9R1Bgz7AAAAAAAAAAAAAAAABxSlMcemlIrH16iOnIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACV4eCYM3i3VeTJ5vxvHm02+02WOPX1n/ALUy1tgjL+JpiiJ/y47mJ76/lme/tIRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASnmOn8Z4dg4bl4HuPINRvObZ/VyzFuePFXBg3L1x1XSzSIm2P0+r3tM/Svv36kWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVzhzxgpqp0+WMGS1qUyzjn0WtX+aIt9JmPvEfRQuOp5Fvms2PRca1W5Zcm17dky5tLppivpxXyT3eYnrue57+sz13LfH45flvrr/dnvvqZv77zpz53yS8f45M3vbnWX11du51cmbd6y24Bh0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsJ8Gniz4cPKvKeWbd8Rvkj/AGT0W2bPTV7TNtyx6CmfLNr/ADsk5Lx1acVa45infv8AMnuJ69sC7pg2/S7tr9Js+4zuG34NZnxaPWTT0zqtPXJaMWaa/b10ituvt6jR5QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF44dxPeue8t2bhPHK6W26b7rcOg0v4rUVwYYyZLRWLZMlvatY77mfeeonqJnqJs6nJjx5aTjy463rP1raO4kFz5HsOv4ryLdeL7rfS31uza7UbfqbaXPGfDbLhyWx3nHkj2tXus9T7e32j6Lc4pSmOsUx1itax1ERHUQ5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAe7Ydl13JN+2vjW2W09dZvGu0+3aa2pzRixRlzZa46Te8+1a+q8dz9o7+rwuL0rkrNL1i1bR1MTHcTAL9zvhe9+OeZ7zwPkeTQZN02HV20WqvoNTGo09r16nvHkiI9Ue8faPfuPssSnHjx4qRjxY60rH0rWOohUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACU7d4z5huvjPfPL2j0mknjPHd00uza7LbV0rnjU6iKzjimH+a1fz17t9u/v1PQRYAAAAAAAAAAAAAAAAEl0Ww8Pz+Nt45RredxpeU6PeNLotv43/AIZlvOt0d6d5tT+JifRj9Ez/ACzH+iY+t69BGgAAAAAAAAAHF71x0te3fVYmZ6jv2/o5J76/Le1Z+1q2mJj94mPeJBPfJ/gbzD4X0ux63ylwHcOPYOR6e2p26+oviyRlivXqracd7ei8Ras+i3U9W+ntPUCZQ8yfEx5p8/bbx3aPKnLKbrpeL4Jw6GmPS0weu81its+b0/z5ZisRNo6j69Vjti8n9gAAAAAAAAAAAAAAAAAAAAACiM2G2WcMZaTkrHc0i0eqI/orSfcvIm/bp422HxXqNv2PHs/Hdx1e6aXU4NujHuGXNqJtN65tR33kpHrn016jrqvvPphGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABK+L8k4TtPDuYbHyHx9Te963rDoqbJu9txyYZ2fJizTbLauOtesnrpMRPc+/piJ9kUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEpp435Bfxlfy1/iOwV2Sm9xsH4a26U/xG+p+R87uumiJn0en7zMT7TPXXvMWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABxa1aVm97RWtY7mZ+kQDkXDfeO8h4vrqbXyfYNy2fWZNPi1dNPuGkyabLbBlr6seSK5IiZraO+p669pj6xK3gAAAAAAAAAAAAAApvlxY5it8lazb6RMxHfvEf8AjMf8VSU8R8k8p4RxzmPFdgyaGu38723FtW8RqNHTLknT472vEYbz74rTN7RMx9YmPvETEWAAAAAAAceivcz6Y95iZ9vrMd9T/b1T/wAZ/VyAAAAAAAAAAAlG7U8aV8dcatsmTkdub31evnkEaqcP+HU00ZIjSxg9MRebTT3nuZ6mbRP+nqLgAAAAAAAAAAAv/B+A828m8jx8R8e8Y1m/7zlwZtVXR6T0Rf5OKvqyX7vatYisdff7wsD07dum67Nq41+y7tr9t1Va2pGo0WqyafLFbR1avrxzFupiepjvqY+oPNHcxEzW1Z+8WrMTH7TE/SRxWtaVilKxWtY6iIj2iHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnvgnw7vnnzyvsHifj+76HatXvuTLX8drY9WLT0x4b5bW9ETE3mYp1FYnvu0faJdvnvwxvXw/eVd78U7/AL5t28arZ74+tboYmtM2PJjrek2pMzOO/Vo7pMz1+s9m/Qx6AAAAAAAAAAAAAAADmtb3vXHjpe98lopSlKza17TPUVrEe8zMzEREe8zL07ptW77Hr8m1b9s+4bXrsVa3vpdfpMmmzVraO62nHkrFoiY+k9dSuPB+XbhwDmmw862rR6PV63j256XdNPg1mP14cuTBlrkrW8fpM1j3j3j6x7wyZ8VHxPch+Krn2j5zv3Edr47G37dTbtPpNFntqLTWLWvN8mW1azaZm89R6Y6iPrJ9jDAAAAAAAAAALnx/i/KeXa2+28R4rve/6vHT5uTT7TtufWZaU9/zWrhraYj2n3mPtP6PDqtNqtDqs2g1+kz6TVaa84s+n1GK2LLivH1reloi1Z/aYiX1I/hH+RPDOx+LuT8S1e9bTs/OL73k1u4RrtTjw5ddpPlY4wZMXrn82OkRakxH0tFpmPzdzrB/Ey5n4x5v8UGs1/jXX6HcZ0Wz6XQb1rdDkrfBl3DHkzeqvqr7WvSlsdbTHfvER9aykveDVEBQAAAAAAAAAAAAAAeva9n3nftZ/h2wbLuO66v5ds34bQaPJqcvy6/zX9GOs29Mdx3PXUdx39XkZt+FH4p+RfCfzLe+X8f4btPJJ33bK7dm0+uz309sXoyeul6ZK1tMR3Mxavp/N+X3j0+6jCNL0yUjJjtFq2juJifaYcrjyTfNVyjkm8co12DT4dTve5arc82LT09GLHkz5rZbVpX7VibzER+kQtwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKflYvmfO+VT5nXp9fpjvr9O1QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKcmOmbHbFkjul6zW0frE/VUAvnMeb8w8g7xj5Bzjkmv3zccWkw6DHqdbmnJemnwxMY8cTP0rXuf+Mz9ZWMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZX8CfC55r+JbXbjpvFPGcGp0u0emuu3PcNVGl0WHJaO64vmdWtbJMe/prWeomJnruO3oYoEs8peKfIPhXmur8e+TeO5Nm3zR0rmnFOSuXHmwXm0UzYslZmL47TS3U+0+0xMRPsiYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAO7R6zW7drMG47brdTotZpbxlwanTZrYc2G8fS1L0mLVn3n3iYk1ms1m46vNuG46zUazV6m/zM+o1GW2XLlv116r3tM2tPtHvMzPs6QAAAAAAAAAAAAAAAAAAAAAAAAAAAAFGXBhz1imfDTJWJ7iL1iY7/ALqqUpjrFMdYrWsdRER1EOQAAAAAAB69oy7Vp9523U77t2XcNrwa7T5dfo8WotgvqdLXLW2bFXJX3pN6RasWj6TPbyAL1zXV8Q3Dl+8a7x/sWu2XjWo1d8m17drtXOq1Gl089dUvlmZm899+/c+0xHc9drKAAAAAAAAAAAAAAAAAAAAAAk3IeIbPsfDuKco0Xkfjm9a7klNbbV7HoL3nWbLOny1pWNT9onJFotH8v36i0d2iMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJFufAOTbRwfYfIutwaT/AAPkmo1el0OTHrMd83zNNf0ZIyYon1U9++pmPeI9+u4iY6pjHji85Ix1i0/W0R7/AG/8o/4Q5eTj5beN8fKSS97N2Zep3Mu5d76lmd7LM+1QDqgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA30/h0/G74i+HXhXJPHHlyus2rBrt2neNDumi23Jqq5fXhxYr4stcNbZPVX5MTFpiY9NojuOmhYWaNkvj0+JjjXxO+ZtNyTg2iz4uN7FtePa9DqNVppwajWW+ZfJky2pP5q07tWta2iJj02nr8zW0CTAAAAAAAAAAAAAAAAAAAB1ZdXpcForn1OLHaY7iL3iJ6/uDtHFbVvWL0tFq2juJie4mHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPVl2vdsG26bec+0bhi23W5MmHS67JpMldNqMmOeslMeWY9F7Vn2tFZmY+7yr3reb8x3Hh+1ePtw5LrtRxnYtVqNbtm1XtHyNJnz2m2XJSIjvu02tPvM9eqeuu1kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIdXq/Hd/He1aDQbDv2LneLd9Tl3Pc8utpbbc+2zSfk4sWHv1Uy1t6e56jvq3vPcRAR4AAAAAAAAAAAAZE8BeCua/Eb5L0ni/gWXbcG4Z9Lm1+bUbhmtiwYNNimkZLzNK2tNu8lIisR7zP1j6rB5M8fch8T+QuQ+M+Wfhf8X43rbaHVzpcvzcNremtq2paYiZia3rPvETHfUx3BojQAAAAAAAAAAAAAAAAAAAAAAAC57pxnkeybXs297zsO4aHb+Q4c2p2nVajTXx4tdixXimS+K1o6vEWmI7j9Yn6TC2Ltu/LeUb/s+x8f3zkO4a/beNYc2m2jS6nUWyY9Diy3i+SmKJn8tZtWvtHtHURHUR0C0gAAAPs5/DF4T4en4WNm3njm27ZuO97pn1X+02oz6el9R+NjNatsF5tHfy6VilaR9JrET799vjGuGz8i5Jx2c88b5LvGzzq4iuonbdwzaX50R9Iv8AKtX19fv2lmjL/wAa2xeM+N/FBz3aPE/4amxYdfjm2DSTE6bT6u2HHbUY8XUdRWMs37iO4i02j7dRhBTjx0xVimOkVrH2iFSzoAAAAAAAAAAAAAAAAAAAADuO+u47+vQk+bn+vzeM9N4ujj3HKaPT75ffZ3Su21jdMl7YJxfJtqO+5xRE99dd+0R31HuEYAAAAAAAAAABXjxZc1/l4MOTLeYmYrjpNrdRHcz1Hv7REyej30oCJiY7ie4kAAAAAAAAAAAAAAAAAAAAAAAAABnb4Ovhc1nxX+UdTwqeRX2LZ9m0P+JbtrcOOMmeMU39GPHirb8vqtbv3t3ERWfae4LcGCRt/wDHB8A+L4Vdm2XnXD+abjyHjO6auNs1GPc8OKur0mqnHfJW/rxRWlsdopaOvRE1tH1mJ9tQCXQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJuS6/xrquK8S0fD+Lb5t3I9HpM9OUa/W7hGbTbjqLXrOK+mxdz8qtaxfuPy/wA0R1bruIyAAAAAAAAAAAAAAAAAAAAAAAAAAADi09VmYjvqPo5AZB554qwcJ4dsPKK8o024ZN4msWwY8fpivqxzeJpPqnuI66nvr3mPp9GPnP8AprX/AE0iYrH2jv3npw8n4Xh8/g8Xw/J8v8nLbdycerepk/U6e7/kPyPxvyfN8/xPD/FwyT4/K8u5JLdvfd7AHreEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABdOMcp5LwrfdNyfh+/wC47Ju+j9XyNboNTfBmxxaOrRF6TE9TH1j6S8ev3Dcd212o3Td9y1m4a7V5LZtRqtZqL58+bJae5tfJeZta0/rMzLzgAAAAAAAAAAAAAAAAAAA32+En+GRtfnnw7ofLfkTyJvew15FTLl2bQ7Th08+jBXJalM2a2Wt/X6/T6orX09VmIme+2o3nbw/vfgXyzyPxPv8Arseu1Gw6muPHrcWP5dNVgvjrkxZYr3Pp7pevcdz1aJhJdECAUAAAAAAAAAAAAAAAAAAHFrVpWb3tFa1juZmeoiHL2bNu2s2Dett5Bt3yZ1m067T7hpoz4oy4py4ctclIvSfa1fVSO6/eO4B4ceTHmpGTFkrek/S1Z7if7ql85xzLevIfMd451yONHG6b7q7a3VxotNXT4IyWiIn0Y6+1Y9o9vf8AWZmZmVjAAAAAAAAAAAAAAAAAAAAAAAXHYeQbzxjcY3bYdffR6uMd8PzKxE/kvHVo6tEx/wAvstwz5PHw8vG8PJJZerL3L/rfi8vPwc55PFyvHlO5Zcsv7lno9/vMz+8z7yA0wAAAAAAAAAAAAAAAAAAAAAAAAMp/Df8AEXzn4Y/I+PyHwnBpdb83T20W47Zq5muHXaa0xb0TeIm1LRatbVtET17+0xLFgexsN8WXxseRvi0tsu2cg4/tnG+O7Dlvq9PtWizX1FsurtSafPy5r1rM+mlr1rWKxEeu0zM9x6deQJMAAAAAAAAAAA+sWtH0rMRaf0mfp3/UZA4x5Uw8c8b73wKeM6fUZd2+b1rLX66+ZWK93r6fzTWI9vf9Hk/M83n8HCcvx/H/ACW2SzZxyW93b+p3n2934H4/435Pk5cfyvN/FxnHlZfjeW2Trjk/d+/UY/Aet4QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATDxH4k535y59t/jTxvtWPXb3uNcmWsZ8vysGDDjiJyZsuTqfTSvcR31M92iIj3ZL+JH4KvNXwv7ZtG/8APMG07js27WjTTuOz6jJnw6XV+n1fJy+vHS1e4i3pt11b0zE+meolsGBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJOX8l4xyDb+M6Xj/AI80HGdTsuzYtu3TU6TW5c87zqqWtNtZkreOsd7RMdxXv9JmYiEbAABtx8Nv8SPyr8OnjjH4wrwzZ+W7VoL5LbTfW6zJpMuipe03nFM0paMtIta0xExWYieu5hrZ5K8icq8uc/37ybzfU4M++cj1f4vWW0+L5eKsxSuOlKV7mYrXHSlY7mZ6r7zMo0JkgAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJPx3i3Fd44dyvkW8+S9t2LddiporbVsefRZMuffJzZbUy1w3raIp8uIraZ6t1E9z1HuCMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzl8GnxFaP4YfOGk8jbxseXddn1W3ajZ9yxaaKficeDNbHeMuKbTETNb4ad17jus2+8RDYH4+/4gHj/4iPHmi8R+Jtl3bJtmfX6fct03Xc9NGm/6mZtjw4cczN/V6+pta0RHUdR333Ghgmd6ACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7dJpNZuGrw7ft2i1Os1epv8vBp9Nhtmy5bdd+mlKRNrT1Ez1ET9JdS9cL5pyrx1yza+dcH3vNtG/bLmtn0OtxUpe2G9qWx2mK5K2rPdL3r7xP1BZpratrUvS1L0ma2res1tW0T1MTE+8TE+0xPvDh36/Xa3ddw1e7bnqr6nW6/UZdXqs9+vVlzZbzfJeeoiO5taZ9oiPf2iHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACU+MPGfMvMXPdm8a8B26ms3vfM84dPXLknHhxxWtr3yZbxE+ila1tMz1P2jruQRYbRfEt/D18w/DRwfB5F3bfdl5RsVM2LBuWfbMeTFfb75JrXHN6ZP58c3tFPXWe4ma91iJmY1dJdAAAAAAAAAAAAAAAAAAAAAAAFeKmHLlpi1OrnSYb3rXJqIxTknDSZ6m/oj3t6Y7n0x7z10CgbBfF34v+GXxjr+G6X4c/LGTmkbjteTLvfWvw62uHJWcc4str4vT8q+WMlv8r09dY+49Pv6tfSXQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABKvGuo8XaXkmoy+X9p5FuOx/4XrK6fDsWox4dRG4emPw17WvMROOJi0THf1mvcTHYIqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ+PN54nx3nex79zviM8p49oNTbLuGzRrb6T8Zj+Xeta/Np7x1eaW6+/p6n6gjw7tZl0ufXarUaHQ/gdLm1GXJp9L8+2f8PiteZpi+Zbq2T0VmK+uY7t13PvLpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASblezcD2zjnDtfxLmur3reN123NqOS6DNtt9NTZ9XGWK48GPJb2zRNfVM2jv+WJ9otEIyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9mTZt6xbNg5Hl2XcabRqdTfRYNxtpMkaXLqKV9VsVc0x6LXivvNYnvqJ9vaXjXrPzXl2q4bo/Hmo5Hr78Z2/X5N00u1Tln8Ni1eSs1vmiv+9MWt/xn9VlAAAABRnrkvhyUxX9F7VmK2/SevaUr8kb9wjknJ67l484HbiGz02/R6adutueXXTfU48fpy6icmSImPXPX5Y9vy+r62lFwAAAAAAAAAAAAAAAABkr4cvNu4/Dv5k4/wCWdv2iu612nJlx6vQzeKW1Omy47Y8lKXmJit+reqszHXdYieomZY1Ab+fGF/Ew43548P6zxN404Hv+0f47fTzuu4bz+Gj5eDHkplnFipivk9VrWrFZtPp6j1THc9NAwJMAAAAAAAAAAAAAAAAAV4cObU58el02HJmz5rejHix0m172676rWPeZ6ifp+jrrat6xelotW0dxMT3EwDkAAAAAAAAAAAAAAAAAAAAAAAGbfhA8meGPE/mGnKvOfAv9qdgna9VpsGP8Ji1f4TVXmk0zfJyzFbd1rkp39a/M9vaZmMYc+3ji/IOc8h3zhHGLcc49r901Wo2varWi06PS3y2nFj/LM1r1WY/LWZrX+WJmIhYQzvQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABnn4HPD3CfOnxKce4B5EvN9inS6vcc2ji80/H3wUiaaebRMTFZ9U2mI95jHMfSZbm/xIPg7+Hzx54Ey+VvG/DNq4Xvexa/RaatNtp8jDuOLPnritiyY49rXiL+utuotHonufTMvmRsO/77xXe9DyXjG86zad32zNGo0eu0ea2LNgyREx6q2r7x7TMTH0mJmJ7iZhMfKXxAebfNum27ReWfJu88m0u05LZdHp9V8rHhxZJr6ZyTTDSlb39MzEWtEzETPUx3PebLaMfgNAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAO/8AA6+NBG7Tt2sjQTqPwcaz8Pf8POo9Hr+T83r0fM9H5vR36vT79dOgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9v9Xq6+/piJn+0TMd/wDGABc+R4OOabeM+Die467X7XX0fJ1Gswxiy3n0xNu6xEdRFu4j2j6f3m2A3z5fPleWSb9T1P8APfX/ANc/Fwvi8fHheV5ZJNubf7uSTb95J/gAw6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM7/B18Nmw/FD5I3ThHIfI+PiOn2zabblW1aY76nWW9cU9OKuSYr6adxN595iLV+nfbD3LtgrxPl2/cTru+m3WNj3TWbZ+O01Zri1XyM18XzaRPfVbejuI7n6/WfrNotSl/56Vt7THvHftMTE/8YmY/pJWtaVilKxWtY6iIjqIg+xyAAAAAAAAAAAAAAAAAAAAAAAAACQ+Pefcq8W822jyFwjco0G+bJmvm0eecNMta2vivit3S8TW0TTJaPeP3+yyazV6rcdbqdx1+ec2q1mbJqc+Wa1rOTLe02vaYrERHdpmeoiI9/aHSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlPK+O8O2fifC9545zzHvm7b7otZm37bK6DJgnZc+PNWuLDN7T1l9dLWn1R7T6JmPaYBFgAAAAAAAAAAAAABKOEbr442zTcmxeQuG7vv2bXbJm02wZdv3T8H/AIbuc2iceoyx11lxx1PcT6uuv5LeqeouAAAAAAAAAAAAAAACVb9423/jfA+L+RNx3Pj+TbeX31tNv0ul3SubXY/wuSMeS2fDWP8AKj1T7fmmfp3ET7AioAAAAAAAAAAAAAAAAAAAAAAAAACT8k4ZoePcS4lyfDzrjm7ajlGHWZ8207fqbZNZtMYMtccV1VZrEUtfvuI/7M9d9dowAAAAAAAAAAAAAAAAAAAAAAAAAkNPIXOsfBcnjCvKtf8A7JZdyjd7bRM1nB+MjH8v5sd19VZ9P2i0V79+u/dHgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1/iNP878P8/H83/c9Uer6d/T6/QHYAAAAAAAAAAAAAAAAAAAAEzEfWYjv2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABK9N4z5Jq/F+t8vYtbsddi0G9Y9iy6e+5VjcLai+KMkWpp+pmccRasTaZiff6dR2igAAAAAAAAAM9fBv4++G7yP5F3jZ/iY55PGtm0+0W1G2Tfcf8AD8Wq1MW/zIvqJ9qzSnVq07j1d2+vpnpbgwKLpynRbBtvKd723im8Zd22TR7nq9Ptm4ZaRW+s0lM1q4c0xHt+ekVt3ERE999R9ItYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACmuLFS9stcVIvf+a0Vjuf6yqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAXjU8N5jouK6LnWs4jvmn43uOe2m0m8ZduzU0WfJXqPTTPNfRPcz1Hv7zExHcxPQWcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASHx9wjdfJXNtn4Dse47PoNw3vPbT6fUbvrfwmkpaMd8n+Zl9NvT3FJiPae5mI+6ya3SZtv1up2/UXw3y6TPk0+S2DLGTHa1LTWZpePa1ZmJ6tHtMdSDpAAAAAAAAAAbHZ/iY8Wz8F+H4bNJ4Xrj5dXX11OTkWSuC+CZ/GTntqIv6vnxlmkzjivXpr3136Y6a4hZoAAAAAAAAAAAAAAAAAAAAk/D+eajhuycx2XT8Y45uc8x2b/Bcmr3Tb41Go27HN/VbLpL9x8rJaO4mep94pP+nqYwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKflYvmfO+VT5nXp9fpjvr9O1QAAAAAAAAAAAAAAAJH444Punk3yDxrx3s2WuHWcl3bS7XjzWiJjDGXLWtskxMx36Kza3Xcd+nqPeUcevad23TYd10W+7HuGbQ7jtupxazR6rDPV8GfHeL0vXv27i1Yn3iY9veJgH028+/wqvFPDPBe+8q8bco5FHLOM7Zk3S+fctVTLp9yjBim2TFbFFa1xTeK2mLUmPTaY79UdxPy+bUeXP4kHxEeYvFefxTvn+zm3aPdtJbRb3rtv0N6ancMNuotSPVktTFW1e639Ne5i09TVqunHfsAFAAAAAAAAAAAAAAAAAAEl3HxxzXafHex+V9x2S2Hi3I9x1W1bbrpz4p+fqNP38yvy4t66x3W8RM1iJmlv+z3GldsuS+HDp75LWxaebzhpM91xzeYm/pj7eqYiZ6+vXuoAAAAAAAAABzWt73rjx475L3tFKUpWbWvaZ6itYj3mZmYiIj3mZBwLvyfh/L+E7hTaeacS3vj+tyYa6jHp9127NpMl8VvpetctazaPaY7j7xMfVaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVY7YqZaXz6aupxVtE5MNslscZaxPvSbV/NXuO47j3jvuEj8kcp47zTm+6cm4l472vg20a22KdNsW2ai+bBpfThpS/pteK/zXra89VrH5vp33MgEaAAAAAAAAAAAAAAAAAAAAAAZ15J8YPkrlHwv7N8K+47Xsscf2e2lpG40w2jV5dNpssZMGKY79ETFq07vEd2iJjqO5kDNGCgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcWrW9ZresWrP1iY7hzEREdRAAAAAAAAAAAAAAAAAAAAAAAAAAk+3Y/G1vGu/X3XUchpz2m66KdlphrinbMm3TWY1MZZmPmRlie5j3iP+r6/1owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD27HvGu45vu18k2v5P43Z9fptx0vzsfrx/OwZa5aeuvceqvqpHcdx3HcdwAMtfFF8UnNfir5bs3KeZbLtW1f4Ft9tBpNNt8X9P57xfLe1rzMzNprXqPpX0/fuWGAPQAAAAAAAAAAAAAAAAAAAAAAAAAAAA//9kK");ye.background=Da;const Ja=new an().load("data:image/jpeg;base64,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"),ln=new Zt(new In(3,3,3),new yn({map:Ja}));ye.add(ln);const Fa=new an().load("data:image/jpeg;base64,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"),Ba=new an().load("normal.jpg"),Pe=new Zt(new Lr(3,32,32),new Un({map:Fa,normalMap:Ba}));function Jr(){const r=document.body.getBoundingClientRect().top;Pe.rotation.x+=.05,Pe.rotation.y+=.075,Pe.rotation.z+=.05,ln.rotation.y+=.01,ln.rotation.z+=.01,Re.position.z=-.01*r,Re.position.x=-2e-4*r,Re.rotation.y=-2e-4*r}ye.add(Pe),Pe.position.z=30,Pe.position.setX(-10),ln.position.z=-5,ln.position.x=2,document.body.onscroll=Jr,Jr(),function r(){requestAnimationFrame(r),Dn.rotation.x+=.01,Dn.rotation.y+=.005,Dn.rotation.z+=.01,Pe.rotation.x+=.005,on.render(ye,Re),on.setPixelRatio(window.devicePixelRatio)}();
